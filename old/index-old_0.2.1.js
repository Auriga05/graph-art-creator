// ==UserScript==
// @name         Graph Art Creator - Experimental
// @namespace    http://tampermonkey.net/
// @version      1.0a
// @description  precal thing
// @author       Auriga05
// @match        https://www.desmos.com/calculator*
// @icon         https://www.google.com/s2/favicons?domain=desmos.com
// @grant        unsafeWindow
// @updateURL    https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js
// @downloadURL  https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js
// @require      https://code.jquery.com/jquery-3.5.1.slim.min.js
// @require      https://cdn.jsdelivr.net/npm/evaluatex@2.2.0/dist/evaluatex.min.js
// ==/UserScript==
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/Graph.ts":
/*!**********************!*\
  !*** ./src/Graph.ts ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Graph\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass Graph {\r\n    constructor(expression, graphType) {\r\n        this.color = expression.color;\r\n        this.hidden = expression.hidden;\r\n        this.id = expression.id;\r\n        this.latex = expression.latex;\r\n        this.type = expression.type;\r\n        this.graphId = parseInt(this.id.split('_')[0], 10);\r\n        if (graphType) {\r\n            this.graphType = graphType;\r\n        }\r\n        else {\r\n            this.graphType = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getGraphType)(expression);\r\n        }\r\n    }\r\n    // return `${A}x^{2}+${C}y^{2}+${D}x+${E}y+${F}=0`;\r\n    toExpression() {\r\n        return {\r\n            id: this.id,\r\n            latex: this.latex,\r\n            type: this.type,\r\n            color: this.color,\r\n            hidden: this.hidden,\r\n        };\r\n    }\r\n    evaluateBounds(variables, bounds) {\r\n        const ya = this.evaluator('y', variables, { x: bounds.xMin });\r\n        const yb = this.evaluator('y', variables, { x: bounds.xMax });\r\n        const xa = this.evaluator('x', variables, { y: bounds.yMin });\r\n        const xb = this.evaluator('x', variables, { y: bounds.yMax });\r\n        return { xa, xb, ya, yb };\r\n    }\r\n    getBoundPoints(domains, evaluations) {\r\n        const xPoints = [\r\n            { x: domains.xMin, y: evaluations.ya.min },\r\n            { x: domains.xMin, y: evaluations.ya.max },\r\n            { x: domains.xMax, y: evaluations.yb.min },\r\n            { x: domains.xMax, y: evaluations.yb.max },\r\n        ].filter((point) => Number.isFinite(point.x.value));\r\n        const yPoints = [\r\n            { x: evaluations.xa.min, y: domains.yMin },\r\n            { x: evaluations.xa.max, y: domains.yMin },\r\n            { x: evaluations.xb.min, y: domains.yMax },\r\n            { x: evaluations.xb.max, y: domains.yMax },\r\n        ].filter((point) => Number.isFinite(point.y.value));\r\n        return [...xPoints, ...yPoints];\r\n    }\r\n    getBounds() {\r\n        const { graphId } = this;\r\n        let { xMin, yMin, xMax, yMax } = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        const { specialPoints, cropPoints } = this.getEndpoints();\r\n        const points = [...specialPoints, ...cropPoints];\r\n        const innerPoints = points.filter((point) => (xMin.value <= point.x.value)\r\n            && (point.x.value <= xMax.value)\r\n            && (yMin.value <= point.y.value)\r\n            && (point.y.value <= yMax.value));\r\n        const x1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const x2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const y1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.y));\r\n        const y2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.y));\r\n        const x1s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(specialPoints.map((point) => point.x));\r\n        const x2s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(specialPoints.map((point) => point.x));\r\n        const y1s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(specialPoints.map((point) => point.y));\r\n        const y2s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(specialPoints.map((point) => point.y));\r\n        xMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([xMin, x1]);\r\n        yMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([yMin, y1]);\r\n        xMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([xMax, x2]);\r\n        yMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([yMax, y2]);\r\n        const cropType = this.getCropType();\r\n        const { xMin: xMinDomain, yMin: yMinDomain, xMax: xMaxDomain, yMax: yMaxDomain, } = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(this.graphId);\r\n        xMin = parseFloat(xMinDomain.value.toFixed(4)) < parseFloat(xMin.value.toFixed(4)) ? xMin : xMinDomain;\r\n        xMax = parseFloat(xMaxDomain.value.toFixed(4)) > parseFloat(xMax.value.toFixed(4)) ? xMax : xMaxDomain;\r\n        yMin = parseFloat(yMinDomain.value.toFixed(4)) < parseFloat(yMin.value.toFixed(4)) ? yMin : yMinDomain;\r\n        yMax = parseFloat(yMaxDomain.value.toFixed(4)) > parseFloat(yMax.value.toFixed(4)) ? yMax : yMaxDomain;\r\n        xMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasXDomain)(cropType) ? xMin : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(-Infinity);\r\n        xMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasXDomain)(cropType) ? xMax : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(Infinity);\r\n        yMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasYDomain)(cropType) ? yMin : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(-Infinity);\r\n        yMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasYDomain)(cropType) ? yMax : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(Infinity);\r\n        return { xMin, yMin, xMax, yMax };\r\n    }\r\n    getCropType() {\r\n        return 3\r\n            - (this.latex.includes('\\\\left\\\\{x') ? 2 : 0)\r\n            - (this.latex.includes('\\\\left\\\\{y') ? 1 : 0);\r\n    }\r\n    convertToYRelevant() {\r\n        const relevantIndices = this.getRelevant('y');\r\n        const converted = this.convertToY();\r\n        return relevantIndices.map((index) => converted[index]);\r\n    }\r\n    convertToXRelevant() {\r\n        const relevantIndices = this.getRelevant('x');\r\n        const converted = this.convertToX();\r\n        return relevantIndices.map((index) => converted[index]);\r\n    }\r\n    evaluator(axis, _variables, input) {\r\n        const variables = {};\r\n        const inputAxis = axis === 'x' ? 'y' : 'x';\r\n        Object.entries(_variables)\r\n            .forEach(([key, value]) => {\r\n            variables[key] = value.value;\r\n        });\r\n        variables[inputAxis] = input[inputAxis].value;\r\n        const values = [];\r\n        const expressions = axis === 'x' ? _constants__WEBPACK_IMPORTED_MODULE_0__.xExpressionsEval[this.graphType] : _constants__WEBPACK_IMPORTED_MODULE_0__.yExpressionsEval[this.graphType];\r\n        for (let i = 0; i < expressions.length; i++) {\r\n            let expression = expressions[i].replaceAll('_{1}', '');\r\n            expression = expression.replaceAll('}\\\\sqrt{', '}\\\\cdot\\\\sqrt{');\r\n            const value = evaluatex(expression, variables)();\r\n            if (value) {\r\n                values.push(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`f_{${this.graphId}${axis}${String.fromCharCode(97 + i)}}(${input[inputAxis].reference})`, value));\r\n            }\r\n        }\r\n        return { min: (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(values), max: (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(values) };\r\n    }\r\n    getRealBounds() {\r\n        const { graphId } = this;\r\n        let { xMin, yMin, xMax, yMax } = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let [newXMin, newXMax, newYMin, newYMax] = [\r\n            _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, -Infinity), _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity), _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, -Infinity), _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity),\r\n        ];\r\n        const { specialPoints, cropPoints } = this.getEndpoints();\r\n        const points = [...specialPoints, ...cropPoints];\r\n        const innerPoints = points.filter((point) => (xMin.value <= point.x.value)\r\n            && (point.x.value <= xMax.value)\r\n            && (yMin.value <= point.y.value)\r\n            && (point.y.value <= yMax.value));\r\n        const x1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const x2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const y1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.y));\r\n        const y2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.y));\r\n        if (y1 !== undefined && y2 !== undefined) {\r\n            newYMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([y1, newYMin]);\r\n            newYMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([y2, newYMax]);\r\n        }\r\n        if (x1 !== undefined && x2 !== undefined) {\r\n            newXMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([x1, newXMin]);\r\n            newXMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([x2, newXMax]);\r\n        }\r\n        xMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([xMin, newXMin]);\r\n        yMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([yMin, newYMin]);\r\n        xMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([xMax, newXMax]);\r\n        yMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([yMax, newYMax]);\r\n        return { xMin, yMin, xMax, yMax };\r\n    }\r\n    convertToY() {\r\n        const { graphType } = this;\r\n        const latexList = _constants__WEBPACK_IMPORTED_MODULE_0__.yExpressions[graphType];\r\n        const newLatexList = [];\r\n        for (let i = 0; i < latexList.length; i++) {\r\n            const latex = latexList[i].replaceAll('_{1', `_{${this.graphId}`);\r\n            newLatexList.push(latex);\r\n        }\r\n        return newLatexList;\r\n    }\r\n    convertToX() {\r\n        const { graphType } = this;\r\n        const latexList = _constants__WEBPACK_IMPORTED_MODULE_0__.xExpressions[graphType];\r\n        const newLatexList = [];\r\n        for (let i = 0; i < latexList.length; i++) {\r\n            const latex = latexList[i].replaceAll('_{1', `_{${this.graphId}`);\r\n            newLatexList.push(latex);\r\n        }\r\n        return newLatexList;\r\n    }\r\n    getClosestEndpoint(point) {\r\n        const endpoints = this.getEndpoints().cropPoints;\r\n        const currEndPoint = {\r\n            endpoint: null,\r\n            currMinSqrMagnitude: Infinity,\r\n        };\r\n        endpoints.forEach((endpoint) => {\r\n            const sqrMagnitude = (endpoint.x.value - point.x) ** 2 + (endpoint.y.value - point.y) ** 2;\r\n            if (sqrMagnitude < currEndPoint.currMinSqrMagnitude) {\r\n                currEndPoint.endpoint = endpoint;\r\n                currEndPoint.currMinSqrMagnitude = sqrMagnitude;\r\n            }\r\n        });\r\n        if (currEndPoint.endpoint) {\r\n            return currEndPoint.endpoint;\r\n        }\r\n        throw Error('No endpoint found');\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/Graph.ts?");

/***/ }),

/***/ "./src/MyCalc.ts":
/*!***********************!*\
  !*** ./src/MyCalc.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MyCalcClass\": () => (/* binding */ MyCalcClass)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/lib.ts\");\n\r\nclass MyCalcClass {\r\n    constructor(_Calc) {\r\n        this.Calc = _Calc;\r\n        this.Controller = _Calc.controller;\r\n        this.logicalExpressions = {};\r\n        this.usedId = [];\r\n        this.globalVariablesObject = {};\r\n        this.globalFunctionsObject = {};\r\n        this.linkedVariables = {};\r\n        this.update();\r\n        this.init();\r\n    }\r\n    init() {\r\n        this.getExpressions().forEach((expression) => {\r\n            if (expression.id.includes('_')) {\r\n                const split = expression.id.split('_');\r\n                if (split[0] === 'final') {\r\n                    this.usedId.push(parseInt(split[1]));\r\n                }\r\n                else if (/\\d+/.test(split[0])) {\r\n                    const matches = [...expression.latex.matchAll(_lib__WEBPACK_IMPORTED_MODULE_0__.functionRegex)];\r\n                    if (matches.length > 0) { // Is a function\r\n                        this.globalFunctionsObject[matches[0][1]] = {\r\n                            id: expression.id,\r\n                            args: matches[0][2].split(','),\r\n                            definition: expression.latex.split('=')[1],\r\n                        };\r\n                    }\r\n                    if (expression.id.endsWith('_0')) {\r\n                        this.usedId.push(parseInt(split[0]));\r\n                    }\r\n                }\r\n            }\r\n        });\r\n    }\r\n    update() {\r\n        const expressions = this.getExpressions();\r\n        const expressionsToSet = [];\r\n        const maxNumber = {};\r\n        expressions.forEach((_expression) => {\r\n            const expression = _expression;\r\n            if (expression.latex) {\r\n                if (expression.latex.includes('e_{')) {\r\n                    expression.latex = expression.latex.replace('e_{', 'q_{');\r\n                    expressionsToSet.push(expression);\r\n                }\r\n                if (expression.id.includes('_')) {\r\n                    const split = expression.id.split('_');\r\n                    if (!['final', 'shade'].includes(split[0])) {\r\n                        const id = parseInt(split[0]);\r\n                        const num = parseInt(split[1]);\r\n                        if (id in maxNumber) {\r\n                            if (num > maxNumber[id]) {\r\n                                maxNumber[id] = num;\r\n                            }\r\n                        }\r\n                        else {\r\n                            maxNumber[id] = num;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        this.updateExpressions(expressionsToSet);\r\n    }\r\n    getSelected() {\r\n        if (this.selectedExpressionId) {\r\n            return this.getExpression(this.selectedExpressionId);\r\n        }\r\n        return undefined;\r\n    }\r\n    getExpression(_id) {\r\n        if (Object.keys(this.logicalExpressions).includes(_id)) {\r\n            return this.logicalExpressions[_id];\r\n        }\r\n        else {\r\n            const expression = this.Controller.getItemModel(_id);\r\n            if (expression) {\r\n                return expression;\r\n            }\r\n            return undefined;\r\n        }\r\n    }\r\n    getExpressions() {\r\n        return this.Calc.getExpressions();\r\n    }\r\n    setLogicalExpression(expression) {\r\n        if (!Object.keys(this.logicalExpressions).includes(expression.id)) {\r\n            this.logicalExpressions[expression.id] = expression;\r\n        }\r\n    }\r\n    get expressionAnalysis() {\r\n        return this.Calc.expressionAnalysis;\r\n    }\r\n    get selectedExpressionId() {\r\n        return this.Calc.selectedExpressionId;\r\n    }\r\n    set selectedExpressionId(id) {\r\n        this.Controller.dispatch({ type: \"set-selected-id\", id: id });\r\n    }\r\n    removeExpressions(expressions) {\r\n        expressions.forEach((expression) => {\r\n            const split = expression.id.split('_');\r\n            if (['final', 'shade'].includes(split[0])) {\r\n                const id = parseInt(split[1]);\r\n                if (this.usedId.includes(id)) {\r\n                    this.usedId = this.usedId.filter(_id => _id !== id);\r\n                }\r\n            }\r\n            else {\r\n                const id = parseInt(split[0]);\r\n                if (this.usedId.includes(id)) {\r\n                    this.usedId = this.usedId.filter(_id => _id !== id);\r\n                }\r\n            }\r\n        });\r\n        this.Calc.removeExpressions(expressions);\r\n    }\r\n    removeExpression(expression) {\r\n        if (this.isLogical(expression.id)) {\r\n            delete this.logicalExpressions[expression.id];\r\n        }\r\n        else {\r\n            this.Calc.removeExpression(expression);\r\n            const split = expression.id.split('_');\r\n            if (['final', 'shade'].includes(split[0])) {\r\n                const id = parseInt(split[1]);\r\n                this.usedId = this.usedId.filter(_id => _id !== id);\r\n            }\r\n            else {\r\n                const id = parseInt(split[0]);\r\n                this.usedId = this.usedId.filter(_id => _id !== id);\r\n            }\r\n        }\r\n    }\r\n    removeExpressionById(expressionId) {\r\n        if (this.isLogical(expressionId)) {\r\n            delete this.logicalExpressions[expressionId];\r\n        }\r\n        else {\r\n            const expression = this.getExpression(expressionId);\r\n            if (expression) {\r\n                this.removeExpression(expression);\r\n            }\r\n        }\r\n    }\r\n    newGraph(id, expressions) {\r\n        if (this.usedId.includes(id)) {\r\n            throw Error('id already in expressions list');\r\n        }\r\n        else {\r\n            this.usedId.push(id);\r\n            this.setExpressions(expressions);\r\n        }\r\n    }\r\n    setExpressions(expressions) {\r\n        const expressionsToBeCreated = [];\r\n        expressions.forEach((expression) => {\r\n            if (this.getExpression(expression.id)) {\r\n                throw Error(\"Tried to update create existent expression\");\r\n            }\r\n            else {\r\n                expressionsToBeCreated.push(expression);\r\n            }\r\n        });\r\n        this.Calc.setExpressions(expressionsToBeCreated);\r\n    }\r\n    updateExpressions(expressions) {\r\n        const expressionsToBeUpdated = [];\r\n        expressions.forEach((expression) => {\r\n            if (this.getExpression(expression.id)) {\r\n                expressionsToBeUpdated.push(expression);\r\n            }\r\n            else {\r\n                throw Error(\"Tried to update non-existent expression\");\r\n            }\r\n        });\r\n        this.Calc.setExpressions(expressionsToBeUpdated);\r\n    }\r\n    updateExpression(expression, _logical) {\r\n        const logical = !!_logical;\r\n        if (logical) {\r\n            this.setLogicalExpression(expression);\r\n        }\r\n        else {\r\n            this.Calc.setExpression(expression);\r\n        }\r\n    }\r\n    setExpression(expression, _logical) {\r\n        const logical = !!_logical;\r\n        if (logical) {\r\n            this.setLogicalExpression(expression);\r\n        }\r\n        else {\r\n            this.Calc.setExpression(expression);\r\n        }\r\n    }\r\n    getOffset() {\r\n        const graphContainer = document.querySelector('#graph-container');\r\n        const graphContainerRect = graphContainer.getBoundingClientRect();\r\n        return { x: graphContainerRect.left, y: graphContainerRect.top };\r\n    }\r\n    pixelsToMath(point) {\r\n        const { x: xOffset, y: yOffset } = this.getOffset();\r\n        return this.Calc.pixelsToMath({\r\n            x: point.x - xOffset,\r\n            y: point.y - yOffset,\r\n        });\r\n    }\r\n    get graphpaperBounds() {\r\n        return this.Calc.graphpaperBounds;\r\n    }\r\n    getState() {\r\n        return this.Calc.getState();\r\n    }\r\n    setState(state) {\r\n        return this.Calc.setState(state);\r\n    }\r\n    getItemCount() {\r\n        return this.Controller.getItemCount();\r\n    }\r\n    isLogical(id) {\r\n        return Object.keys(this.logicalExpressions).includes(id);\r\n    }\r\n    dependsOn(graphId) {\r\n        const expressionList = [];\r\n        const allExpressions = this.getExpressions();\r\n        for (let i = 0; i < allExpressions.length; i++) {\r\n            const expression = allExpressions[i];\r\n            if (expression.latex) {\r\n                if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.usesVariable)(expression.latex, graphId)) {\r\n                    expressionList.push(expression);\r\n                }\r\n            }\r\n        }\r\n        return expressionList;\r\n    }\r\n    table(points) {\r\n        const table = {\r\n            id: \"reg_table\",\r\n            type: \"table\",\r\n            columns: [\r\n                {\r\n                    latex: \"r_{x}\",\r\n                    color: \"BLACK\",\r\n                    id: \"reg_1\",\r\n                    values: points.map((point) => parseFloat(point.x.toFixed(4)))\r\n                },\r\n                {\r\n                    latex: \"r_{y}\",\r\n                    color: \"BLACK\",\r\n                    id: \"reg_2\",\r\n                    values: points.map((point) => parseFloat(point.y.toFixed(4)))\r\n                }\r\n            ]\r\n        };\r\n        return table;\r\n    }\r\n    regression(points) {\r\n        const newExp = {\r\n            reg: \"r_{A}r_{x}^{2}+r_{C}r_{x}^{2}+r_{D}r_{x}+r_{E}r_{y}+r_{F}\\\\sim0\\\\left\\{\\\\frac{r_{F}^{2}}{r_{A}r_{C}}>1\\\\right\\\\}\",\r\n            reg_exp: \"r_{A}r_{x}^{2}+r_{C}r_{x}^{2}+r_{D}r_{x}+r_{E}r_{y}+r_{F}\\\\sim0\\\\left\\\\{\\\\frac{r_{F}^{2}}{r_{A}r_{C}}>1\\\\right\\\\}\"\r\n        };\r\n        this.setExpression(this.table(points));\r\n    }\r\n    linkedVariable(reference, _value) {\r\n        if (typeof reference === 'number') {\r\n            return new _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable(reference, _value);\r\n        }\r\n        else {\r\n            if (reference) {\r\n                if (reference in this.linkedVariables) {\r\n                    if (_value) {\r\n                        this.linkedVariables[reference].value = _value;\r\n                    }\r\n                    return this.linkedVariables[reference];\r\n                }\r\n                else {\r\n                    return new _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable(reference, _value);\r\n                }\r\n            }\r\n            else {\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable(reference, _value);\r\n            }\r\n        }\r\n    }\r\n    addLinkedVariable(linkedVariable) {\r\n        if (linkedVariable.reference) {\r\n            if (linkedVariable.reference in this.linkedVariables) {\r\n                this.linkedVariables[linkedVariable.reference] = linkedVariable;\r\n            }\r\n            else {\r\n                this.linkedVariables[linkedVariable.reference] = linkedVariable;\r\n            }\r\n        }\r\n    }\r\n    updateLinkedVariables() {\r\n        Object.values(this.linkedVariables).forEach(linkedVariable => {\r\n            if (linkedVariable.reference && !linkedVariable.alwaysClean) {\r\n                this.linkedVariables[linkedVariable.reference].clean = false;\r\n            }\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/MyCalc.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultExpressionFormat\": () => (/* binding */ defaultExpressionFormat),\n/* harmony export */   \"yExpressions\": () => (/* binding */ yExpressions),\n/* harmony export */   \"xExpressions\": () => (/* binding */ xExpressions),\n/* harmony export */   \"yExpressionsEval\": () => (/* binding */ yExpressionsEval),\n/* harmony export */   \"xExpressionsEval\": () => (/* binding */ xExpressionsEval),\n/* harmony export */   \"expressionFormat\": () => (/* binding */ expressionFormat),\n/* harmony export */   \"expressionNames\": () => (/* binding */ expressionNames),\n/* harmony export */   \"baseExpressionFormat\": () => (/* binding */ baseExpressionFormat)\n/* harmony export */ });\nconst defaultExpressionFormat = [\r\n    { latex: '\\\\left(x_{1cb},y_{1ca}+\\\\left(y_{1cb}-y_{1ca}\\\\right)t\\\\right)', types: ['segment', 'delete', 'hide', 'y'] },\r\n    { latex: '\\\\left(x_{1ca},y_{1ca}+\\\\left(y_{1cb}-y_{1ca}\\\\right)t\\\\right)', types: ['segment', 'delete', 'hide', 'y'] },\r\n    { latex: '\\\\left(x_{1ca}+\\\\left(x_{1cb}-x_{1ca}\\\\right)t,y_{1ca}\\\\right)', types: ['segment', 'delete', 'hide', 'x'] },\r\n    { latex: '\\\\left(x_{1ca}+\\\\left(x_{1cb}-x_{1ca}\\\\right)t,y_{1cb}\\\\right)', types: ['segment', 'delete', 'hide', 'x'] },\r\n    { latex: '\\\\left(x_{1cam}+\\\\operatorname{sgn}(h_{1})\\\\operatorname{abs}(h_{1}),y_{1cam}+\\\\operatorname{sgn}(k_{1})\\\\operatorname{abs}(k_{1})\\\\right)', types: ['point', 'delete', 'hide', 'xy'] },\r\n    { latex: '\\\\left(x_{1cbm}+\\\\operatorname{sgn}(h_{1})\\\\operatorname{abs}(h_{1}),y_{1cbm}+\\\\operatorname{sgn}(k_{1})\\\\operatorname{abs}(k_{1})\\\\right)', types: ['point', 'delete', 'hide', 'xy'] },\r\n    { latex: 'x_{1ca}=x_{1cam}+h_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'y_{1ca}=y_{1cam}+k_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'x_{1cb}=x_{1cbm}+h_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'y_{1cb}=y_{1cbm}+k_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'x_{1cam}=0', types: ['var', 'delete'] },\r\n    { latex: 'y_{1cam}=0', types: ['var', 'delete'] },\r\n    { latex: 'x_{1cbm}=0', types: ['var', 'delete'] },\r\n    { latex: 'y_{1cbm}=0', types: ['var', 'delete'] },\r\n];\r\nconst yExpressions = [\r\n    ['k_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}', 'k_{1}+\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}'],\r\n    ['k_{1}+\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['k_{1}-\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['m_{1}x+b_{1}'],\r\n];\r\nconst xExpressions = [\r\n    ['h_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}+\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['h_{1}-\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}', 'h_{1}+\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}', 'h_{1}+\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['\\\\frac{\\\\left(y-b_{1}\\\\right)}{m_{1}}'],\r\n];\r\nconst yExpressionsEval = [\r\n    ['k_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}', 'k_{1}+\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}'],\r\n    ['k_{1}+\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['k_{1}-\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['m_{1}\\\\cdot x+b_{1}'],\r\n];\r\nconst xExpressionsEval = [\r\n    ['h_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}+\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['h_{1}-\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}', 'h_{1}+\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}', 'h_{1}+\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['\\\\frac{\\\\left(y-b_{1}\\\\right)}{m_{1}}'],\r\n];\r\nconst expressionFormat = [\r\n    [\r\n        { latex: '\\\\left(x-h_{1}\\\\right)^{2}+\\\\left(y-k_{1}\\\\right)^{2}=r_{1}^{2}', types: ['graph'], name: 'graph' },\r\n        { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1}+a_{1},k_{1}+b_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: 'r_{1}=\\\\sqrt{a_{1}^{2}+b_{1}^{2}}', types: ['helper_var'], name: 'r' },\r\n        { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n        { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n        { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n        { latex: 'b_{1}=0', types: ['var'], name: 'b' },\r\n        ...defaultExpressionFormat,\r\n        ...yExpressions[0].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n        ...xExpressions[0].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n    ],\r\n    [\r\n        { latex: '\\\\left(y-k_{1}\\\\right)^{2}=4c_{1}\\\\left(x-h_{1}\\\\right)', types: ['graph'] },\r\n        { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1}+d_{1},k_{1}+q_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n        { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n        { latex: 'q_{1}=1', types: ['var'], name: 'e' },\r\n        { latex: 'd_{1}=1', types: ['var'], name: 'd' },\r\n        { latex: 'c_{1}=\\\\frac{q_{1}^{2}}{4d_{1}}', types: ['helper_var'], name: 'c' },\r\n        ...defaultExpressionFormat,\r\n        ...yExpressions[1].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n        ...xExpressions[1].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n    ],\r\n    [\r\n        { latex: '\\\\left(x-h_{1}\\\\right)^{2}=4c_{1}\\\\left(y-k_{1}\\\\right)', types: ['graph'] },\r\n        { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1}+q_{1},k_{1}+d_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n        { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n        { latex: 'q_{1}=1', types: ['var'], name: 'e' },\r\n        { latex: 'd_{1}=1', types: ['var'], name: 'd' },\r\n        { latex: 'c_{1}=\\\\frac{q_{1}^{2}}{4d_{1}}', types: ['helper_var'], name: 'c' },\r\n        ...defaultExpressionFormat,\r\n        ...yExpressions[2].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n        ...xExpressions[2].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n    ],\r\n    [\r\n        { latex: '\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{a_{1}^{2}}+\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{b_{1}^{2}}=1', types: ['graph'] },\r\n        { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1}+a_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1},k_{1}+b_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: 'k_{1}=0', types: ['var'], name: 'h' },\r\n        { latex: 'h_{1}=0', types: ['var'], name: 'k' },\r\n        { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n        { latex: 'b_{1}=1', types: ['var'], name: 'b' },\r\n        ...defaultExpressionFormat,\r\n        ...yExpressions[3].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n        ...xExpressions[3].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n    ],\r\n    [\r\n        { latex: '\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{a_{1}^{2}}-\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{b_{1}^{2}}=1', types: ['graph'] },\r\n        { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1}+a_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1}+\\\\sqrt{2}a_{1},k_{1}+b_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n        { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n        { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n        { latex: 'b_{1}=1', types: ['var'], name: 'b' },\r\n        ...defaultExpressionFormat,\r\n        ...yExpressions[4].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n        ...xExpressions[4].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n    ],\r\n    [\r\n        { latex: '\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{a_{1}^{2}}-\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{b_{1}^{2}}=1', types: ['graph'] },\r\n        { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1},k_{1}+a_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(h_{1}+b_{1},k_{1}+\\\\sqrt{2}a_{1}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n        { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n        { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n        { latex: 'b_{1}=1', types: ['var'], name: 'b' },\r\n        ...defaultExpressionFormat,\r\n        ...yExpressions[5].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n        ...xExpressions[5].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n    ],\r\n    [\r\n        { latex: 'y=m_{1}x+b_{1}\\\\left\\\\{x_{1ca}<x<x_{1cb}\\\\right\\\\}', types: ['graph'] },\r\n        { latex: '\\\\left(x_{1a},y_{1a}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: '\\\\left(x_{1b},y_{1b}\\\\right)', types: ['point', 'hide'] },\r\n        { latex: 'x_{1ca}=\\\\min\\\\left(x_{1a},x_{1b}\\\\right)', types: ['helper_var'] },\r\n        { latex: 'x_{1cb}=\\\\max\\\\left(x_{1a},x_{1b}\\\\right)', types: ['helper_var'] },\r\n        { latex: 'm_{1}=\\\\frac{\\\\left(y_{1b}-y_{1a}\\\\right)}{\\\\left(x_{1b}-x_{1a}\\\\right)}', types: ['helper_var'] },\r\n        { latex: 'b_{1}=y_{1a}-\\\\frac{\\\\left(y_{1b}-y_{1a}\\\\right)x_{1a}}{\\\\left(x_{1b}-x_{1a}\\\\right)}', types: ['helper_var'] },\r\n        { latex: 'y_{1a}=0', types: ['var'], name: 'ya' },\r\n        { latex: 'y_{1b}=1', types: ['var'], name: 'yb' },\r\n        { latex: 'x_{1a}=0', types: ['var'], name: 'xa' },\r\n        { latex: 'x_{1b}=1', types: ['var'], name: 'xb' },\r\n        ...yExpressions[6].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n        ...xExpressions[6].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n        { latex: 'y_{1ca}=m_{1}x_{1ca}+b_{1}', types: ['helper_var'] },\r\n        { latex: 'y_{1cb}=m_{1}x_{1cb}+b_{1}', types: ['helper_var'] },\r\n    ],\r\n];\r\nconst expressionNames = expressionFormat.map((expressionList) => {\r\n    const x = {};\r\n    expressionList.forEach((latexExpression, expressionId) => {\r\n        if (latexExpression.name) {\r\n            x[latexExpression.name] = expressionId;\r\n        }\r\n    });\r\n    return x;\r\n});\r\nconst baseExpressionFormat = [];\r\nfor (let i = 0; i < expressionFormat.length; i++) {\r\n    const expression = expressionFormat[i];\r\n    baseExpressionFormat.push(expression[0].latex);\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/constants.ts?");

/***/ }),

/***/ "./src/graphs/Circle.ts":
/*!******************************!*\
  !*** ./src/graphs/Circle.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* binding */ Circle)\n/* harmony export */ });\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass Circle extends _Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 0);\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${this.graphId}}`);\r\n        const r = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`r_{${this.graphId}}`);\r\n        const A = 1;\r\n        const C = 1;\r\n        const D = -2 * h;\r\n        const E = -2 * k;\r\n        const F = k ** 2 + h ** 2 - r ** 2;\r\n        return { A, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const r = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`r_{${graphId}}`);\r\n        return { h, k, r };\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        const r2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`r_{${currId}}`) ** 2;\r\n        latex = latex.replace(`r_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_2__.simplify)(r2, 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_2__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, r } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${h.reference}-${r.reference}`), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${k.reference}-${r.reference}`) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${h.reference}+${r.reference}`), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${k.reference}+${r.reference}`) },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (h < xMax.value)\r\n                relevantIndices.push(1);\r\n            if (xMin.value < h)\r\n                relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            if (k < yMax.value)\r\n                relevantIndices.push(1);\r\n            if (yMin.value < k)\r\n                relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, k, r] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        r = Math.sqrt(Math.abs(r));\r\n        return { h, k, r };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, r } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${graphId}}`, r);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${graphId}}`, '0');\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`r_{${graphId}}`, r);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${id}}`, 0);\r\n    }\r\n}\r\nCircle.hasCenter = true;\r\nCircle.hasCrop = true;\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/Circle.ts?");

/***/ }),

/***/ "./src/graphs/Ellipse.ts":
/*!*******************************!*\
  !*** ./src/graphs/Ellipse.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ellipse\": () => (/* binding */ Ellipse)\n/* harmony export */ });\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass Ellipse extends _Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 3);\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${this.graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = b ** 2;\r\n        const C = a ** 2;\r\n        const D = -2 * h * b ** 2;\r\n        const E = -2 * k * a ** 2;\r\n        const F = b ** 2 * h ** 2 + a ** 2 * k ** 2 - a ** 2 * b ** 2;\r\n        return { A, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const a = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`a_{${graphId}}`);\r\n        const b = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`b_{${graphId}}`);\r\n        return { h, k, a, b };\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${currId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`b_{${currId}}`);\r\n        const a2 = a ** 2;\r\n        const b2 = b ** 2;\r\n        latex = latex.replace(`a_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_2__.simplify)(a2, 4));\r\n        latex = latex.replace(`b_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_2__.simplify)(b2, 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_2__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, a, b } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${h.reference}-${a.reference}`), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${k.reference}-${b.reference}`) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${h.reference}+${a.reference}`), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${k.reference}+${b.reference}`) },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (h < xMax.value)\r\n                relevantIndices.push(1);\r\n            if (xMin.value < h)\r\n                relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            if (k < yMax.value)\r\n                relevantIndices.push(1);\r\n            if (yMin.value < k)\r\n                relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, a, k, b] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        a = Math.sqrt(Math.abs(a));\r\n        b = Math.sqrt(Math.abs(b));\r\n        return { h, a, k, b };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, a, b } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${graphId}}`, a);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${graphId}}`, b);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${id}}`, size * 0.2);\r\n    }\r\n}\r\nEllipse.hasCenter = true;\r\nEllipse.hasCrop = true;\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/Ellipse.ts?");

/***/ }),

/***/ "./src/graphs/HorizontalHyperbola.ts":
/*!*******************************************!*\
  !*** ./src/graphs/HorizontalHyperbola.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HorizontalHyperbola\": () => (/* binding */ HorizontalHyperbola)\n/* harmony export */ });\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass HorizontalHyperbola extends _Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 4);\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${this.graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = b ** 2;\r\n        const C = -(a ** 2);\r\n        const D = -2 * h * b ** 2;\r\n        const E = 2 * k * a ** 2;\r\n        const F = b ** 2 * h ** 2 - a ** 2 * k ** 2 - a ** 2 * b ** 2;\r\n        return { A, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const a = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`a_{${graphId}}`);\r\n        const b = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`b_{${graphId}}`);\r\n        return { h, k, a, b };\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${currId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`b_{${currId}}`);\r\n        const a2 = a ** 2;\r\n        const b2 = b ** 2;\r\n        latex = latex.replace(`a_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_2__.simplify)(a2, 4));\r\n        latex = latex.replace(`b_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_2__.simplify)(b2, 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.substitute)(latex);\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, a, b } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${h.reference}-${a.reference}`), y: k },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${h.reference}+${a.reference}`), y: k },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${graphId}}`);\r\n        // const b = getVariable(`b_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (xMax.value < h + a)\r\n                relevantIndices.push(0);\r\n            if (xMin.value > h - a)\r\n                relevantIndices.push(1);\r\n        }\r\n        if (axis === 'y') {\r\n            if (yMax.value < k)\r\n                relevantIndices.push(0);\r\n            if (yMin.value > k)\r\n                relevantIndices.push(1);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, a, k, b] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        a = Math.sqrt(Math.abs(a));\r\n        b = Math.sqrt(Math.abs(b));\r\n        return { h, k, a, b };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, a, b } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${graphId}}`, a);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${graphId}}`, b);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${id}}`, size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${id}}`, size * 0.2);\r\n    }\r\n}\r\nHorizontalHyperbola.hasCenter = true;\r\nHorizontalHyperbola.hasCrop = true;\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/HorizontalHyperbola.ts?");

/***/ }),

/***/ "./src/graphs/HorizontalParabola.ts":
/*!******************************************!*\
  !*** ./src/graphs/HorizontalParabola.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HorizontalParabola\": () => (/* binding */ HorizontalParabola)\n/* harmony export */ });\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass HorizontalParabola extends _Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 1);\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${this.graphId}}`);\r\n        const c = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`c_{${this.graphId}}`);\r\n        const A = 0;\r\n        const C = 1;\r\n        const D = -4 * c;\r\n        const E = -2 * k;\r\n        const F = 4 * c * h + k ** 2;\r\n        return { A, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const c = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`c_{${graphId}}`);\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        return { h, k, c };\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        latex = latex.replace(`4c_{${currId}}`, (0,_lib__WEBPACK_IMPORTED_MODULE_2__.simplify)(4 * (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`c_{${currId}}`), 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_2__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, c } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, -Infinity) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity) },\r\n            { x: h, y: k },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            if (k < yMax.value)\r\n                relevantIndices.push(1);\r\n            if (yMin.value < k)\r\n                relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [k, c, h] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        c /= 4;\r\n        return { h, k, c };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { k, c, h } = variables;\r\n        const d = Math.sign(c) / 4;\r\n        const e = Math.sqrt(Math.abs(c));\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`d_{${graphId}}`, d);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`q_{${graphId}}`, e);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`c_{${graphId}}`, c);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`q_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`d_{${id}}`, size * 0.3);\r\n    }\r\n}\r\nHorizontalParabola.hasCenter = true;\r\nHorizontalParabola.hasCrop = true;\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/HorizontalParabola.ts?");

/***/ }),

/***/ "./src/graphs/LineSegment.ts":
/*!***********************************!*\
  !*** ./src/graphs/LineSegment.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineSegment\": () => (/* binding */ LineSegment)\n/* harmony export */ });\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass LineSegment extends _Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 6);\r\n    }\r\n    getGeneralForm() {\r\n        const m = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`m_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = 0;\r\n        const C = 0;\r\n        const D = m;\r\n        const E = 0;\r\n        const F = b;\r\n        return { A, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const x1 = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`x_{${graphId}ca}`);\r\n        const x2 = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`x_{${graphId}cb}`);\r\n        const y1 = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`y_{${graphId}ca}`);\r\n        const y2 = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`y_{${graphId}cb}`);\r\n        return { x1, x2, y1, y2 };\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.substitute)(latex);\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        const points = [];\r\n        const variables = this.getConicVariables();\r\n        const { x1, x2, y1, y2 } = variables;\r\n        const xa = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minMax)([x1, x2]);\r\n        const xb = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minMax)([x1, x2]);\r\n        const ya = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minMax)([y1, y2]);\r\n        const yb = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minMax)([y1, y2]);\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, { xa, xb, ya, yb }),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        relevantIndices.push(0);\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        const [m, b, x1, x2] = variables;\r\n        return { m, b, x1, x2 };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { m, b, x1, x2 } = variables;\r\n        const y1 = m * x1 + b;\r\n        const y2 = m * x2 + b;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`x_{${graphId}a}`, x1.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`y_{${graphId}a}`, y1.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`x_{${graphId}b}`, x2.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`y_{${graphId}b}`, y2.toString());\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`x_{${id}a}`, expressionPos.x - size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`y_{${id}a}`, expressionPos.y - size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`x_{${id}b}`, expressionPos.x + size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`y_{${id}b}`, expressionPos.y + size * 0.2);\r\n    }\r\n}\r\nLineSegment.hasCenter = false;\r\nLineSegment.hasCrop = false;\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/LineSegment.ts?");

/***/ }),

/***/ "./src/graphs/VerticalHyperbola.ts":
/*!*****************************************!*\
  !*** ./src/graphs/VerticalHyperbola.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VerticalHyperbola\": () => (/* binding */ VerticalHyperbola)\n/* harmony export */ });\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass VerticalHyperbola extends _Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 5);\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${this.graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = -(b ** 2);\r\n        const C = a ** 2;\r\n        const D = 2 * h * b ** 2;\r\n        const E = -2 * k * a ** 2;\r\n        const F = a ** 2 * k ** 2 - b ** 2 * h ** 2 - a ** 2 * b ** 2;\r\n        return { A, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const a = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`a_{${graphId}}`);\r\n        const b = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`b_{${graphId}}`);\r\n        return { h, k, a, b };\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${currId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`b_{${currId}}`);\r\n        const a2 = a ** 2;\r\n        const b2 = b ** 2;\r\n        latex = latex.replace(`a_{${currId}}^{2}`, a2.toFixed(4));\r\n        latex = latex.replace(`b_{${currId}}^{2}`, b2.toFixed(4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.substitute)(latex);\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, a, b } = variables;\r\n        points = [\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${k.reference}-${b.reference}`) },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`${k.reference}+${b.reference}`) },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`a_{${graphId}}`);\r\n        // const b = getVariable(`b_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (yMax.value < h)\r\n                relevantIndices.push(0);\r\n            if (yMin.value > h)\r\n                relevantIndices.push(1);\r\n        }\r\n        if (axis === 'y') {\r\n            if (yMax.value < k + a)\r\n                relevantIndices.push(0);\r\n            if (yMin.value > k - a)\r\n                relevantIndices.push(1);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [k, a, h, b] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        a = Math.sqrt(Math.abs(a));\r\n        b = Math.sqrt(Math.abs(b));\r\n        return { h, k, a, b };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, a, b } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${graphId}}`, a);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${graphId}}`, b);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`a_{${id}}`, size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`b_{${id}}`, size * 0.2);\r\n    }\r\n}\r\nVerticalHyperbola.hasCenter = true;\r\nVerticalHyperbola.hasCrop = true;\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/VerticalHyperbola.ts?");

/***/ }),

/***/ "./src/graphs/VerticalParabola.ts":
/*!****************************************!*\
  !*** ./src/graphs/VerticalParabola.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VerticalParabola\": () => (/* binding */ VerticalParabola)\n/* harmony export */ });\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass VerticalParabola extends _Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 2);\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`k_{${this.graphId}}`);\r\n        const c = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`c_{${this.graphId}}`);\r\n        const A = 1;\r\n        const C = 0;\r\n        const D = -2 * h;\r\n        const E = -4 * c;\r\n        const F = 4 * c * k + h ** 2;\r\n        return { A, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const c = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`c_{${graphId}}`);\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        return { h, k, c };\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        latex = latex.replace(`4c_{${currId}}`, (4 * (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`c_{${currId}}`)).toFixed(4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_2__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, c } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, -Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity) },\r\n            { x: h, y: k },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (h < xMax.value)\r\n                relevantIndices.push(1);\r\n            if (xMin.value < h)\r\n                relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, c, k] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        c /= 4;\r\n        return { h, k, c };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, c, k } = variables;\r\n        const d = Math.sign(c) / 4;\r\n        const e = Math.sqrt(Math.abs(c));\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`d_{${graphId}}`, d);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`q_{${graphId}}`, e);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`c_{${graphId}}`, c);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`q_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`d_{${id}}`, size * 0.3);\r\n    }\r\n}\r\nVerticalParabola.hasCenter = true;\r\nVerticalParabola.hasCrop = true;\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/VerticalParabola.ts?");

/***/ }),

/***/ "./src/index.user.ts":
/*!***************************!*\
  !*** ./src/index.user.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MyCalc\": () => (/* binding */ MyCalc)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/lib.ts\");\n/* harmony import */ var _Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Graph */ \"./src/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _graphs_Circle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./graphs/Circle */ \"./src/graphs/Circle.ts\");\n/* harmony import */ var _graphs_Ellipse__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graphs/Ellipse */ \"./src/graphs/Ellipse.ts\");\n/* harmony import */ var _graphs_HorizontalHyperbola__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./graphs/HorizontalHyperbola */ \"./src/graphs/HorizontalHyperbola.ts\");\n/* harmony import */ var _graphs_HorizontalParabola__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graphs/HorizontalParabola */ \"./src/graphs/HorizontalParabola.ts\");\n/* harmony import */ var _graphs_LineSegment__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graphs/LineSegment */ \"./src/graphs/LineSegment.ts\");\n/* harmony import */ var _graphs_VerticalHyperbola__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./graphs/VerticalHyperbola */ \"./src/graphs/VerticalHyperbola.ts\");\n/* harmony import */ var _graphs_VerticalParabola__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./graphs/VerticalParabola */ \"./src/graphs/VerticalParabola.ts\");\n/* harmony import */ var _MyCalc__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./MyCalc */ \"./src/MyCalc.ts\");\n// ==UserScript==\r\n// @name         Precal thing\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1.2\r\n// @description  precal thing\r\n// @author       You (not Watanabe)\r\n// @match        https://www.desmos.com/calculator*\r\n// @icon         https://www.google.com/s2/favicons?domain=desmos.com\r\n// @grant        unsafeWindow\r\n// @updateURL    https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js\r\n// @downloadURL  https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js\r\n// @require      https://code.jquery.com/jquery-3.5.1.slim.min.js\r\n// @require      https://cdn.jsdelivr.net/npm/evaluatex@2.2.0/dist/evaluatex.min.js\r\n// ==/UserScript==\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst GraphTypes = [\r\n    _graphs_Circle__WEBPACK_IMPORTED_MODULE_3__.Circle,\r\n    _graphs_HorizontalParabola__WEBPACK_IMPORTED_MODULE_6__.HorizontalParabola,\r\n    _graphs_VerticalParabola__WEBPACK_IMPORTED_MODULE_9__.VerticalParabola,\r\n    _graphs_Ellipse__WEBPACK_IMPORTED_MODULE_4__.Ellipse,\r\n    _graphs_HorizontalHyperbola__WEBPACK_IMPORTED_MODULE_5__.HorizontalHyperbola,\r\n    _graphs_VerticalHyperbola__WEBPACK_IMPORTED_MODULE_8__.VerticalHyperbola,\r\n    _graphs_LineSegment__WEBPACK_IMPORTED_MODULE_7__.LineSegment\r\n];\r\nfunction isGraph(expression) {\r\n    return expression.id.endsWith('_0') || expression.id.startsWith('final_');\r\n}\r\nlet MyCalc;\r\nfunction main() {\r\n    MyCalc = new _MyCalc__WEBPACK_IMPORTED_MODULE_10__.MyCalcClass(Calc);\r\n    const selections = [];\r\n    let easySelections = [];\r\n    let lastSelection;\r\n    const graphAbbrev = ['C', 'HP', 'VP', 'E', 'HH', 'VH', 'LS'];\r\n    let easyMode = false;\r\n    let lastSelectedId = '';\r\n    let currentlyPressed = [];\r\n    let idSet = false;\r\n    let shadeIdSet = false;\r\n    let altTime = 0;\r\n    let ctrlTime = 0;\r\n    let expressionPos = { x: 0, y: 0 };\r\n    let globalId = 1;\r\n    let shadeId = 1;\r\n    let currGraphId = 0;\r\n    let centerPoint = {\r\n        x: Infinity,\r\n        y: Infinity,\r\n    };\r\n    let lastCenterPoint = {\r\n        x: Infinity,\r\n        y: Infinity,\r\n    };\r\n    function getShadeId() {\r\n        return Math.max(...MyCalc\r\n            .getExpressions()\r\n            .filter((x) => x.id.startsWith('shade_'))\r\n            .filter((x) => !x.id.includes('folder'))\r\n            .map((x) => parseInt(x.id.split('_')[1], 10)), 0);\r\n    }\r\n    const shadingData = {\r\n        lastUpperBoundary: {\r\n            x: MyCalc.linkedVariable(null, -Infinity),\r\n            y: MyCalc.linkedVariable(null, -Infinity),\r\n        },\r\n        lastLowerBoundary: {\r\n            x: MyCalc.linkedVariable(null, Infinity),\r\n            y: MyCalc.linkedVariable(null, Infinity),\r\n        },\r\n    };\r\n    function updateVariables(filter) {\r\n        Object.keys(MyCalc.globalVariablesObject).forEach(key => {\r\n            delete MyCalc.globalVariablesObject[key];\r\n        });\r\n        let currExpressions = MyCalc.getExpressions();\r\n        if (filter) {\r\n            const idFilter = `${filter}_`;\r\n            currExpressions = currExpressions.filter((x) => x.id.startsWith(idFilter));\r\n        }\r\n        for (let i = 0; i < currExpressions.length; i++) {\r\n            const expression = currExpressions[i];\r\n            const analysis = MyCalc.expressionAnalysis[expression.id];\r\n            if (analysis) {\r\n                if (analysis.evaluation) {\r\n                    if (analysis.evaluation.type === 'Number') {\r\n                        const variable = expression.latex.split('=')[0];\r\n                        if (variable.includes('_') && !(['x', 'y'].includes(variable))) {\r\n                            MyCalc.globalVariablesObject[variable] = analysis.evaluation.value.toString();\r\n                        }\r\n                    }\r\n                }\r\n                else if (expression.latex) {\r\n                    if (expression.latex.includes('f_')) {\r\n                        // console.log(expression);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function intersect(array1, array2) {\r\n        return array1.filter((value) => array2.includes(value));\r\n    }\r\n    function doesIntersect(array1, array2) {\r\n        const filteredArray = intersect(array1, array2);\r\n        return (filteredArray.length > 0);\r\n    }\r\n    function typeFilter(expressionList, graphType, types) {\r\n        const ceTypes = _constants__WEBPACK_IMPORTED_MODULE_2__.expressionFormat[graphType];\r\n        return expressionList.filter((x) => doesIntersect(ceTypes[parseInt(x.id.split('_')[1], 10)].types, types));\r\n    }\r\n    function createGraphObject(expression) {\r\n        const graphType = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getGraphType)(expression);\r\n        const Class = GraphTypes[graphType];\r\n        if (Class) {\r\n            return new Class(expression);\r\n        }\r\n        throw Error('Tried to convert non-conic to a conic');\r\n    }\r\n    function getDomainsFromLatex(latex) {\r\n        return [\r\n            ...latex.matchAll(/\\\\left\\\\{((?:[-+]?\\d+\\.?\\d*<)?[xy](?:<[-+]?\\d+\\.?\\d*)?)\\\\right\\\\}/g),\r\n        ].map((domain) => domain[1]);\r\n    }\r\n    function transformVariables(graphType, variables) {\r\n        return GraphTypes[graphType].transformVariables(variables);\r\n    }\r\n    function toId(expression, _id) {\r\n        return expression.replace(/_\\{\\d+([a-z]*)}/g, `_{${_id}$1}`);\r\n    }\r\n    function createGraphWithBounds(graphId, graphType, variables, _bounds, _logical) {\r\n        const logical = !!_logical;\r\n        let { xMin, yMin, xMax, yMax } = _bounds;\r\n        let cropType = 0;\r\n        // 0 - default (x and y), 1 - x only, 2 - y only, 3 - no crop\r\n        if (!Number.isFinite(xMin) && !Number.isFinite(xMax)) { // Has no x domain\r\n            cropType += 2;\r\n        }\r\n        if (!Number.isFinite(yMin) && !Number.isFinite(yMax)) { // Has no y domain\r\n            cropType += 1;\r\n        }\r\n        let h = 0;\r\n        let k = 0;\r\n        const expression = _constants__WEBPACK_IMPORTED_MODULE_2__.expressionFormat[graphType];\r\n        const expressionsToSet = [];\r\n        GraphTypes[graphType].setGraphVariables(variables, graphId);\r\n        if (GraphTypes[graphType].hasCenter) {\r\n            ({ h, k } = variables);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cam}`, (xMin - h).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cam}`, (yMin - k).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cbm}`, (xMax - h).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cbm}`, (yMax - k).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}ca}`, xMin.toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}ca}`, yMin.toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cb}`, xMax.toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cb}`, yMax.toString());\r\n        }\r\n        if (logical) {\r\n            const newExpression = expression[0];\r\n            let newExpressionLatex = newExpression.latex;\r\n            newExpressionLatex = newExpressionLatex.replaceAll('_{1', `_{${graphId}`);\r\n            if (GraphTypes[graphType].hasCenter) {\r\n                newExpressionLatex += (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(MyCalc.linkedVariable(`x_{${graphId}ca}`, xMin), MyCalc.linkedVariable(`y_{${graphId}ca}`, yMin), MyCalc.linkedVariable(`x_{${graphId}cb}`, xMax), MyCalc.linkedVariable(`y_{${graphId}cb}`, yMax))\r\n                    .reference;\r\n                const conic = createGraphObject({\r\n                    id: `${graphId.toString()}_${0}`,\r\n                    latex: newExpressionLatex,\r\n                    color: 'BLACK',\r\n                    hidden: false,\r\n                    type: 'expression'\r\n                });\r\n                const bounds = conic.getRealBounds();\r\n                if (!Number.isFinite(xMin)) {\r\n                    xMin = bounds.xMin.value - 2;\r\n                }\r\n                if (!Number.isFinite(yMin)) {\r\n                    yMin = bounds.yMin.value - 2;\r\n                }\r\n                if (!Number.isFinite(xMax)) {\r\n                    xMax = bounds.xMax.value + 2;\r\n                }\r\n                if (!Number.isFinite(yMax)) {\r\n                    yMax = bounds.yMax.value + 2;\r\n                }\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cam}`, (xMin - h).toString());\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cam}`, (yMin - k).toString());\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cbm}`, (xMax - h).toString());\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cbm}`, (yMax - k).toString());\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}ca}`, xMin.toString());\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}ca}`, yMin.toString());\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cb}`, xMax.toString());\r\n                (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cb}`, yMax.toString());\r\n                MyCalc.setLogicalExpression({\r\n                    id: `${graphId.toString()}_${0}`,\r\n                    latex: newExpressionLatex,\r\n                    color: 'BLACK',\r\n                    hidden: false,\r\n                    type: 'expression',\r\n                });\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < expression.length; i++) {\r\n                const newExpression = expression[i];\r\n                let newExpressionLatex = newExpression.latex;\r\n                newExpressionLatex = newExpressionLatex.replaceAll('_{1', `_{${graphId}`);\r\n                if (doesIntersect(newExpression.types, ['var'])) {\r\n                    const [variable] = newExpressionLatex.split('=');\r\n                    const value = MyCalc.globalVariablesObject[toId(variable, graphId)];\r\n                    newExpressionLatex = `${variable}=${(0,_lib__WEBPACK_IMPORTED_MODULE_0__.simplify)(parseFloat(value), 4)}`;\r\n                }\r\n                if (graphType !== 6) {\r\n                    if (i === 0) {\r\n                        newExpressionLatex += (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(MyCalc.linkedVariable(`x_{${graphId}ca}`, xMin), MyCalc.linkedVariable(`y_{${graphId}ca}`, yMin), MyCalc.linkedVariable(`x_{${graphId}cb}`, xMax), MyCalc.linkedVariable(`y_{${graphId}cb}`, yMax))\r\n                            .reference;\r\n                        const conic = createGraphObject({ id: `${graphId.toString()}_${i}`, latex: newExpressionLatex, color: 'BLACK', hidden: doesIntersect(expression[i].types, ['x_expression', 'y_expression']), type: 'expression' });\r\n                        const bounds = conic.getRealBounds();\r\n                        if (!Number.isFinite(xMin)) {\r\n                            xMin = bounds.xMin.value - 2;\r\n                        }\r\n                        if (!Number.isFinite(yMin)) {\r\n                            yMin = bounds.yMin.value - 2;\r\n                        }\r\n                        if (!Number.isFinite(xMax)) {\r\n                            xMax = bounds.xMax.value + 2;\r\n                        }\r\n                        if (!Number.isFinite(yMax)) {\r\n                            yMax = bounds.yMax.value + 2;\r\n                        }\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cam}`, (xMin - h).toString());\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cam}`, (yMin - k).toString());\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cbm}`, (xMax - h).toString());\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cbm}`, (yMax - k).toString());\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}ca}`, xMin.toString());\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}ca}`, yMin.toString());\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cb}`, xMax.toString());\r\n                        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cb}`, yMax.toString());\r\n                    }\r\n                }\r\n                let isHidden = doesIntersect(expression[i].types, ['x_expression', 'y_expression']);\r\n                if (doesIntersect(expression[i].types, ['x']))\r\n                    isHidden = (cropType % 2 === 1);\r\n                if (doesIntersect(expression[i].types, ['y']))\r\n                    isHidden = cropType > 1;\r\n                if (doesIntersect(expression[i].types, ['xy']))\r\n                    isHidden = cropType === 3;\r\n                expressionsToSet.push({\r\n                    id: `${graphId.toString()}_${i}`,\r\n                    latex: newExpressionLatex,\r\n                    color: 'BLACK',\r\n                    hidden: isHidden,\r\n                    type: 'expression',\r\n                });\r\n            }\r\n            MyCalc.setExpressions(expressionsToSet);\r\n        }\r\n    }\r\n    function convertFromStandard(latex, _id, _logical) {\r\n        const logical = !!_logical;\r\n        const graphId = parseInt(_id, 10);\r\n        const regex = [\r\n            /\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\+\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}=([-+]?\\d+\\.?\\d*)/g,\r\n            /\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}=([-+]?\\d+\\.?\\d*)\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)/g,\r\n            /\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}=([-+]?\\d+\\.?\\d*)\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)/g,\r\n            /\\\\frac\\{\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}\\+\\\\frac\\{\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}=1/g,\r\n            /\\\\frac\\{\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}-\\\\frac\\{\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}=1/g,\r\n            /\\\\frac\\{\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}-\\\\frac\\{\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}=1/g,\r\n            /y=([-+]?\\d+\\.?\\d*)x([-+]?\\d+\\.?\\d*)\\\\left\\\\{([-+]?\\d+\\.?\\d*)<x<([-+]?\\d+\\.?\\d*)\\\\right\\\\}/g,\r\n        ];\r\n        const graphType = regex.findIndex((pattern) => pattern.test(latex));\r\n        if (graphType === -1) {\r\n        }\r\n        else {\r\n            const currRegex = regex[graphType];\r\n            const match = latex.match(currRegex);\r\n            if (match) {\r\n                const variables = [...match[0].matchAll(currRegex)][0].slice(1)\r\n                    .map((x) => parseFloat(x));\r\n                const domains = getDomainsFromLatex(latex);\r\n                if (domains) {\r\n                    const bounds = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.parseDomains)(domains);\r\n                    createGraphWithBounds(graphId, graphType, transformVariables(graphType, variables), bounds, logical);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function unfinalizeConvert(expressionId) {\r\n        const regex = /y=([-+]?(?:\\d+\\.?\\d*)?)\\\\sqrt\\{([-+]?\\d+\\.?\\d*)\\+\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}([-+]?\\d+\\.?\\d*)/g;\r\n        const expression = MyCalc.getExpression(expressionId);\r\n        if (expression) {\r\n            const variables = [...expression.latex.matchAll(regex)][0].slice(1);\r\n            if (variables.length) {\r\n                const [_a, _b, _h, _k] = variables;\r\n                const a = parseFloat(_a === '-' ? '-1' : _a);\r\n                const b = parseFloat(_b);\r\n                const h = -parseFloat(_h);\r\n                const k = parseFloat(_k);\r\n                const a2 = b * a ** 2;\r\n                const b2 = b;\r\n                const { xMin: _xMin, xMax: _xMax, yMin: _yMin, yMax: _yMax } = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.parseDomains)(getDomainsFromLatex(expression.latex));\r\n                const xMin = Math.max(-Infinity, _xMin);\r\n                const xMax = Math.min(Infinity, _xMax);\r\n                if (a < 0) { // down\r\n                    const yMin = Math.max(-Infinity, _yMin);\r\n                    const yMax = Math.min(k, _yMax);\r\n                    if (b < 0) { // horizontal hyperbola\r\n                        createGraphWithBounds(globalId, 4, { h, a: Math.sqrt(Math.abs(b2)), k, b: Math.sqrt(Math.abs(a2)) }, { xMin, xMax, yMin, yMax });\r\n                    }\r\n                    else if (b > 0) { // vertical hyperbola\r\n                        createGraphWithBounds(globalId, 5, { h, a: Math.sqrt(Math.abs(a2)), k, b: Math.sqrt(Math.abs(b2)) }, { xMin, xMax, yMin, yMax });\r\n                    }\r\n                }\r\n                else if (a > 0) { // up\r\n                    const yMin = Math.max(k, _yMin);\r\n                    const yMax = Math.min(Infinity, _yMax);\r\n                    if (b < 0) { // horizontal hyperbola\r\n                        createGraphWithBounds(globalId, 4, { h, a: Math.sqrt(Math.abs(b2)), k, b: Math.sqrt(Math.abs(a2)) }, { xMin, xMax, yMin, yMax });\r\n                    }\r\n                    else if (b > 0) { // vertical parabola\r\n                        createGraphWithBounds(globalId, 5, { h, a: Math.sqrt(Math.abs(a2)), k, b: Math.sqrt(Math.abs(b2)) }, { xMin, xMax, yMin, yMax });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function unfinalize(expressionId, _logical) {\r\n        const logical = !!_logical;\r\n        const currId = expressionId.split('_')[1];\r\n        const baseExpression = MyCalc.getExpression(expressionId);\r\n        if (baseExpression) {\r\n            convertFromStandard(baseExpression.latex, currId, logical);\r\n            if (!logical) {\r\n                MyCalc.removeExpressions([baseExpression]);\r\n            }\r\n        }\r\n    }\r\n    function finalize(expressionId) {\r\n        if (MyCalc.isLogical(expressionId)) {\r\n            const graphId = parseInt(expressionId.split(\"_\")[0]);\r\n            const expressionList = MyCalc.dependsOn(graphId).map((_expression) => {\r\n                const expression = _expression;\r\n                expression.latex = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.substituteFromId)(expression.latex, graphId);\r\n                return expression;\r\n            });\r\n            MyCalc.updateExpressions(expressionList);\r\n            MyCalc.removeExpressionById(expressionId);\r\n        }\r\n        else {\r\n            const currId = expressionId.split('_')[0];\r\n            const sameIdItem = MyCalc.getExpression(`final_${currId}`);\r\n            if (sameIdItem) {\r\n                // throw Error('Same id for some reason')\r\n            }\r\n            const idFilter = `${currId}_`;\r\n            const filteredExpressions = MyCalc.getExpressions().filter((expression) => expression.id.startsWith(idFilter));\r\n            const baseExpression = MyCalc.getExpression(`${currId}_0`);\r\n            if (!baseExpression) {\r\n                throw Error(`Cannot find expression with id ${currId}_0`);\r\n            }\r\n            const conic = createGraphObject(baseExpression);\r\n            const expressionList = [];\r\n            MyCalc.removeExpressions(filteredExpressions);\r\n            const allExpressions = MyCalc.getExpressions();\r\n            for (let i = 0; i < allExpressions.length; i++) {\r\n                const expression = allExpressions[i];\r\n                if (expression.latex) {\r\n                    if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.usesVariable)(expression.latex, conic.graphId)) {\r\n                        expression.latex = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.substituteFromId)(expression.latex, conic.graphId);\r\n                        expressionList.push(expression);\r\n                    }\r\n                }\r\n            }\r\n            MyCalc.updateExpressions(expressionList);\r\n            conic.latex = conic.convertToStandard();\r\n            if (sameIdItem) {\r\n                conic.id = `final_${globalId}`;\r\n                globalId += 1;\r\n            }\r\n            else {\r\n                conic.id = `final_${conic.graphId}`;\r\n            }\r\n            MyCalc.setExpression(conic);\r\n        }\r\n    }\r\n    function createConic(graphType) {\r\n        const expression = _constants__WEBPACK_IMPORTED_MODULE_2__.expressionFormat[graphType];\r\n        const expressionsToSet = [];\r\n        for (let i = 0; i < expression.length; i++) {\r\n            const newExpression = expression[i];\r\n            let newExpressionLatex = newExpression.latex;\r\n            if (i === 0) {\r\n                if (graphType !== 6) {\r\n                    newExpressionLatex += '\\\\left\\\\{x_{1ca}<x<x_{1cb}\\\\right\\\\}\\\\left\\\\{y_{1ca}<y<y_{1cb}\\\\right\\\\}';\r\n                }\r\n            }\r\n            newExpressionLatex = newExpressionLatex.replace(/_\\{\\d+([a-z]*)}/g, `_{${globalId}$1}`);\r\n            if (doesIntersect(newExpression.types, ['var'])) {\r\n                const [variable] = newExpressionLatex.split('=');\r\n                const value = MyCalc.globalVariablesObject[toId(variable, globalId)];\r\n                newExpressionLatex = `${variable}=${(0,_lib__WEBPACK_IMPORTED_MODULE_0__.simplify)(parseFloat(value), 4)}`;\r\n            }\r\n            const hidden = doesIntersect(expression[i].types, ['x_expression', 'y_expression']);\r\n            if (hidden) {\r\n                const split = newExpressionLatex.split('=');\r\n                const matches = [...split[0].matchAll(_lib__WEBPACK_IMPORTED_MODULE_0__.functionRegex)];\r\n                if (matches.length > 0) {\r\n                    const [full, name, args] = matches[0];\r\n                    MyCalc.globalFunctionsObject[name] = {\r\n                        id: `${globalId.toString()}_${i}`,\r\n                        args: args.split(','),\r\n                        definition: split[1],\r\n                    };\r\n                }\r\n            }\r\n            expressionsToSet.push({ id: `${globalId.toString()}_${i}`,\r\n                latex: newExpressionLatex,\r\n                color: 'BLACK',\r\n                hidden,\r\n                type: 'expression' });\r\n        }\r\n        MyCalc.newGraph(globalId, expressionsToSet);\r\n        globalId += 1;\r\n    }\r\n    function createDefaultConic(graphType) {\r\n        const coordinates = MyCalc.graphpaperBounds.mathCoordinates;\r\n        expressionPos = { x: parseFloat(((coordinates.left + coordinates.right) / 2).toFixed(4)), y: parseFloat(((coordinates.top + coordinates.bottom) / 2).toFixed(4)) };\r\n        const verticalSize = (coordinates.top - coordinates.bottom);\r\n        const horizontalSize = (coordinates.right - coordinates.left);\r\n        const size = Math.min(verticalSize, horizontalSize);\r\n        GraphTypes[graphType].setDefault(globalId, expressionPos, size);\r\n        if (GraphTypes[graphType].hasCenter) {\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`h_{${globalId}}`, expressionPos.x);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`k_{${globalId}}`, expressionPos.y);\r\n        }\r\n        if (GraphTypes[graphType].hasCrop) {\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${globalId}cam}`, -size * 0.4);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${globalId}cam}`, -size * 0.4);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${globalId}cbm}`, size * 0.4);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${globalId}cbm}`, size * 0.4);\r\n        }\r\n        createConic(graphType);\r\n    }\r\n    function freeze(force, append) {\r\n        let newId = 1;\r\n        const numExpressions = MyCalc.getItemCount();\r\n        if (append) {\r\n            const expressionsString = localStorage.getItem('expressions');\r\n            if (expressionsString) {\r\n                const expressions = JSON.parse(expressionsString);\r\n                let newId = globalId;\r\n                let newShadeId = shadeId;\r\n                const newExpressions = expressions.map((_expression) => {\r\n                    const expression = _expression;\r\n                    const split = expression.id.split(\"_\");\r\n                    if (split[0] === \"final\") {\r\n                        expression.id = `final_${newId}`;\r\n                        newId += 1;\r\n                    }\r\n                    else if (split[0] === \"shade\") {\r\n                        expression.id = `shade_${newShadeId}`;\r\n                        newShadeId += 1;\r\n                    }\r\n                    return expression;\r\n                });\r\n                MyCalc.setExpressions(newExpressions);\r\n                globalId = newId;\r\n                shadeId = newShadeId;\r\n            }\r\n        }\r\n        else {\r\n            if (numExpressions !== 1) {\r\n                const expressions = MyCalc.getExpressions();\r\n                let graphExpressionsNormal = [];\r\n                if (force) {\r\n                    graphExpressionsNormal = expressions.filter((x) => !x.id.includes('_'));\r\n                }\r\n                const graphExpressionsBase = expressions.filter((x) => x.id.endsWith('_0') && !x.id.startsWith('final_'));\r\n                const graphExpressionsFinal = expressions.filter((x) => x.id.startsWith('final_') && !x.id.includes('folder'));\r\n                const graphExpressionsShade = expressions.filter((x) => x.id.startsWith('shade_') && !x.id.includes('folder'));\r\n                const graphExpressionsNormalLatex = graphExpressionsNormal.map((_graphExpression) => {\r\n                    const graphExpression = _graphExpression;\r\n                    graphExpression.id = `final_${newId}`;\r\n                    newId += 1;\r\n                    return graphExpression;\r\n                });\r\n                const graphExpressionsBaseLatex = graphExpressionsBase.map((_graphExpression) => {\r\n                    const conic = createGraphObject(_graphExpression);\r\n                    conic.latex = conic.convertToStandard();\r\n                    conic.id = `final_${newId}`;\r\n                    conic.graphId = newId;\r\n                    newId += 1;\r\n                    return conic.toExpression();\r\n                });\r\n                const graphExpressionsFinalLatex = graphExpressionsFinal.map((_graphExpression) => {\r\n                    const graphExpression = _graphExpression;\r\n                    graphExpression.id = `final_${newId}`;\r\n                    newId += 1;\r\n                    return graphExpression;\r\n                });\r\n                const graphExpressionsShadeLatex = graphExpressionsShade.map((_graphExpression) => {\r\n                    const graphExpression = _graphExpression;\r\n                    const latex = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.substituteParenthesis)(graphExpression.latex);\r\n                    const expression = { color: graphExpression.color, fillOpacity: graphExpression.fillOpacity, hidden: false, id: graphExpression.id, latex, type: 'expression' };\r\n                    return expression;\r\n                });\r\n                const latexAll = [\r\n                    ...graphExpressionsNormalLatex,\r\n                    ...graphExpressionsShadeLatex,\r\n                    ...graphExpressionsBaseLatex,\r\n                    ...graphExpressionsFinalLatex,\r\n                ];\r\n                localStorage.setItem('expressions', JSON.stringify(latexAll));\r\n            }\r\n            else {\r\n                const expressionsString = localStorage.getItem('expressions');\r\n                if (expressionsString) {\r\n                    const expressions = JSON.parse(expressionsString);\r\n                    MyCalc.setExpressions(expressions);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function resetSelection() {\r\n        shadingData.lastUpperBoundary = { x: MyCalc.linkedVariable(-Infinity), y: MyCalc.linkedVariable(-Infinity) };\r\n        shadingData.lastLowerBoundary = { x: MyCalc.linkedVariable(Infinity), y: MyCalc.linkedVariable(Infinity) };\r\n    }\r\n    function finalizeId(_id) {\r\n        if (_id.startsWith('final_')) {\r\n            unfinalize(_id);\r\n        }\r\n        else if (_id.includes('_')) {\r\n            finalize(_id);\r\n        }\r\n        else {\r\n            unfinalizeConvert(_id);\r\n        }\r\n    }\r\n    function fixNegative() {\r\n        let toFix = [];\r\n        const negativeab = MyCalc.getExpressions()\r\n            .filter((x) => /[ab]_{\\d*\\w+}=-\\d+[.]{0,1}\\d*/g.test(x.latex)); // Selects ellipse, hyperbola with negative a, b\r\n        toFix = [...toFix, ...negativeab.map((expression) => {\r\n                expression.latex.replaceAll('-', '');\r\n                return expression;\r\n            })];\r\n        MyCalc.updateExpressions(toFix);\r\n    }\r\n    function deleteById(_id) {\r\n        if (_id.includes('_')) {\r\n            if (['shade', 'final'].includes(_id.split('_')[0])) {\r\n                const expression = MyCalc.getExpression(_id);\r\n                if (expression) {\r\n                    MyCalc.removeExpression(expression);\r\n                }\r\n            }\r\n            else {\r\n                const graphId = parseInt(_id.split('_')[0]);\r\n                const idFilter = `${graphId}_`;\r\n                let filteredExpressions = MyCalc.getExpressions();\r\n                filteredExpressions = filteredExpressions.filter((x) => x.id.startsWith(idFilter));\r\n                MyCalc.removeExpressions(filteredExpressions);\r\n                // MyCalc.removeExpressions(MyCalc.dependsOn(parseInt(currId)))\r\n                const expressionList = MyCalc.dependsOn(graphId).map((_expression) => {\r\n                    const expression = _expression;\r\n                    expression.latex = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.substituteFromId)(expression.latex, graphId);\r\n                    return expression;\r\n                });\r\n                MyCalc.updateExpressions(expressionList);\r\n            }\r\n        }\r\n    }\r\n    function changeCropMode(_id) {\r\n        if (_id.includes('_')) {\r\n            const currId = _id.split('_')[0];\r\n            const idFilter = `${currId}_`;\r\n            let filteredExpressions = MyCalc.getExpressions();\r\n            filteredExpressions = filteredExpressions.filter((x) => x.id.startsWith(idFilter) && !x.id.includes('folder'));\r\n            const graphExpression = filteredExpressions.find((x) => x.id.endsWith('_0'));\r\n            if (!graphExpression) {\r\n                throw new Error();\r\n            }\r\n            const conic = createGraphObject(graphExpression);\r\n            const { graphType } = conic;\r\n            // 0 - default (x and y), 1 - x only, 2 - y only, 3 - no crop\r\n            let cropType = conic.getCropType();\r\n            cropType = (cropType + 1) % 4;\r\n            [conic.latex] = conic.latex.split('\\\\left\\\\{');\r\n            const addition = (cropType < 2 ? '\\\\left\\\\{x_{1ca}<x<x_{1cb}\\\\right\\\\}' : '') + (!(cropType % 2) ? '\\\\left\\\\{y_{1ca}<y<y_{1cb}\\\\right\\\\}' : '');\r\n            conic.latex += addition.replaceAll('_{1', `_{${currId}`);\r\n            const xBoundary = typeFilter(filteredExpressions, graphType, ['x']); // x only domain\r\n            const yBoundary = typeFilter(filteredExpressions, graphType, ['y']); // y only domain\r\n            const xyPoints = typeFilter(filteredExpressions, graphType, ['xy']); // points\r\n            const expressionsToSet = [];\r\n            for (let i = 0; i < xBoundary.length; i++) {\r\n                const expression = xBoundary[i];\r\n                expression.hidden = (cropType % 2 === 1);\r\n                expressionsToSet.push(expression);\r\n            }\r\n            for (let i = 0; i < yBoundary.length; i++) {\r\n                const expression = yBoundary[i];\r\n                expression.hidden = (cropType > 1);\r\n                expressionsToSet.push(expression);\r\n            }\r\n            for (let i = 0; i < xyPoints.length; i++) {\r\n                const expression = xyPoints[i];\r\n                expression.hidden = (cropType === 3);\r\n                expressionsToSet.push(expression);\r\n            }\r\n            expressionsToSet.push(conic);\r\n            MyCalc.updateExpressions(expressionsToSet);\r\n        }\r\n    }\r\n    function hideCropLines(_id) {\r\n        if (_id.includes('_')) {\r\n            const idFilter = `${_id.split('_')[0]}_`;\r\n            let filteredExpressions = MyCalc.getExpressions();\r\n            filteredExpressions = filteredExpressions.filter((x) => x.id.startsWith(idFilter))\r\n                .filter((x) => !x.id.includes('folder'));\r\n            const graphExpression = filteredExpressions.find((x) => x.id.endsWith('_0'));\r\n            if (!graphExpression) {\r\n                throw new Error();\r\n            }\r\n            const conic = createGraphObject(graphExpression);\r\n            const { graphType } = conic;\r\n            filteredExpressions = typeFilter(filteredExpressions, graphType, ['hide']);\r\n            let [newExpression] = filteredExpressions;\r\n            const newState = !newExpression.hidden;\r\n            const expressionsToSet = [];\r\n            const cropType = conic.getCropType();\r\n            const xBoundary = typeFilter(filteredExpressions, graphType, ['x']); // x only domain\r\n            const yBoundary = typeFilter(filteredExpressions, graphType, ['y']); // y only domain\r\n            const xyPoints = typeFilter(filteredExpressions, graphType, ['xy']); // points\r\n            const avoidPoints = [\r\n                ...xBoundary.map((exp) => exp.id),\r\n                ...yBoundary.map((exp) => exp.id),\r\n                ...xyPoints.map((exp) => exp.id),\r\n            ];\r\n            if (!newState) {\r\n                for (let i = 0; i < filteredExpressions.length; i++) {\r\n                    newExpression = filteredExpressions[i];\r\n                    if (!avoidPoints.includes(newExpression.id)) {\r\n                        newExpression.hidden = false;\r\n                    }\r\n                    expressionsToSet.push(newExpression);\r\n                }\r\n                for (let j = 0; j < xBoundary.length; j++) {\r\n                    const expression = xBoundary[j];\r\n                    expression.hidden = (cropType % 2 === 1);\r\n                    expressionsToSet.push(expression);\r\n                }\r\n                for (let j = 0; j < yBoundary.length; j++) {\r\n                    const expression = yBoundary[j];\r\n                    expression.hidden = (cropType > 1);\r\n                    expressionsToSet.push(expression);\r\n                }\r\n                for (let j = 0; j < xyPoints.length; j++) {\r\n                    const expression = xyPoints[j];\r\n                    expression.hidden = (cropType === 3);\r\n                    expressionsToSet.push(expression);\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0; i < filteredExpressions.length; i++) {\r\n                    newExpression = filteredExpressions[i];\r\n                    if ('hidden' in newExpression) {\r\n                        newExpression.hidden = newState;\r\n                    }\r\n                    expressionsToSet.push(newExpression);\r\n                }\r\n            }\r\n            MyCalc.updateExpressions(expressionsToSet);\r\n        }\r\n    }\r\n    function setId() {\r\n        const baseId = Math.max(0, Math.max(...MyCalc.getExpressions()\r\n            .filter((x) => x.id.endsWith('_0'))\r\n            .map((x) => parseInt(x.id.split('_')[0], 10))\r\n            .filter((x) => !Number.isNaN(x)))) + 1;\r\n        const finalId = Math.max(0, Math.max(...MyCalc.getExpressions()\r\n            .filter((x) => x.id.startsWith('final_'))\r\n            .map((x) => parseInt(x.id.split('_')[1], 10))\r\n            .filter((x) => !Number.isNaN(x)))) + 1;\r\n        globalId = Math.max(baseId, finalId);\r\n        idSet = true;\r\n    }\r\n    function shadeToBack() {\r\n        const state = MyCalc.getState();\r\n        state.expressions.list = state.expressions.list\r\n            .filter((x) => x.id.startsWith('shade_'))\r\n            .concat(state.expressions.list.filter((x) => !x.id.startsWith('shade_')));\r\n        MyCalc.setState(state);\r\n    }\r\n    function toggleShading() {\r\n        const shade = MyCalc.getExpressions()\r\n            .filter((x) => x.id.startsWith('shade_') && !x.id.includes('folder'));\r\n        const newState = !shade[0].hidden;\r\n        MyCalc.updateExpressions(shade.map((_x) => {\r\n            const x = _x;\r\n            x.hidden = newState;\r\n            return x;\r\n        }));\r\n    }\r\n    function getBoundsById(_id) {\r\n        const graphExpression = MyCalc.getExpression(_id);\r\n        if (graphExpression) {\r\n            console.log((createGraphObject(graphExpression))\r\n                .getRealBounds());\r\n        }\r\n    }\r\n    function expressionToFront(_id) {\r\n        const state = MyCalc.getState();\r\n        const expression = state.expressions.list\r\n            .filter((_expression) => _expression.id === _id);\r\n        const multipleExpressions = state.expressions.list\r\n            .filter((_expression) => _expression.id !== _id);\r\n        state.expressions.list = expression.concat(multipleExpressions);\r\n        MyCalc.setState(state);\r\n    }\r\n    function keyUpHandler(e) {\r\n        if (MyCalc)\r\n            MyCalc.updateLinkedVariables();\r\n        updateVariables();\r\n        setId();\r\n        if (currentlyPressed.includes(e.keyCode)) {\r\n            currentlyPressed = currentlyPressed.filter((key) => key !== e.keyCode);\r\n        }\r\n        if (e.ctrlKey && e.shiftKey) {\r\n            const { key } = e;\r\n            if (key === '<') {\r\n                if (MyCalc.selectedExpressionId) {\r\n                    expressionToFront(MyCalc.selectedExpressionId);\r\n                }\r\n            }\r\n            if (key === 'F') { // F - Finalize\r\n                if (MyCalc.selectedExpressionId) {\r\n                    finalizeId(MyCalc.selectedExpressionId);\r\n                }\r\n            }\r\n        }\r\n        if (e.key === 'Control') {\r\n            ctrlTime = Date.now();\r\n        }\r\n        if (e.key === 'Alt') {\r\n            altTime = Date.now();\r\n        }\r\n        if (e.ctrlKey || (Date.now() - ctrlTime) < 100) {\r\n            ctrlTime = Date.now();\r\n            const { key } = e;\r\n        }\r\n        if (e.altKey || (Date.now() - altTime) < 100) {\r\n            altTime = Date.now();\r\n            const { keyCode } = e;\r\n            if (keyCode === 87) {\r\n                const selection = selections.pop();\r\n            }\r\n            if (keyCode === 77) {\r\n                if (MyCalc.selectedExpressionId) {\r\n                    getBoundsById(MyCalc.selectedExpressionId);\r\n                }\r\n            }\r\n            if (keyCode === 219) {\r\n                fixNegative();\r\n            }\r\n            if (keyCode === 189) {\r\n                shadeToBack();\r\n            }\r\n            else if (keyCode === 187) {\r\n                toggleShading();\r\n            }\r\n            else if ((keyCode >= 49) && (keyCode <= 56)) {\r\n                createDefaultConic(keyCode - 49);\r\n            }\r\n            else if (keyCode === 83) { // bottom\r\n                resetSelection();\r\n            }\r\n            else if (keyCode === 48) {\r\n                freeze(e.shiftKey, e.ctrlKey);\r\n            }\r\n            else if (keyCode === 88) {\r\n                if (MyCalc.selectedExpressionId)\r\n                    deleteById(MyCalc.selectedExpressionId);\r\n            }\r\n            else if (keyCode === 81) {\r\n                if (MyCalc.selectedExpressionId)\r\n                    changeCropMode(MyCalc.selectedExpressionId);\r\n            }\r\n            else if (keyCode === 72) {\r\n                if (MyCalc.selectedExpressionId)\r\n                    hideCropLines(MyCalc.selectedExpressionId);\r\n            }\r\n            else if (keyCode === 70) {\r\n                easyMode = !easyMode;\r\n            }\r\n        }\r\n        e.preventDefault();\r\n    }\r\n    function keyDownHandler(e) {\r\n        if (MyCalc)\r\n            MyCalc.updateLinkedVariables();\r\n        if (e.altKey) {\r\n            if (!currentlyPressed.includes(e.keyCode)) {\r\n                currentlyPressed.push(e.keyCode);\r\n            }\r\n        }\r\n    }\r\n    function fillInside(expressionId) {\r\n        const object = MyCalc.getExpression(expressionId);\r\n        if (object) {\r\n            const conic = createGraphObject(object);\r\n            if ([0, 4].includes(conic.graphType)) {\r\n                conic.latex = conic.latex.replace('=', '>');\r\n            }\r\n            else if ([1, 2, 3, 5, 6].includes(conic.graphType)) {\r\n                conic.latex = conic.latex.replace('=', '<');\r\n            }\r\n            MyCalc.setExpression({ color: 'BLACK', hidden: false, type: 'expression', id: `shade_${shadeId}`, latex: conic.latex });\r\n            shadeId += 1;\r\n        }\r\n    }\r\n    function fillIntersection(lowerId, upperId, axis) {\r\n        const lowerObject = MyCalc.getExpression(lowerId);\r\n        const upperObject = MyCalc.getExpression(upperId);\r\n        if (!upperObject || !lowerObject) {\r\n            throw new Error(\"This shouldn't happen\");\r\n        }\r\n        const lowerConic = createGraphObject(lowerObject);\r\n        const upperConic = createGraphObject(upperObject);\r\n        const lowerBounds = lowerConic.getRealBounds();\r\n        const upperBounds = upperConic.getRealBounds();\r\n        if (axis === 'y') {\r\n            let realMin = lowerBounds.xMin.value < upperBounds.xMin.value\r\n                ? upperBounds.xMin : lowerBounds.xMin;\r\n            let realMax = lowerBounds.xMax.value > upperBounds.xMax.value\r\n                ? upperBounds.xMax : lowerBounds.xMax;\r\n            if (Number.isFinite(lastCenterPoint.x)) {\r\n                if (shadingData.lastUpperBoundary.y.value > realMin.value && lastCenterPoint.x < centerPoint.x) { // To right\r\n                    realMin = shadingData.lastUpperBoundary.y;\r\n                }\r\n                if (shadingData.lastLowerBoundary.y.value < realMax.value && lastCenterPoint.x > centerPoint.x) {\r\n                    realMax = shadingData.lastLowerBoundary.y;\r\n                }\r\n            }\r\n            shadingData.lastUpperBoundary.y = realMax;\r\n            shadingData.lastLowerBoundary.y = realMin;\r\n            const bounds = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(realMin, MyCalc.linkedVariable(-Infinity), realMax, MyCalc.linkedVariable(Infinity)).reference;\r\n            const newExpressions = [];\r\n            const lowerConicConverted = lowerConic.convertToYRelevant();\r\n            const upperConicConverted = upperConic.convertToYRelevant();\r\n            for (let lowerIndex = 0; lowerIndex < lowerConicConverted.length; lowerIndex++) {\r\n                const currLowerConic = lowerConicConverted[lowerIndex];\r\n                for (let upperIndex = 0; upperIndex < upperConicConverted.length; upperIndex++) {\r\n                    const currUpperConic = upperConicConverted[upperIndex];\r\n                    const newExpression = `${currLowerConic}<y<${currUpperConic}${bounds}`;\r\n                    newExpressions.push({ color: 'BLACK', hidden: false, type: 'expression', id: `shade_${shadeId}`, latex: newExpression, fillOpacity: '1' });\r\n                    shadeId += 1;\r\n                }\r\n            }\r\n            MyCalc.setExpressions(newExpressions);\r\n        }\r\n        else if (axis === 'x') {\r\n            let realMin = lowerBounds.yMin.value < upperBounds.yMin.value\r\n                ? upperBounds.yMin : lowerBounds.yMin;\r\n            let realMax = lowerBounds.yMax.value > upperBounds.yMax.value\r\n                ? upperBounds.yMax : lowerBounds.yMax;\r\n            if (Number.isFinite(lastCenterPoint.y)) {\r\n                if (shadingData.lastUpperBoundary.x.value > realMin.value && lastCenterPoint.y < centerPoint.y) {\r\n                    realMin = shadingData.lastUpperBoundary.x;\r\n                }\r\n                if (shadingData.lastLowerBoundary.x.value < realMax.value && lastCenterPoint.y > centerPoint.y) {\r\n                    realMax = shadingData.lastLowerBoundary.x;\r\n                }\r\n            }\r\n            shadingData.lastUpperBoundary.x = realMax;\r\n            shadingData.lastLowerBoundary.x = realMin;\r\n            const bounds = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(MyCalc.linkedVariable(-Infinity), realMin, MyCalc.linkedVariable(Infinity), realMax)\r\n                .reference;\r\n            const newExpressions = [];\r\n            const lowerConicConverted = lowerConic.convertToXRelevant();\r\n            const upperConicConverted = upperConic.convertToXRelevant();\r\n            for (let lowerIndex = 0; lowerIndex < lowerConicConverted.length; lowerIndex++) {\r\n                const currLowerConic = lowerConicConverted[lowerIndex];\r\n                for (let upperIndex = 0; upperIndex < upperConicConverted.length; upperIndex++) {\r\n                    const currUpperConic = upperConicConverted[upperIndex];\r\n                    const newExpression = `${currLowerConic}<x<${currUpperConic}${bounds}`;\r\n                    newExpressions.push({ color: 'BLACK', hidden: false, type: 'expression', id: `shade_${shadeId}`, latex: newExpression });\r\n                    shadeId += 1;\r\n                }\r\n            }\r\n            MyCalc.setExpressions(newExpressions);\r\n        }\r\n    }\r\n    function mouseUpHandler(e) {\r\n        if (MyCalc)\r\n            MyCalc.updateLinkedVariables();\r\n        setId();\r\n        if (MyCalc.selectedExpressionId) {\r\n            lastSelectedId = MyCalc.selectedExpressionId;\r\n        }\r\n        updateVariables();\r\n        if (!shadeIdSet) {\r\n            shadeId = getShadeId() + 1;\r\n            shadeIdSet = true;\r\n        }\r\n        if (easyMode) {\r\n            // if (easySelections.length > 4) {\r\n            //   easySelections.pop()\r\n            // }\r\n            console.log(easySelections);\r\n            if (e.button === 0) {\r\n                const selectedExpression = MyCalc.getSelected();\r\n                MyCalc.selectedExpressionId = undefined;\r\n                if (selectedExpression?.type === 'expression' && isGraph(selectedExpression)) {\r\n                    console.log(selectedExpression);\r\n                    const point = createGraphObject(selectedExpression).getClosestEndpoint(MyCalc.pixelsToMath({\r\n                        x: e.clientX,\r\n                        y: e.clientY,\r\n                    }));\r\n                    console.log(point);\r\n                    easySelections.push({\r\n                        x: point.x.value,\r\n                        y: point.y.value,\r\n                    });\r\n                }\r\n                else {\r\n                    easySelections.push(MyCalc.pixelsToMath({ x: e.clientX, y: e.clientY }));\r\n                }\r\n            }\r\n            else if (e.button == 1) {\r\n                if (easySelections.length === 1) {\r\n                }\r\n                if (easySelections.length === 2) {\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${globalId}a}`, easySelections[0].x);\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${globalId}a}`, easySelections[0].y);\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${globalId}b}`, easySelections[1].x);\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${globalId}b}`, easySelections[1].y);\r\n                    createConic(6);\r\n                }\r\n                if (easySelections.length === 4) {\r\n                    MyCalc.regression(easySelections);\r\n                }\r\n                easySelections = [];\r\n            }\r\n        }\r\n        else {\r\n            if (currentlyPressed.includes(65)) {\r\n                const selected = MyCalc.getSelected();\r\n                if (selected && isGraph(selected)) {\r\n                    selections.push({ id: selected.id, pos: MyCalc.pixelsToMath({ x: e.clientX, y: e.clientY }) });\r\n                }\r\n                if (selections.length >= 2) {\r\n                    const lowerSelection = selections.shift();\r\n                    const upperSelection = selections.shift();\r\n                    if (!upperSelection || !lowerSelection) {\r\n                        throw new Error(\"This shouldn't happen\");\r\n                    }\r\n                    centerPoint = {\r\n                        x: (upperSelection.pos.x + lowerSelection.pos.x) / 2,\r\n                        y: (upperSelection.pos.x + lowerSelection.pos.y) / 2,\r\n                    };\r\n                    const slope = (Math.abs(upperSelection.pos.y - lowerSelection.pos.y) + 1)\r\n                        / (Math.abs(upperSelection.pos.x - lowerSelection.pos.x) + 1);\r\n                    const axis = (slope > 1) ? 'y' : 'x';\r\n                    let upperId = upperSelection.id;\r\n                    let lowerId = lowerSelection.id;\r\n                    if (upperId === lowerId) {\r\n                        const lowerFinal = lowerId.startsWith('final_');\r\n                        if (lowerFinal) {\r\n                            unfinalize(lowerId);\r\n                            lowerId = `${lowerId.split('_')[1]}_0`;\r\n                        }\r\n                        fillInside(lowerId);\r\n                        if (lowerFinal)\r\n                            finalize(lowerId);\r\n                    }\r\n                    else {\r\n                        const lowerFinal = lowerId.startsWith('final_');\r\n                        const upperFinal = upperId.startsWith('final_');\r\n                        if (lowerFinal) {\r\n                            unfinalize(lowerId, true);\r\n                            lowerId = `${lowerId.split('_')[1]}_0`;\r\n                        }\r\n                        if (upperFinal) {\r\n                            unfinalize(upperId, true);\r\n                            upperId = `${upperId.split('_')[1]}_0`;\r\n                        }\r\n                        fillIntersection(lowerId, upperId, axis);\r\n                        if (lowerFinal)\r\n                            finalize(lowerId);\r\n                        if (upperFinal)\r\n                            finalize(upperId);\r\n                    }\r\n                    lastCenterPoint = centerPoint;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    document.addEventListener('keydown', keyDownHandler, false);\r\n    document.addEventListener('keyup', keyUpHandler, false);\r\n    document.addEventListener('pointerup', mouseUpHandler, false);\r\n    function toggleArtist() {\r\n        const x = document.querySelector('#artist');\r\n        const y = document.querySelector('#artist-container');\r\n        if (x)\r\n            x.style.display = x.style.display === 'none' ? 'block' : 'none';\r\n        if (y)\r\n            y.style.display = y.style.display === 'none' ? 'block' : 'none';\r\n    }\r\n    function changeColor() {\r\n        const graphExpression = MyCalc.getExpression(lastSelectedId);\r\n        if (graphExpression) {\r\n            const colorForm = $('#colorForm');\r\n            if (colorForm) {\r\n                const data = colorForm.serializeArray();\r\n                data.forEach((pair) => {\r\n                    graphExpression[pair.name] = pair.value;\r\n                });\r\n                MyCalc.updateExpression(graphExpression);\r\n            }\r\n        }\r\n    }\r\n    function changegraphType() {\r\n        currGraphId = (currGraphId + 1) % 7;\r\n        const button = document.querySelector('#artist-button');\r\n        if (button) {\r\n            button.innerHTML = graphAbbrev[currGraphId];\r\n        }\r\n    }\r\n    function createConicHandler() {\r\n        createDefaultConic(currGraphId);\r\n    }\r\n    const shortcutButtons = false;\r\n    const pillbox = unsafeWindow.document.querySelector('.dcg-overgraph-pillbox-elements');\r\n    if (pillbox) {\r\n        pillbox.insertAdjacentHTML('beforeend', '<div id=\"artist-button-container\"><div class=\"dcg-tooltip-hit-area-container\"><div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings\" role=\"button\" onclick=\\'toggleArtist()\\' style=\"background:#ededed\"><i class=\"dcg-icon-wrench\" aria-hidden=\"true\"></i></div></div><div style=\"display: none\"></div></div>');\r\n        pillbox.insertAdjacentHTML('beforeend', '<div id=\"artist-container\" class=\"dcg-artist-view-container\"></div>');\r\n        const artistContainer = unsafeWindow.document.querySelector('#artist-container');\r\n        if (shortcutButtons) {\r\n            if (artistContainer) {\r\n                artistContainer.insertAdjacentHTML('beforeend', `<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div id=\"artist-button\" class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" oncontextmenu=\"createConicHandler();return false;\" onclick=\"changegraphType()\" style=\"background:#ededed\">${graphAbbrev[currGraphId]}</div></div>`);\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"deleteById(Calc.selectedExpressionId)\" style=\"background:#ededed\">X</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"hideCropLines(Calc.selectedExpressionId)\" style=\"background:#ededed\">H</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"changeCropMode(Calc.selectedExpressionId)\" style=\"background:#ededed\">Q</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"finalizeId(Calc.selectedExpressionId)\" style=\"background:#ededed\">F</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" oncontextmenu=\"freeze(false);return false;\" style=\"background:#ededed\">S</div></div>');\r\n            }\r\n        }\r\n    }\r\n    const body = document.querySelector('.dcg-grapher');\r\n    if (body) {\r\n        body.insertAdjacentHTML('beforeend', '<div id=\"artist\" style=\"position: absolute; bottom: 5%; right: 5%; padding: 10px; border: 1px solid black; border-radius: 10px\"><form id=\"colorForm\" onSubmit=\"return changeColor()\"><div> Color <input name=\"color\" type=\"color\"></div><div> Opacity <input name=\"fillOpacity\" type=\"number\" min=\"0\" max=\"1\" value=\"0.4\"></div><div><input type=\"button\" value=\"Apply\" onclick=\"changeColor()\"></div></form></div>');\r\n    }\r\n    unsafeWindow.MyCalc = MyCalc;\r\n    unsafeWindow.idSet = idSet;\r\n    unsafeWindow.id = globalId;\r\n    unsafeWindow.Conic = _Graph__WEBPACK_IMPORTED_MODULE_1__.Graph;\r\n    unsafeWindow.changeColor = changeColor;\r\n    unsafeWindow.changegraphType = changegraphType;\r\n    unsafeWindow.createConicHandler = createConicHandler;\r\n    unsafeWindow.deleteById = deleteById;\r\n    unsafeWindow.toggleArtist = toggleArtist;\r\n}\r\n(async () => {\r\n    while (typeof Calc === 'undefined') {\r\n        await new Promise((resolve) => setTimeout(resolve, 1000));\r\n    }\r\n    main();\r\n})();\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/index.user.ts?");

/***/ }),

/***/ "./src/lib.ts":
/*!********************!*\
  !*** ./src/lib.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"functionRegex\": () => (/* binding */ functionRegex),\n/* harmony export */   \"functionVariableRegex\": () => (/* binding */ functionVariableRegex),\n/* harmony export */   \"getVariable\": () => (/* binding */ getVariable),\n/* harmony export */   \"substituteParenthesis\": () => (/* binding */ substituteParenthesis),\n/* harmony export */   \"LinkedVariable\": () => (/* binding */ LinkedVariable),\n/* harmony export */   \"getGraphType\": () => (/* binding */ getGraphType),\n/* harmony export */   \"hasXDomain\": () => (/* binding */ hasXDomain),\n/* harmony export */   \"hasYDomain\": () => (/* binding */ hasYDomain),\n/* harmony export */   \"getDomains\": () => (/* binding */ getDomains),\n/* harmony export */   \"parseDomains\": () => (/* binding */ parseDomains),\n/* harmony export */   \"maxLinkedVariable\": () => (/* binding */ maxLinkedVariable),\n/* harmony export */   \"minLinkedVariable\": () => (/* binding */ minLinkedVariable),\n/* harmony export */   \"minMax\": () => (/* binding */ minMax),\n/* harmony export */   \"simplify\": () => (/* binding */ simplify),\n/* harmony export */   \"getVariablesNeeded\": () => (/* binding */ getVariablesNeeded),\n/* harmony export */   \"substitute\": () => (/* binding */ substitute),\n/* harmony export */   \"generateBounds\": () => (/* binding */ generateBounds),\n/* harmony export */   \"usesVariable\": () => (/* binding */ usesVariable),\n/* harmony export */   \"substituteFromId\": () => (/* binding */ substituteFromId),\n/* harmony export */   \"setVariable\": () => (/* binding */ setVariable)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./index.user */ \"./src/index.user.ts\");\n\r\n\r\nconst functionRegex = /([a-z]+_{[\\w\\d]+})(?:\\(([^,\\n=<>]+(?:,.+)*)\\))/g;\r\nconst functionVariableRegex = /([a-z]+_{[\\w\\d]+})(?:\\(([^,\\n=<>]+(?:,.+)*)\\))?/g;\r\nfunction getVariable(name) {\r\n    const match = name.match(/(\\w_{\\d+\\w*})/g);\r\n    if (match && match[0].length === name.length) {\r\n        if (name in _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.globalVariablesObject) {\r\n            return parseFloat(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.globalVariablesObject[name]);\r\n        }\r\n    }\r\n    else {\r\n        const match = [...name.matchAll(functionRegex)];\r\n        if (match.length > 0) {\r\n            const parts = match[0];\r\n            const args = parts[2].split(',');\r\n            const value = evaluateFunction(parts[1], args.map((arg) => getVariable(arg)));\r\n            return value;\r\n        }\r\n        else {\r\n            const value = evaluatex(substitute(name))();\r\n            if (value) {\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n    throw Error(`The variable ${name} is missing`);\r\n}\r\nfunction substituteParenthesis(_latex) {\r\n    let latex = _latex;\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    for (let j = 0; j < variablesNeeded.length; j++) {\r\n        const variableNeeded = variablesNeeded[j][0];\r\n        latex = latex.replace(variableNeeded, `(${simplify(getVariable(variableNeeded), 4)})`);\r\n    }\r\n    return latex;\r\n}\r\nfunction evaluateFunction(_func, values) {\r\n    const funcObject = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.globalFunctionsObject[_func];\r\n    if (!funcObject) {\r\n        throw Error(`Cannot find function with name ${_func}`);\r\n    }\r\n    const args = funcObject.args;\r\n    if (args.length !== values.length) {\r\n        throw Error(`Variable length (${args.length}) and value length (${values.length}) mismatch`);\r\n    }\r\n    else {\r\n        const variablesNeeded = getVariablesNeeded(funcObject.definition)\r\n            .map((variable) => variable[0])\r\n            .filter((variable) => !args.includes(variable));\r\n        const variableObject = {};\r\n        args.forEach((value, index) => variableObject[value] = values[index]);\r\n        variablesNeeded.forEach((value) => variableObject[value.replace(/([a-z])(?:_{(\\d+[a-z]*)})/g, '$1_$2')] = getVariable(value));\r\n        let newDefinition = funcObject.definition;\r\n        variablesNeeded.forEach((value) => {\r\n            newDefinition = newDefinition.replace(value, value.replace(/([a-z])(?:_{(\\d+[a-z]*)})/g, '$1_$2'));\r\n        });\r\n        newDefinition = newDefinition.replaceAll('}\\\\sqrt{', '}\\\\cdot\\\\sqrt{');\r\n        const value = evaluatex(newDefinition, variableObject)();\r\n        if (value !== undefined) {\r\n            return value;\r\n        }\r\n    }\r\n    throw Error('function broken lul');\r\n}\r\nclass LinkedVariable {\r\n    constructor(reference, _value) {\r\n        if (typeof reference === 'number') {\r\n            this.reference = null;\r\n            this._value = reference;\r\n            this.clean = true;\r\n            this.alwaysClean = true;\r\n        }\r\n        else {\r\n            this.clean = true;\r\n            this.alwaysClean = false;\r\n            this.reference = reference;\r\n            if (_value === undefined) {\r\n                if (reference != null) {\r\n                    this._value = getVariable(reference);\r\n                }\r\n                else {\r\n                    throw new Error('Null reference and undefined value');\r\n                }\r\n            }\r\n            else {\r\n                this._value = _value;\r\n            }\r\n        }\r\n        if (_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc) {\r\n            _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.addLinkedVariable(this);\r\n        }\r\n    }\r\n    get value() {\r\n        if (!this.clean) {\r\n            if (this.reference) {\r\n                try {\r\n                    return getVariable(this.reference);\r\n                }\r\n                catch {\r\n                    return this._value;\r\n                }\r\n            }\r\n        }\r\n        return this._value;\r\n    }\r\n    set value(_value) {\r\n        if (!this.alwaysClean) {\r\n            this.clean = true;\r\n        }\r\n        if (this.reference) {\r\n            _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.globalVariablesObject[this.reference] = _value.toString();\r\n        }\r\n        this._value = _value;\r\n    }\r\n}\r\nfunction getGraphType(expression) {\r\n    const graphId = parseInt(expression.id.split('_')[0], 10);\r\n    let type = null;\r\n    for (let i = 0; i < _constants__WEBPACK_IMPORTED_MODULE_0__.baseExpressionFormat.length; i++) {\r\n        const currExpressionFormat = _constants__WEBPACK_IMPORTED_MODULE_0__.baseExpressionFormat[i];\r\n        const newExpression = currExpressionFormat.replaceAll('_{1', `_{${graphId}`);\r\n        if (expression.latex.includes(newExpression)) {\r\n            type = i;\r\n            break;\r\n        }\r\n    }\r\n    if (type === null) {\r\n        throw new Error('Cannot find conic type');\r\n    }\r\n    else {\r\n        return type;\r\n    }\r\n}\r\nfunction hasXDomain(cropType) {\r\n    return cropType <= 1;\r\n}\r\nfunction hasYDomain(cropType) {\r\n    return !(cropType % 2);\r\n}\r\nfunction getDomains(currId) {\r\n    return {\r\n        xMin: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`x_{${currId}ca}`),\r\n        yMin: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`y_{${currId}ca}`),\r\n        xMax: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`x_{${currId}cb}`),\r\n        yMax: _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`y_{${currId}cb}`),\r\n    };\r\n}\r\nfunction parseDomains(domains) {\r\n    let [xMin, yMin, xMax, yMax] = [-Infinity, -Infinity, Infinity, Infinity];\r\n    for (let i = 0; i < domains.length; i++) {\r\n        const latex = domains[i];\r\n        const split = latex.split('<');\r\n        let variable = '';\r\n        if (split.includes('x')) {\r\n            variable = 'x';\r\n        }\r\n        else if (split.includes('y')) {\r\n            variable = 'y';\r\n        }\r\n        if (variable !== '') {\r\n            if (['x', 'y'].includes(split[0])) { // x < 2\r\n                if (variable === 'x') {\r\n                    xMax = parseFloat(split[1]);\r\n                }\r\n                else if (variable === 'y') {\r\n                    yMax = parseFloat(split[1]);\r\n                }\r\n            }\r\n            else if (['x', 'y'].includes(split[1]) && split.length === 2) { // 2 < x\r\n                if (variable === 'x') {\r\n                    xMin = parseFloat(split[0]);\r\n                }\r\n                else if (variable === 'y') {\r\n                    yMin = parseFloat(split[0]);\r\n                }\r\n            }\r\n            else if (['x', 'y'].includes(split[1]) && split.length === 3) { // 2 < x < 3\r\n                if (variable === 'x') {\r\n                    xMin = parseFloat(split[0]);\r\n                    xMax = parseFloat(split[2]);\r\n                }\r\n                else if (variable === 'y') {\r\n                    yMin = parseFloat(split[0]);\r\n                    yMax = parseFloat(split[2]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { xMin, xMax, yMin, yMax };\r\n}\r\nfunction maxLinkedVariable(linkedVariables) {\r\n    let maxVariable = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, -Infinity);\r\n    linkedVariables.forEach((variable) => {\r\n        maxVariable = variable.value > maxVariable.value ? variable : maxVariable;\r\n    });\r\n    return maxVariable;\r\n}\r\nfunction minLinkedVariable(linkedVariables) {\r\n    let minVariable = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(null, Infinity);\r\n    linkedVariables.forEach((variable) => {\r\n        minVariable = variable.value < minVariable.value ? variable : minVariable;\r\n    });\r\n    return minVariable;\r\n}\r\nfunction minMax(variables) {\r\n    return {\r\n        min: minLinkedVariable(variables),\r\n        max: maxLinkedVariable(variables),\r\n    };\r\n}\r\nfunction simplify(_number, decimalPlaces) {\r\n    return parseFloat(_number.toFixed(decimalPlaces))\r\n        .toString();\r\n}\r\nfunction getVariablesNeeded(latex) {\r\n    return [...latex.matchAll(functionVariableRegex)];\r\n}\r\nfunction substitute(_latex) {\r\n    let latex = _latex;\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    for (let j = 0; j < variablesNeeded.length; j++) {\r\n        const variableNeeded = variablesNeeded[j][0];\r\n        latex = latex.replace(variableNeeded, simplify(getVariable(variableNeeded), 4));\r\n    }\r\n    return latex;\r\n}\r\nfunction generateBounds(_xMin, _yMin, _xMax, _yMax) {\r\n    const xMin = _xMin;\r\n    xMin.value = parseFloat(xMin.value.toFixed(4));\r\n    const yMin = _yMin;\r\n    yMin.value = parseFloat(yMin.value.toFixed(4));\r\n    const xMax = _xMax;\r\n    xMax.value = parseFloat(xMax.value.toFixed(4));\r\n    const yMax = _yMax;\r\n    yMax.value = parseFloat(yMax.value.toFixed(4));\r\n    const xBounds = { value: '', reference: '' };\r\n    const yBounds = { value: '', reference: '' };\r\n    if (xMin.value === -Infinity) {\r\n        if (xMax.value !== Infinity) {\r\n            xBounds.value = `\\\\left\\\\{x<${xMax.value}\\\\right\\\\}`;\r\n            xBounds.reference = `\\\\left\\\\{x<${xMax.reference}\\\\right\\\\}`;\r\n        }\r\n    }\r\n    else if (xMax.value === Infinity) {\r\n        xBounds.value = `\\\\left\\\\{${xMin.value}<x\\\\right\\\\}`;\r\n        xBounds.reference = `\\\\left\\\\{${xMin.reference}<x\\\\right\\\\}`;\r\n    }\r\n    else {\r\n        xBounds.value = `\\\\left\\\\{${xMin.value}<x<${xMax.value}\\\\right\\\\}`;\r\n        xBounds.reference = `\\\\left\\\\{${xMin.reference}<x<${xMax.reference}\\\\right\\\\}`;\r\n    }\r\n    if (yMin.value === -Infinity) {\r\n        if (yMax.value !== Infinity) {\r\n            yBounds.value = `\\\\left\\\\{y<${yMax.value}\\\\right\\\\}`;\r\n            yBounds.reference = `\\\\left\\\\{y<${yMax.reference}\\\\right\\\\}`;\r\n        }\r\n    }\r\n    else if (yMax.value === Infinity) {\r\n        yBounds.value = `\\\\left\\\\{${yMin.value}<y\\\\right\\\\}`;\r\n        yBounds.reference = `\\\\left\\\\{${yMin.reference}<y\\\\right\\\\}`;\r\n    }\r\n    else {\r\n        yBounds.value = `\\\\left\\\\{${yMin.value}<y<${yMax.value}\\\\right\\\\}`;\r\n        yBounds.reference = `\\\\left\\\\{${yMin.reference}<y<${yMax.reference}\\\\right\\\\}`;\r\n    }\r\n    return { value: `${xBounds.value}${yBounds.value}`, reference: `${xBounds.reference}${yBounds.reference}` };\r\n}\r\nfunction usesVariable(latex, _id) {\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    return variablesNeeded.some((variable) => {\r\n        if (variable) {\r\n            const newVariable = [...variable[0].matchAll(/[a-z]_{(\\d+)[a-z]*}/g)][0];\r\n            if (newVariable) {\r\n                return newVariable[1] === _id.toString();\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction substituteFromId(_latex, expressionId) {\r\n    let latex = _latex;\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    for (let j = 0; j < variablesNeeded.length; j++) {\r\n        const variableNeeded = variablesNeeded[j][0];\r\n        if (usesVariable(variableNeeded, expressionId)) {\r\n            const variableValue = simplify(getVariable(variableNeeded), 4);\r\n            latex = latex.replace(variableNeeded, `(${variableValue})`);\r\n        }\r\n    }\r\n    return latex;\r\n}\r\nfunction setVariable(variable, _value) {\r\n    let value = _value;\r\n    if (typeof value === 'number') {\r\n        value = value.toString();\r\n    }\r\n    if (value == undefined) {\r\n        throw Error('undefined bruh what');\r\n    }\r\n    _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.globalVariablesObject[variable] = value;\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/lib.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.user.ts");
/******/ 	
/******/ })()
;