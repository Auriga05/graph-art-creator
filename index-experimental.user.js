// ==UserScript==
// @name         Graph Art Creator - Experimental
// @namespace    http://tampermonkey.net/
// @version      1.0a
// @description  precal thing
// @author       Auriga05
// @match        https://www.desmos.com/calculator*
// @icon         https://www.google.com/s2/favicons?domain=desmos.com
// @grant        unsafeWindow
// @updateURL    https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js
// @downloadURL  https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js
// @require      https://code.jquery.com/jquery-3.5.1.slim.min.js
// @require      https://cdn.jsdelivr.net/npm/evaluatex@2.2.0/dist/evaluatex.min.js
// ==/UserScript==
/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/is-any-array/src/index.js":
/*!************************************************!*\
  !*** ./node_modules/is-any-array/src/index.js ***!
  \************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ isAnyArray)\n/* harmony export */ });\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/is-any-array/src/index.js?");

/***/ }),

/***/ "./node_modules/ml-array-max/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-max/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/src/index.js\");\n\n\nfunction max(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var maxValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (max);\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-array-max/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-array-min/lib-es6/index.js":
/*!****************************************************!*\
  !*** ./node_modules/ml-array-min/lib-es6/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/src/index.js\");\n\n\nfunction min(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var _options$fromIndex = options.fromIndex,\n      fromIndex = _options$fromIndex === void 0 ? 0 : _options$fromIndex,\n      _options$toIndex = options.toIndex,\n      toIndex = _options$toIndex === void 0 ? input.length : _options$toIndex;\n\n  if (fromIndex < 0 || fromIndex >= input.length || !Number.isInteger(fromIndex)) {\n    throw new Error('fromIndex must be a positive integer smaller than length');\n  }\n\n  if (toIndex <= fromIndex || toIndex > input.length || !Number.isInteger(toIndex)) {\n    throw new Error('toIndex must be an integer greater than fromIndex and at most equal to length');\n  }\n\n  var minValue = input[fromIndex];\n\n  for (var i = fromIndex + 1; i < toIndex; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (min);\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-array-min/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-array-rescale/lib-es6/index.js":
/*!********************************************************!*\
  !*** ./node_modules/ml-array-rescale/lib-es6/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ rescale)\n/* harmony export */ });\n/* harmony import */ var is_any_array__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-any-array */ \"./node_modules/is-any-array/src/index.js\");\n/* harmony import */ var ml_array_max__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-array-max */ \"./node_modules/ml-array-max/lib-es6/index.js\");\n/* harmony import */ var ml_array_min__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ml-array-min */ \"./node_modules/ml-array-min/lib-es6/index.js\");\n\n\n\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!(0,is_any_array__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = (0,ml_array_min__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(input);\n  var currentMax = (0,ml_array_max__WEBPACK_IMPORTED_MODULE_1__[\"default\"])(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\n\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-array-rescale/lib-es6/index.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/evd.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/evd.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ EigenvalueDecomposition)\n/* harmony export */ });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../wrap/WrapperMatrix2D */ \"./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/dc/util.js\");\n\n\n\n\n\nclass EigenvalueDecomposition {\n  constructor(matrix, options = {}) {\n    const { assumeSymmetric = false } = options;\n\n    matrix = _wrap_WrapperMatrix2D__WEBPACK_IMPORTED_MODULE_0__[\"default\"].checkMatrix(matrix);\n    if (!matrix.isSquare()) {\n      throw new Error('Matrix is not a square matrix');\n    }\n\n    if (matrix.isEmpty()) {\n      throw new Error('Matrix must be non-empty');\n    }\n\n    let n = matrix.columns;\n    let V = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"](n, n);\n    let d = new Float64Array(n);\n    let e = new Float64Array(n);\n    let value = matrix;\n    let i, j;\n\n    let isSymmetric = false;\n    if (assumeSymmetric) {\n      isSymmetric = true;\n    } else {\n      isSymmetric = matrix.isSymmetric();\n    }\n\n    if (isSymmetric) {\n      for (i = 0; i < n; i++) {\n        for (j = 0; j < n; j++) {\n          V.set(i, j, value.get(i, j));\n        }\n      }\n      tred2(n, e, d, V);\n      tql2(n, e, d, V);\n    } else {\n      let H = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"](n, n);\n      let ort = new Float64Array(n);\n      for (j = 0; j < n; j++) {\n        for (i = 0; i < n; i++) {\n          H.set(i, j, value.get(i, j));\n        }\n      }\n      orthes(n, H, ort, V);\n      hqr2(n, e, d, V, H);\n    }\n\n    this.n = n;\n    this.e = e;\n    this.d = d;\n    this.V = V;\n  }\n\n  get realEigenvalues() {\n    return Array.from(this.d);\n  }\n\n  get imaginaryEigenvalues() {\n    return Array.from(this.e);\n  }\n\n  get eigenvectorMatrix() {\n    return this.V;\n  }\n\n  get diagonalMatrix() {\n    let n = this.n;\n    let e = this.e;\n    let d = this.d;\n    let X = new _matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"](n, n);\n    let i, j;\n    for (i = 0; i < n; i++) {\n      for (j = 0; j < n; j++) {\n        X.set(i, j, 0);\n      }\n      X.set(i, i, d[i]);\n      if (e[i] > 0) {\n        X.set(i, i + 1, e[i]);\n      } else if (e[i] < 0) {\n        X.set(i, i - 1, e[i]);\n      }\n    }\n    return X;\n  }\n}\n\nfunction tred2(n, e, d, V) {\n  let f, g, h, i, j, k, hh, scale;\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n  }\n\n  for (i = n - 1; i > 0; i--) {\n    scale = 0;\n    h = 0;\n    for (k = 0; k < i; k++) {\n      scale = scale + Math.abs(d[k]);\n    }\n\n    if (scale === 0) {\n      e[i] = d[i - 1];\n      for (j = 0; j < i; j++) {\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n        V.set(j, i, 0);\n      }\n    } else {\n      for (k = 0; k < i; k++) {\n        d[k] /= scale;\n        h += d[k] * d[k];\n      }\n\n      f = d[i - 1];\n      g = Math.sqrt(h);\n      if (f > 0) {\n        g = -g;\n      }\n\n      e[i] = scale * g;\n      h = h - f * g;\n      d[i - 1] = f - g;\n      for (j = 0; j < i; j++) {\n        e[j] = 0;\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        V.set(j, i, f);\n        g = e[j] + V.get(j, j) * f;\n        for (k = j + 1; k <= i - 1; k++) {\n          g += V.get(k, j) * d[k];\n          e[k] += V.get(k, j) * f;\n        }\n        e[j] = g;\n      }\n\n      f = 0;\n      for (j = 0; j < i; j++) {\n        e[j] /= h;\n        f += e[j] * d[j];\n      }\n\n      hh = f / (h + h);\n      for (j = 0; j < i; j++) {\n        e[j] -= hh * d[j];\n      }\n\n      for (j = 0; j < i; j++) {\n        f = d[j];\n        g = e[j];\n        for (k = j; k <= i - 1; k++) {\n          V.set(k, j, V.get(k, j) - (f * e[k] + g * d[k]));\n        }\n        d[j] = V.get(i - 1, j);\n        V.set(i, j, 0);\n      }\n    }\n    d[i] = h;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    V.set(n - 1, i, V.get(i, i));\n    V.set(i, i, 1);\n    h = d[i + 1];\n    if (h !== 0) {\n      for (k = 0; k <= i; k++) {\n        d[k] = V.get(k, i + 1) / h;\n      }\n\n      for (j = 0; j <= i; j++) {\n        g = 0;\n        for (k = 0; k <= i; k++) {\n          g += V.get(k, i + 1) * V.get(k, j);\n        }\n        for (k = 0; k <= i; k++) {\n          V.set(k, j, V.get(k, j) - g * d[k]);\n        }\n      }\n    }\n\n    for (k = 0; k <= i; k++) {\n      V.set(k, i + 1, 0);\n    }\n  }\n\n  for (j = 0; j < n; j++) {\n    d[j] = V.get(n - 1, j);\n    V.set(n - 1, j, 0);\n  }\n\n  V.set(n - 1, n - 1, 1);\n  e[0] = 0;\n}\n\nfunction tql2(n, e, d, V) {\n  let g, h, i, j, k, l, m, p, r, dl1, c, c2, c3, el1, s, s2, iter;\n\n  for (i = 1; i < n; i++) {\n    e[i - 1] = e[i];\n  }\n\n  e[n - 1] = 0;\n\n  let f = 0;\n  let tst1 = 0;\n  let eps = Number.EPSILON;\n\n  for (l = 0; l < n; l++) {\n    tst1 = Math.max(tst1, Math.abs(d[l]) + Math.abs(e[l]));\n    m = l;\n    while (m < n) {\n      if (Math.abs(e[m]) <= eps * tst1) {\n        break;\n      }\n      m++;\n    }\n\n    if (m > l) {\n      iter = 0;\n      do {\n        iter = iter + 1;\n\n        g = d[l];\n        p = (d[l + 1] - g) / (2 * e[l]);\n        r = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(p, 1);\n        if (p < 0) {\n          r = -r;\n        }\n\n        d[l] = e[l] / (p + r);\n        d[l + 1] = e[l] * (p + r);\n        dl1 = d[l + 1];\n        h = g - d[l];\n        for (i = l + 2; i < n; i++) {\n          d[i] -= h;\n        }\n\n        f = f + h;\n\n        p = d[m];\n        c = 1;\n        c2 = c;\n        c3 = c;\n        el1 = e[l + 1];\n        s = 0;\n        s2 = 0;\n        for (i = m - 1; i >= l; i--) {\n          c3 = c2;\n          c2 = c;\n          s2 = s;\n          g = c * e[i];\n          h = c * p;\n          r = (0,_util__WEBPACK_IMPORTED_MODULE_2__.hypotenuse)(p, e[i]);\n          e[i + 1] = s * r;\n          s = e[i] / r;\n          c = p / r;\n          p = c * d[i] - s * g;\n          d[i + 1] = h + s * (c * g + s * d[i]);\n\n          for (k = 0; k < n; k++) {\n            h = V.get(k, i + 1);\n            V.set(k, i + 1, s * V.get(k, i) + c * h);\n            V.set(k, i, c * V.get(k, i) - s * h);\n          }\n        }\n\n        p = (-s * s2 * c3 * el1 * e[l]) / dl1;\n        e[l] = s * p;\n        d[l] = c * p;\n      } while (Math.abs(e[l]) > eps * tst1);\n    }\n    d[l] = d[l] + f;\n    e[l] = 0;\n  }\n\n  for (i = 0; i < n - 1; i++) {\n    k = i;\n    p = d[i];\n    for (j = i + 1; j < n; j++) {\n      if (d[j] < p) {\n        k = j;\n        p = d[j];\n      }\n    }\n\n    if (k !== i) {\n      d[k] = d[i];\n      d[i] = p;\n      for (j = 0; j < n; j++) {\n        p = V.get(j, i);\n        V.set(j, i, V.get(j, k));\n        V.set(j, k, p);\n      }\n    }\n  }\n}\n\nfunction orthes(n, H, ort, V) {\n  let low = 0;\n  let high = n - 1;\n  let f, g, h, i, j, m;\n  let scale;\n\n  for (m = low + 1; m <= high - 1; m++) {\n    scale = 0;\n    for (i = m; i <= high; i++) {\n      scale = scale + Math.abs(H.get(i, m - 1));\n    }\n\n    if (scale !== 0) {\n      h = 0;\n      for (i = high; i >= m; i--) {\n        ort[i] = H.get(i, m - 1) / scale;\n        h += ort[i] * ort[i];\n      }\n\n      g = Math.sqrt(h);\n      if (ort[m] > 0) {\n        g = -g;\n      }\n\n      h = h - ort[m] * g;\n      ort[m] = ort[m] - g;\n\n      for (j = m; j < n; j++) {\n        f = 0;\n        for (i = high; i >= m; i--) {\n          f += ort[i] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (i = m; i <= high; i++) {\n          H.set(i, j, H.get(i, j) - f * ort[i]);\n        }\n      }\n\n      for (i = 0; i <= high; i++) {\n        f = 0;\n        for (j = high; j >= m; j--) {\n          f += ort[j] * H.get(i, j);\n        }\n\n        f = f / h;\n        for (j = m; j <= high; j++) {\n          H.set(i, j, H.get(i, j) - f * ort[j]);\n        }\n      }\n\n      ort[m] = scale * ort[m];\n      H.set(m, m - 1, scale * g);\n    }\n  }\n\n  for (i = 0; i < n; i++) {\n    for (j = 0; j < n; j++) {\n      V.set(i, j, i === j ? 1 : 0);\n    }\n  }\n\n  for (m = high - 1; m >= low + 1; m--) {\n    if (H.get(m, m - 1) !== 0) {\n      for (i = m + 1; i <= high; i++) {\n        ort[i] = H.get(i, m - 1);\n      }\n\n      for (j = m; j <= high; j++) {\n        g = 0;\n        for (i = m; i <= high; i++) {\n          g += ort[i] * V.get(i, j);\n        }\n\n        g = g / ort[m] / H.get(m, m - 1);\n        for (i = m; i <= high; i++) {\n          V.set(i, j, V.get(i, j) + g * ort[i]);\n        }\n      }\n    }\n  }\n}\n\nfunction hqr2(nn, e, d, V, H) {\n  let n = nn - 1;\n  let low = 0;\n  let high = nn - 1;\n  let eps = Number.EPSILON;\n  let exshift = 0;\n  let norm = 0;\n  let p = 0;\n  let q = 0;\n  let r = 0;\n  let s = 0;\n  let z = 0;\n  let iter = 0;\n  let i, j, k, l, m, t, w, x, y;\n  let ra, sa, vr, vi;\n  let notlast, cdivres;\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      d[i] = H.get(i, i);\n      e[i] = 0;\n    }\n\n    for (j = Math.max(i - 1, 0); j < nn; j++) {\n      norm = norm + Math.abs(H.get(i, j));\n    }\n  }\n\n  while (n >= low) {\n    l = n;\n    while (l > low) {\n      s = Math.abs(H.get(l - 1, l - 1)) + Math.abs(H.get(l, l));\n      if (s === 0) {\n        s = norm;\n      }\n      if (Math.abs(H.get(l, l - 1)) < eps * s) {\n        break;\n      }\n      l--;\n    }\n\n    if (l === n) {\n      H.set(n, n, H.get(n, n) + exshift);\n      d[n] = H.get(n, n);\n      e[n] = 0;\n      n--;\n      iter = 0;\n    } else if (l === n - 1) {\n      w = H.get(n, n - 1) * H.get(n - 1, n);\n      p = (H.get(n - 1, n - 1) - H.get(n, n)) / 2;\n      q = p * p + w;\n      z = Math.sqrt(Math.abs(q));\n      H.set(n, n, H.get(n, n) + exshift);\n      H.set(n - 1, n - 1, H.get(n - 1, n - 1) + exshift);\n      x = H.get(n, n);\n\n      if (q >= 0) {\n        z = p >= 0 ? p + z : p - z;\n        d[n - 1] = x + z;\n        d[n] = d[n - 1];\n        if (z !== 0) {\n          d[n] = x - w / z;\n        }\n        e[n - 1] = 0;\n        e[n] = 0;\n        x = H.get(n, n - 1);\n        s = Math.abs(x) + Math.abs(z);\n        p = x / s;\n        q = z / s;\n        r = Math.sqrt(p * p + q * q);\n        p = p / r;\n        q = q / r;\n\n        for (j = n - 1; j < nn; j++) {\n          z = H.get(n - 1, j);\n          H.set(n - 1, j, q * z + p * H.get(n, j));\n          H.set(n, j, q * H.get(n, j) - p * z);\n        }\n\n        for (i = 0; i <= n; i++) {\n          z = H.get(i, n - 1);\n          H.set(i, n - 1, q * z + p * H.get(i, n));\n          H.set(i, n, q * H.get(i, n) - p * z);\n        }\n\n        for (i = low; i <= high; i++) {\n          z = V.get(i, n - 1);\n          V.set(i, n - 1, q * z + p * V.get(i, n));\n          V.set(i, n, q * V.get(i, n) - p * z);\n        }\n      } else {\n        d[n - 1] = x + p;\n        d[n] = x + p;\n        e[n - 1] = z;\n        e[n] = -z;\n      }\n\n      n = n - 2;\n      iter = 0;\n    } else {\n      x = H.get(n, n);\n      y = 0;\n      w = 0;\n      if (l < n) {\n        y = H.get(n - 1, n - 1);\n        w = H.get(n, n - 1) * H.get(n - 1, n);\n      }\n\n      if (iter === 10) {\n        exshift += x;\n        for (i = low; i <= n; i++) {\n          H.set(i, i, H.get(i, i) - x);\n        }\n        s = Math.abs(H.get(n, n - 1)) + Math.abs(H.get(n - 1, n - 2));\n        x = y = 0.75 * s;\n        w = -0.4375 * s * s;\n      }\n\n      if (iter === 30) {\n        s = (y - x) / 2;\n        s = s * s + w;\n        if (s > 0) {\n          s = Math.sqrt(s);\n          if (y < x) {\n            s = -s;\n          }\n          s = x - w / ((y - x) / 2 + s);\n          for (i = low; i <= n; i++) {\n            H.set(i, i, H.get(i, i) - s);\n          }\n          exshift += s;\n          x = y = w = 0.964;\n        }\n      }\n\n      iter = iter + 1;\n\n      m = n - 2;\n      while (m >= l) {\n        z = H.get(m, m);\n        r = x - z;\n        s = y - z;\n        p = (r * s - w) / H.get(m + 1, m) + H.get(m, m + 1);\n        q = H.get(m + 1, m + 1) - z - r - s;\n        r = H.get(m + 2, m + 1);\n        s = Math.abs(p) + Math.abs(q) + Math.abs(r);\n        p = p / s;\n        q = q / s;\n        r = r / s;\n        if (m === l) {\n          break;\n        }\n        if (\n          Math.abs(H.get(m, m - 1)) * (Math.abs(q) + Math.abs(r)) <\n          eps *\n            (Math.abs(p) *\n              (Math.abs(H.get(m - 1, m - 1)) +\n                Math.abs(z) +\n                Math.abs(H.get(m + 1, m + 1))))\n        ) {\n          break;\n        }\n        m--;\n      }\n\n      for (i = m + 2; i <= n; i++) {\n        H.set(i, i - 2, 0);\n        if (i > m + 2) {\n          H.set(i, i - 3, 0);\n        }\n      }\n\n      for (k = m; k <= n - 1; k++) {\n        notlast = k !== n - 1;\n        if (k !== m) {\n          p = H.get(k, k - 1);\n          q = H.get(k + 1, k - 1);\n          r = notlast ? H.get(k + 2, k - 1) : 0;\n          x = Math.abs(p) + Math.abs(q) + Math.abs(r);\n          if (x !== 0) {\n            p = p / x;\n            q = q / x;\n            r = r / x;\n          }\n        }\n\n        if (x === 0) {\n          break;\n        }\n\n        s = Math.sqrt(p * p + q * q + r * r);\n        if (p < 0) {\n          s = -s;\n        }\n\n        if (s !== 0) {\n          if (k !== m) {\n            H.set(k, k - 1, -s * x);\n          } else if (l !== m) {\n            H.set(k, k - 1, -H.get(k, k - 1));\n          }\n\n          p = p + s;\n          x = p / s;\n          y = q / s;\n          z = r / s;\n          q = q / p;\n          r = r / p;\n\n          for (j = k; j < nn; j++) {\n            p = H.get(k, j) + q * H.get(k + 1, j);\n            if (notlast) {\n              p = p + r * H.get(k + 2, j);\n              H.set(k + 2, j, H.get(k + 2, j) - p * z);\n            }\n\n            H.set(k, j, H.get(k, j) - p * x);\n            H.set(k + 1, j, H.get(k + 1, j) - p * y);\n          }\n\n          for (i = 0; i <= Math.min(n, k + 3); i++) {\n            p = x * H.get(i, k) + y * H.get(i, k + 1);\n            if (notlast) {\n              p = p + z * H.get(i, k + 2);\n              H.set(i, k + 2, H.get(i, k + 2) - p * r);\n            }\n\n            H.set(i, k, H.get(i, k) - p);\n            H.set(i, k + 1, H.get(i, k + 1) - p * q);\n          }\n\n          for (i = low; i <= high; i++) {\n            p = x * V.get(i, k) + y * V.get(i, k + 1);\n            if (notlast) {\n              p = p + z * V.get(i, k + 2);\n              V.set(i, k + 2, V.get(i, k + 2) - p * r);\n            }\n\n            V.set(i, k, V.get(i, k) - p);\n            V.set(i, k + 1, V.get(i, k + 1) - p * q);\n          }\n        }\n      }\n    }\n  }\n\n  if (norm === 0) {\n    return;\n  }\n\n  for (n = nn - 1; n >= 0; n--) {\n    p = d[n];\n    q = e[n];\n\n    if (q === 0) {\n      l = n;\n      H.set(n, n, 1);\n      for (i = n - 1; i >= 0; i--) {\n        w = H.get(i, i) - p;\n        r = 0;\n        for (j = l; j <= n; j++) {\n          r = r + H.get(i, j) * H.get(j, n);\n        }\n\n        if (e[i] < 0) {\n          z = w;\n          s = r;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            H.set(i, n, w !== 0 ? -r / w : -r / (eps * norm));\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            q = (d[i] - p) * (d[i] - p) + e[i] * e[i];\n            t = (x * s - z * r) / q;\n            H.set(i, n, t);\n            H.set(\n              i + 1,\n              n,\n              Math.abs(x) > Math.abs(z) ? (-r - w * t) / x : (-s - y * t) / z,\n            );\n          }\n\n          t = Math.abs(H.get(i, n));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    } else if (q < 0) {\n      l = n - 1;\n\n      if (Math.abs(H.get(n, n - 1)) > Math.abs(H.get(n - 1, n))) {\n        H.set(n - 1, n - 1, q / H.get(n, n - 1));\n        H.set(n - 1, n, -(H.get(n, n) - p) / H.get(n, n - 1));\n      } else {\n        cdivres = cdiv(0, -H.get(n - 1, n), H.get(n - 1, n - 1) - p, q);\n        H.set(n - 1, n - 1, cdivres[0]);\n        H.set(n - 1, n, cdivres[1]);\n      }\n\n      H.set(n, n - 1, 0);\n      H.set(n, n, 1);\n      for (i = n - 2; i >= 0; i--) {\n        ra = 0;\n        sa = 0;\n        for (j = l; j <= n; j++) {\n          ra = ra + H.get(i, j) * H.get(j, n - 1);\n          sa = sa + H.get(i, j) * H.get(j, n);\n        }\n\n        w = H.get(i, i) - p;\n\n        if (e[i] < 0) {\n          z = w;\n          r = ra;\n          s = sa;\n        } else {\n          l = i;\n          if (e[i] === 0) {\n            cdivres = cdiv(-ra, -sa, w, q);\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n          } else {\n            x = H.get(i, i + 1);\n            y = H.get(i + 1, i);\n            vr = (d[i] - p) * (d[i] - p) + e[i] * e[i] - q * q;\n            vi = (d[i] - p) * 2 * q;\n            if (vr === 0 && vi === 0) {\n              vr =\n                eps *\n                norm *\n                (Math.abs(w) +\n                  Math.abs(q) +\n                  Math.abs(x) +\n                  Math.abs(y) +\n                  Math.abs(z));\n            }\n            cdivres = cdiv(\n              x * r - z * ra + q * sa,\n              x * s - z * sa - q * ra,\n              vr,\n              vi,\n            );\n            H.set(i, n - 1, cdivres[0]);\n            H.set(i, n, cdivres[1]);\n            if (Math.abs(x) > Math.abs(z) + Math.abs(q)) {\n              H.set(\n                i + 1,\n                n - 1,\n                (-ra - w * H.get(i, n - 1) + q * H.get(i, n)) / x,\n              );\n              H.set(\n                i + 1,\n                n,\n                (-sa - w * H.get(i, n) - q * H.get(i, n - 1)) / x,\n              );\n            } else {\n              cdivres = cdiv(\n                -r - y * H.get(i, n - 1),\n                -s - y * H.get(i, n),\n                z,\n                q,\n              );\n              H.set(i + 1, n - 1, cdivres[0]);\n              H.set(i + 1, n, cdivres[1]);\n            }\n          }\n\n          t = Math.max(Math.abs(H.get(i, n - 1)), Math.abs(H.get(i, n)));\n          if (eps * t * t > 1) {\n            for (j = i; j <= n; j++) {\n              H.set(j, n - 1, H.get(j, n - 1) / t);\n              H.set(j, n, H.get(j, n) / t);\n            }\n          }\n        }\n      }\n    }\n  }\n\n  for (i = 0; i < nn; i++) {\n    if (i < low || i > high) {\n      for (j = i; j < nn; j++) {\n        V.set(i, j, H.get(i, j));\n      }\n    }\n  }\n\n  for (j = nn - 1; j >= low; j--) {\n    for (i = low; i <= high; i++) {\n      z = 0;\n      for (k = low; k <= Math.min(j, high); k++) {\n        z = z + V.get(i, k) * H.get(k, j);\n      }\n      V.set(i, j, z);\n    }\n  }\n}\n\nfunction cdiv(xr, xi, yr, yi) {\n  let r, d;\n  if (Math.abs(yr) > Math.abs(yi)) {\n    r = yi / yr;\n    d = yr + r * yi;\n    return [(xr + r * xi) / d, (xi - r * xr) / d];\n  } else {\n    r = yr / yi;\n    d = yi + r * yr;\n    return [(r * xr + xi) / d, (r * xi - xr) / d];\n  }\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/dc/evd.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/dc/util.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/dc/util.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hypotenuse\": () => (/* binding */ hypotenuse)\n/* harmony export */ });\nfunction hypotenuse(a, b) {\n  let r = 0;\n  if (Math.abs(a) > Math.abs(b)) {\n    r = b / a;\n    return Math.abs(a) * Math.sqrt(1 + r * r);\n  }\n  if (b !== 0) {\n    r = a / b;\n    return Math.abs(b) * Math.sqrt(1 + r * r);\n  }\n  return 0;\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/dc/util.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/inspect.js":
/*!***********************************************!*\
  !*** ./node_modules/ml-matrix/src/inspect.js ***!
  \***********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"inspectMatrix\": () => (/* binding */ inspectMatrix),\n/* harmony export */   \"inspectMatrixWithOptions\": () => (/* binding */ inspectMatrixWithOptions)\n/* harmony export */ });\nconst indent = ' '.repeat(2);\nconst indentData = ' '.repeat(4);\n\nfunction inspectMatrix() {\n  return inspectMatrixWithOptions(this);\n}\n\nfunction inspectMatrixWithOptions(matrix, options = {}) {\n  const { maxRows = 15, maxColumns = 10, maxNumSize = 8 } = options;\n  return `${matrix.constructor.name} {\n${indent}[\n${indentData}${inspectData(matrix, maxRows, maxColumns, maxNumSize)}\n${indent}]\n${indent}rows: ${matrix.rows}\n${indent}columns: ${matrix.columns}\n}`;\n}\n\nfunction inspectData(matrix, maxRows, maxColumns, maxNumSize) {\n  const { rows, columns } = matrix;\n  const maxI = Math.min(rows, maxRows);\n  const maxJ = Math.min(columns, maxColumns);\n  const result = [];\n  for (let i = 0; i < maxI; i++) {\n    let line = [];\n    for (let j = 0; j < maxJ; j++) {\n      line.push(formatNumber(matrix.get(i, j), maxNumSize));\n    }\n    result.push(`${line.join(' ')}`);\n  }\n  if (maxJ !== columns) {\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\n  }\n  if (maxI !== rows) {\n    result.push(`... ${rows - maxRows} more rows`);\n  }\n  return result.join(`\\n${indentData}`);\n}\n\nfunction formatNumber(num, maxNumSize) {\n  const numStr = String(num);\n  if (numStr.length <= maxNumSize) {\n    return numStr.padEnd(maxNumSize, ' ');\n  }\n  const precise = num.toPrecision(maxNumSize - 2);\n  if (precise.length <= maxNumSize) {\n    return precise;\n  }\n  const exponential = num.toExponential(maxNumSize - 2);\n  const eIndex = exponential.indexOf('e');\n  const e = exponential.slice(eIndex);\n  return exponential.slice(0, maxNumSize - e.length) + e;\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/inspect.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/mathOperations.js":
/*!******************************************************!*\
  !*** ./node_modules/ml-matrix/src/mathOperations.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"installMathOperations\": () => (/* binding */ installMathOperations)\n/* harmony export */ });\nfunction installMathOperations(AbstractMatrix, Matrix) {\n  AbstractMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number') return this.addS(value);\n    return this.addM(value);\n  };\n\n  AbstractMatrix.prototype.addS = function addS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.addM = function addM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.add = function add(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.add(value);\n  };\n\n  AbstractMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number') return this.subS(value);\n    return this.subM(value);\n  };\n\n  AbstractMatrix.prototype.subS = function subS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.subM = function subM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sub = function sub(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sub(value);\n  };\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\n  AbstractMatrix.subtract = AbstractMatrix.sub;\n\n  AbstractMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number') return this.mulS(value);\n    return this.mulM(value);\n  };\n\n  AbstractMatrix.prototype.mulS = function mulS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mul = function mul(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mul(value);\n  };\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\n  AbstractMatrix.multiply = AbstractMatrix.mul;\n\n  AbstractMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number') return this.divS(value);\n    return this.divM(value);\n  };\n\n  AbstractMatrix.prototype.divS = function divS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.divM = function divM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.div = function div(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.div(value);\n  };\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\n  AbstractMatrix.divide = AbstractMatrix.div;\n\n  AbstractMatrix.prototype.mod = function mod(value) {\n    if (typeof value === 'number') return this.modS(value);\n    return this.modM(value);\n  };\n\n  AbstractMatrix.prototype.modS = function modS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.modM = function modM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mod = function mod(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mod(value);\n  };\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\n  AbstractMatrix.modulus = AbstractMatrix.mod;\n\n  AbstractMatrix.prototype.and = function and(value) {\n    if (typeof value === 'number') return this.andS(value);\n    return this.andM(value);\n  };\n\n  AbstractMatrix.prototype.andS = function andS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.andM = function andM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.and = function and(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.and(value);\n  };\n\n  AbstractMatrix.prototype.or = function or(value) {\n    if (typeof value === 'number') return this.orS(value);\n    return this.orM(value);\n  };\n\n  AbstractMatrix.prototype.orS = function orS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.orM = function orM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.or = function or(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.or(value);\n  };\n\n  AbstractMatrix.prototype.xor = function xor(value) {\n    if (typeof value === 'number') return this.xorS(value);\n    return this.xorM(value);\n  };\n\n  AbstractMatrix.prototype.xorS = function xorS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.xor = function xor(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.xor(value);\n  };\n\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\n    if (typeof value === 'number') return this.leftShiftS(value);\n    return this.leftShiftM(value);\n  };\n\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.leftShift(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\n    return this.signPropagatingRightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.signPropagatingRightShift(value);\n  };\n\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\n    if (typeof value === 'number') return this.rightShiftS(value);\n    return this.rightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.rightShift(value);\n  };\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\n\n  AbstractMatrix.prototype.not = function not() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, ~(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.not = function not(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.not();\n  };\n\n  AbstractMatrix.prototype.abs = function abs() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.abs(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.abs = function abs(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.abs();\n  };\n\n  AbstractMatrix.prototype.acos = function acos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acos = function acos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acos();\n  };\n\n  AbstractMatrix.prototype.acosh = function acosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acosh = function acosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acosh();\n  };\n\n  AbstractMatrix.prototype.asin = function asin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asin = function asin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asin();\n  };\n\n  AbstractMatrix.prototype.asinh = function asinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asinh = function asinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asinh();\n  };\n\n  AbstractMatrix.prototype.atan = function atan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atan = function atan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atan();\n  };\n\n  AbstractMatrix.prototype.atanh = function atanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atanh = function atanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atanh();\n  };\n\n  AbstractMatrix.prototype.cbrt = function cbrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cbrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cbrt = function cbrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cbrt();\n  };\n\n  AbstractMatrix.prototype.ceil = function ceil() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.ceil(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.ceil = function ceil(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.ceil();\n  };\n\n  AbstractMatrix.prototype.clz32 = function clz32() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.clz32(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.clz32 = function clz32(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.clz32();\n  };\n\n  AbstractMatrix.prototype.cos = function cos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cos = function cos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cos();\n  };\n\n  AbstractMatrix.prototype.cosh = function cosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cosh = function cosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cosh();\n  };\n\n  AbstractMatrix.prototype.exp = function exp() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.exp(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.exp = function exp(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.exp();\n  };\n\n  AbstractMatrix.prototype.expm1 = function expm1() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.expm1(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.expm1 = function expm1(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.expm1();\n  };\n\n  AbstractMatrix.prototype.floor = function floor() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.floor(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.floor = function floor(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.floor();\n  };\n\n  AbstractMatrix.prototype.fround = function fround() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.fround(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.fround = function fround(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.fround();\n  };\n\n  AbstractMatrix.prototype.log = function log() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log = function log(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log();\n  };\n\n  AbstractMatrix.prototype.log1p = function log1p() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log1p(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log1p = function log1p(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log1p();\n  };\n\n  AbstractMatrix.prototype.log10 = function log10() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log10(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log10 = function log10(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log10();\n  };\n\n  AbstractMatrix.prototype.log2 = function log2() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log2(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log2 = function log2(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log2();\n  };\n\n  AbstractMatrix.prototype.round = function round() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.round(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.round = function round(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.round();\n  };\n\n  AbstractMatrix.prototype.sign = function sign() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sign(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sign = function sign(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sign();\n  };\n\n  AbstractMatrix.prototype.sin = function sin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sin = function sin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sin();\n  };\n\n  AbstractMatrix.prototype.sinh = function sinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sinh = function sinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sinh();\n  };\n\n  AbstractMatrix.prototype.sqrt = function sqrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sqrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sqrt = function sqrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sqrt();\n  };\n\n  AbstractMatrix.prototype.tan = function tan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tan = function tan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tan();\n  };\n\n  AbstractMatrix.prototype.tanh = function tanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tanh = function tanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tanh();\n  };\n\n  AbstractMatrix.prototype.trunc = function trunc() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.trunc(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.trunc = function trunc(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.trunc();\n  };\n\n  AbstractMatrix.pow = function pow(matrix, arg0) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.pow(arg0);\n  };\n\n  AbstractMatrix.prototype.pow = function pow(value) {\n    if (typeof value === 'number') return this.powS(value);\n    return this.powM(value);\n  };\n\n  AbstractMatrix.prototype.powS = function powS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), value));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.powM = function powM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));\n      }\n    }\n    return this;\n  };\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/mathOperations.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/matrix.js":
/*!**********************************************!*\
  !*** ./node_modules/ml-matrix/src/matrix.js ***!
  \**********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"AbstractMatrix\": () => (/* binding */ AbstractMatrix),\n/* harmony export */   \"default\": () => (/* binding */ Matrix)\n/* harmony export */ });\n/* harmony import */ var ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-array-rescale */ \"./node_modules/ml-array-rescale/lib-es6/index.js\");\n/* harmony import */ var _inspect__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./inspect */ \"./node_modules/ml-matrix/src/inspect.js\");\n/* harmony import */ var _mathOperations__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./mathOperations */ \"./node_modules/ml-matrix/src/mathOperations.js\");\n/* harmony import */ var _stat__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./stat */ \"./node_modules/ml-matrix/src/stat.js\");\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/util.js\");\n\n\n\n\n\n\n\nclass AbstractMatrix {\n  static from1DArray(newRows, newColumns, newData) {\n    let length = newRows * newColumns;\n    if (length !== newData.length) {\n      throw new RangeError('data length does not match given dimensions');\n    }\n    let newMatrix = new Matrix(newRows, newColumns);\n    for (let row = 0; row < newRows; row++) {\n      for (let column = 0; column < newColumns; column++) {\n        newMatrix.set(row, column, newData[row * newColumns + column]);\n      }\n    }\n    return newMatrix;\n  }\n\n  static rowVector(newData) {\n    let vector = new Matrix(1, newData.length);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(0, i, newData[i]);\n    }\n    return vector;\n  }\n\n  static columnVector(newData) {\n    let vector = new Matrix(newData.length, 1);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(i, 0, newData[i]);\n    }\n    return vector;\n  }\n\n  static zeros(rows, columns) {\n    return new Matrix(rows, columns);\n  }\n\n  static ones(rows, columns) {\n    return new Matrix(rows, columns).fill(1);\n  }\n\n  static rand(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { random = Math.random } = options;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.set(i, j, random());\n      }\n    }\n    return matrix;\n  }\n\n  static randInt(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1000, random = Math.random } = options;\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let interval = max - min;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        let value = min + Math.round(random() * interval);\n        matrix.set(i, j, value);\n      }\n    }\n    return matrix;\n  }\n\n  static eye(rows, columns, value) {\n    if (columns === undefined) columns = rows;\n    if (value === undefined) value = 1;\n    let min = Math.min(rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, value);\n    }\n    return matrix;\n  }\n\n  static diag(data, rows, columns) {\n    let l = data.length;\n    if (rows === undefined) rows = l;\n    if (columns === undefined) columns = rows;\n    let min = Math.min(l, rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, data[i]);\n    }\n    return matrix;\n  }\n\n  static min(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static max(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new this(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static checkMatrix(value) {\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\n  }\n\n  static isMatrix(value) {\n    return value != null && value.klass === 'Matrix';\n  }\n\n  get size() {\n    return this.rows * this.columns;\n  }\n\n  apply(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        callback.call(this, i, j);\n      }\n    }\n    return this;\n  }\n\n  to1DArray() {\n    let array = [];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        array.push(this.get(i, j));\n      }\n    }\n    return array;\n  }\n\n  to2DArray() {\n    let copy = [];\n    for (let i = 0; i < this.rows; i++) {\n      copy.push([]);\n      for (let j = 0; j < this.columns; j++) {\n        copy[i].push(this.get(i, j));\n      }\n    }\n    return copy;\n  }\n\n  toJSON() {\n    return this.to2DArray();\n  }\n\n  isRowVector() {\n    return this.rows === 1;\n  }\n\n  isColumnVector() {\n    return this.columns === 1;\n  }\n\n  isVector() {\n    return this.rows === 1 || this.columns === 1;\n  }\n\n  isSquare() {\n    return this.rows === this.columns;\n  }\n\n  isEmpty() {\n    return this.rows === 0 || this.columns === 0;\n  }\n\n  isSymmetric() {\n    if (this.isSquare()) {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          if (this.get(i, j) !== this.get(j, i)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isEchelonForm = false;\n          checked = true;\n        }\n      }\n      i++;\n    }\n    return isEchelonForm;\n  }\n\n  isReducedEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isReducedEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isReducedEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isReducedEchelonForm = false;\n          checked = true;\n        }\n      }\n      for (let k = j + 1; k < this.rows; k++) {\n        if (this.get(i, k) !== 0) {\n          isReducedEchelonForm = false;\n        }\n      }\n      i++;\n    }\n    return isReducedEchelonForm;\n  }\n\n  echelonForm() {\n    let result = this.clone();\n    let h = 0;\n    let k = 0;\n    while (h < result.rows && k < result.columns) {\n      let iMax = h;\n      for (let i = h; i < result.rows; i++) {\n        if (result.get(i, k) > result.get(iMax, k)) {\n          iMax = i;\n        }\n      }\n      if (result.get(iMax, k) === 0) {\n        k++;\n      } else {\n        result.swapRows(h, iMax);\n        let tmp = result.get(h, k);\n        for (let j = k; j < result.columns; j++) {\n          result.set(h, j, result.get(h, j) / tmp);\n        }\n        for (let i = h + 1; i < result.rows; i++) {\n          let factor = result.get(i, k) / result.get(h, k);\n          result.set(i, k, 0);\n          for (let j = k + 1; j < result.columns; j++) {\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\n          }\n        }\n        h++;\n        k++;\n      }\n    }\n    return result;\n  }\n\n  reducedEchelonForm() {\n    let result = this.echelonForm();\n    let m = result.columns;\n    let n = result.rows;\n    let h = n - 1;\n    while (h >= 0) {\n      if (result.maxRow(h) === 0) {\n        h--;\n      } else {\n        let p = 0;\n        let pivot = false;\n        while (p < n && pivot === false) {\n          if (result.get(h, p) === 1) {\n            pivot = true;\n          } else {\n            p++;\n          }\n        }\n        for (let i = 0; i < h; i++) {\n          let factor = result.get(i, p);\n          for (let j = p; j < m; j++) {\n            let tmp = result.get(i, j) - factor * result.get(h, j);\n            result.set(i, j, tmp);\n          }\n        }\n        h--;\n      }\n    }\n    return result;\n  }\n\n  set() {\n    throw new Error('set method is unimplemented');\n  }\n\n  get() {\n    throw new Error('get method is unimplemented');\n  }\n\n  repeat(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { rows = 1, columns = 1 } = options;\n    if (!Number.isInteger(rows) || rows <= 0) {\n      throw new TypeError('rows must be a positive integer');\n    }\n    if (!Number.isInteger(columns) || columns <= 0) {\n      throw new TypeError('columns must be a positive integer');\n    }\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n      }\n    }\n    return matrix;\n  }\n\n  fill(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, value);\n      }\n    }\n    return this;\n  }\n\n  neg() {\n    return this.mulS(-1);\n  }\n\n  getRow(index) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);\n    let row = [];\n    for (let i = 0; i < this.columns; i++) {\n      row.push(this.get(index, i));\n    }\n    return row;\n  }\n\n  getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n  }\n\n  setRow(index, array) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);\n    array = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, array);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, array[i]);\n    }\n    return this;\n  }\n\n  swapRows(row1, row2) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row1);\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row2);\n    for (let i = 0; i < this.columns; i++) {\n      let temp = this.get(row1, i);\n      this.set(row1, i, this.get(row2, i));\n      this.set(row2, i, temp);\n    }\n    return this;\n  }\n\n  getColumn(index) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);\n    let column = [];\n    for (let i = 0; i < this.rows; i++) {\n      column.push(this.get(i, index));\n    }\n    return column;\n  }\n\n  getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n  }\n\n  setColumn(index, array) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);\n    array = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, array[i]);\n    }\n    return this;\n  }\n\n  swapColumns(column1, column2) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column1);\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column2);\n    for (let i = 0; i < this.rows; i++) {\n      let temp = this.get(i, column1);\n      this.set(i, column1, this.get(i, column2));\n      this.set(i, column2, temp);\n    }\n    return this;\n  }\n\n  addRowVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[j]);\n      }\n    }\n    return this;\n  }\n\n  subRowVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[j]);\n      }\n    }\n    return this;\n  }\n\n  mulRowVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[j]);\n      }\n    }\n    return this;\n  }\n\n  divRowVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[j]);\n      }\n    }\n    return this;\n  }\n\n  addColumnVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[i]);\n      }\n    }\n    return this;\n  }\n\n  subColumnVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulColumnVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[i]);\n      }\n    }\n    return this;\n  }\n\n  divColumnVector(vector) {\n    vector = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulRow(index, value) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, this.get(index, i) * value);\n    }\n    return this;\n  }\n\n  mulColumn(index, value) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, this.get(i, index) * value);\n    }\n    return this;\n  }\n\n  max() {\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  maxIndex() {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkNonEmpty)(this);\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  min() {\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  minIndex() {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkNonEmpty)(this);\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  maxRow(row) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  maxRowIndex(row) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkNonEmpty)(this);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  minRow(row) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  minRowIndex(row) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, row);\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkNonEmpty)(this);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  maxColumn(column) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  maxColumnIndex(column) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkNonEmpty)(this);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  minColumn(column) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);\n    if (this.isEmpty()) {\n      return NaN;\n    }\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  minColumnIndex(column) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, column);\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkNonEmpty)(this);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  diag() {\n    let min = Math.min(this.rows, this.columns);\n    let diag = [];\n    for (let i = 0; i < min; i++) {\n      diag.push(this.get(i, i));\n    }\n    return diag;\n  }\n\n  norm(type = 'frobenius') {\n    let result = 0;\n    if (type === 'max') {\n      return this.max();\n    } else if (type === 'frobenius') {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j < this.columns; j++) {\n          result = result + this.get(i, j) * this.get(i, j);\n        }\n      }\n      return Math.sqrt(result);\n    } else {\n      throw new RangeError(`unknown norm type: ${type}`);\n    }\n  }\n\n  cumulativeSum() {\n    let sum = 0;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        sum += this.get(i, j);\n        this.set(i, j, sum);\n      }\n    }\n    return this;\n  }\n\n  dot(vector2) {\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n    let vector1 = this.to1DArray();\n    if (vector1.length !== vector2.length) {\n      throw new RangeError('vectors do not have the same size');\n    }\n    let dot = 0;\n    for (let i = 0; i < vector1.length; i++) {\n      dot += vector1[i] * vector2[i];\n    }\n    return dot;\n  }\n\n  mmul(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.columns;\n\n    let result = new Matrix(m, p);\n\n    let Bcolj = new Float64Array(n);\n    for (let j = 0; j < p; j++) {\n      for (let k = 0; k < n; k++) {\n        Bcolj[k] = other.get(k, j);\n      }\n\n      for (let i = 0; i < m; i++) {\n        let s = 0;\n        for (let k = 0; k < n; k++) {\n          s += this.get(i, k) * Bcolj[k];\n        }\n\n        result.set(i, j, s);\n      }\n    }\n    return result;\n  }\n\n  strassen2x2(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(2, 2);\n    const a11 = this.get(0, 0);\n    const b11 = other.get(0, 0);\n    const a12 = this.get(0, 1);\n    const b12 = other.get(0, 1);\n    const a21 = this.get(1, 0);\n    const b21 = other.get(1, 0);\n    const a22 = this.get(1, 1);\n    const b22 = other.get(1, 1);\n\n    // Compute intermediate values.\n    const m1 = (a11 + a22) * (b11 + b22);\n    const m2 = (a21 + a22) * b11;\n    const m3 = a11 * (b12 - b22);\n    const m4 = a22 * (b21 - b11);\n    const m5 = (a11 + a12) * b22;\n    const m6 = (a21 - a11) * (b11 + b12);\n    const m7 = (a12 - a22) * (b21 + b22);\n\n    // Combine intermediate values into the output.\n    const c00 = m1 + m4 - m5 + m7;\n    const c01 = m3 + m5;\n    const c10 = m2 + m4;\n    const c11 = m1 - m2 + m3 + m6;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    return result;\n  }\n\n  strassen3x3(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(3, 3);\n\n    const a00 = this.get(0, 0);\n    const a01 = this.get(0, 1);\n    const a02 = this.get(0, 2);\n    const a10 = this.get(1, 0);\n    const a11 = this.get(1, 1);\n    const a12 = this.get(1, 2);\n    const a20 = this.get(2, 0);\n    const a21 = this.get(2, 1);\n    const a22 = this.get(2, 2);\n\n    const b00 = other.get(0, 0);\n    const b01 = other.get(0, 1);\n    const b02 = other.get(0, 2);\n    const b10 = other.get(1, 0);\n    const b11 = other.get(1, 1);\n    const b12 = other.get(1, 2);\n    const b20 = other.get(2, 0);\n    const b21 = other.get(2, 1);\n    const b22 = other.get(2, 2);\n\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n    const m2 = (a00 - a10) * (-b01 + b11);\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n    const m5 = (a10 + a11) * (-b00 + b01);\n    const m6 = a00 * b00;\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n    const m8 = (-a00 + a20) * (b02 - b12);\n    const m9 = (a20 + a21) * (-b00 + b02);\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n    const m13 = (a02 - a22) * (b11 - b21);\n    const m14 = a02 * b20;\n    const m15 = (a21 + a22) * (-b20 + b21);\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n    const m17 = (a02 - a12) * (b12 - b22);\n    const m18 = (a11 + a12) * (-b20 + b22);\n    const m19 = a01 * b10;\n    const m20 = a12 * b21;\n    const m21 = a10 * b02;\n    const m22 = a20 * b01;\n    const m23 = a22 * b22;\n\n    const c00 = m6 + m14 + m19;\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n    const c11 = m2 + m4 + m5 + m6 + m20;\n    const c12 = m14 + m16 + m17 + m18 + m21;\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n    const c21 = m12 + m13 + m14 + m15 + m22;\n    const c22 = m6 + m7 + m8 + m9 + m23;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(0, 2, c02);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    result.set(1, 2, c12);\n    result.set(2, 0, c20);\n    result.set(2, 1, c21);\n    result.set(2, 2, c22);\n    return result;\n  }\n\n  mmulStrassen(y) {\n    y = Matrix.checkMatrix(y);\n    let x = this.clone();\n    let r1 = x.rows;\n    let c1 = x.columns;\n    let r2 = y.rows;\n    let c2 = y.columns;\n    if (c1 !== r2) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\n      );\n    }\n\n    // Put a matrix into the top left of a matrix of zeros.\n    // `rows` and `cols` are the dimensions of the output matrix.\n    function embed(mat, rows, cols) {\n      let r = mat.rows;\n      let c = mat.columns;\n      if (r === rows && c === cols) {\n        return mat;\n      } else {\n        let resultat = AbstractMatrix.zeros(rows, cols);\n        resultat = resultat.setSubMatrix(mat, 0, 0);\n        return resultat;\n      }\n    }\n\n    // Make sure both matrices are the same size.\n    // This is exclusively for simplicity:\n    // this algorithm can be implemented with matrices of different sizes.\n\n    let r = Math.max(r1, r2);\n    let c = Math.max(c1, c2);\n    x = embed(x, r, c);\n    y = embed(y, r, c);\n\n    // Our recursive multiplication function.\n    function blockMult(a, b, rows, cols) {\n      // For small matrices, resort to naive multiplication.\n      if (rows <= 512 || cols <= 512) {\n        return a.mmul(b); // a is equivalent to this\n      }\n\n      // Apply dynamic padding.\n      if (rows % 2 === 1 && cols % 2 === 1) {\n        a = embed(a, rows + 1, cols + 1);\n        b = embed(b, rows + 1, cols + 1);\n      } else if (rows % 2 === 1) {\n        a = embed(a, rows + 1, cols);\n        b = embed(b, rows + 1, cols);\n      } else if (cols % 2 === 1) {\n        a = embed(a, rows, cols + 1);\n        b = embed(b, rows, cols + 1);\n      }\n\n      let halfRows = parseInt(a.rows / 2, 10);\n      let halfCols = parseInt(a.columns / 2, 10);\n      // Subdivide input matrices.\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n      // Compute intermediate values.\n      let m1 = blockMult(\n        AbstractMatrix.add(a11, a22),\n        AbstractMatrix.add(b11, b22),\n        halfRows,\n        halfCols,\n      );\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\n      let m6 = blockMult(\n        AbstractMatrix.sub(a21, a11),\n        AbstractMatrix.add(b11, b12),\n        halfRows,\n        halfCols,\n      );\n      let m7 = blockMult(\n        AbstractMatrix.sub(a12, a22),\n        AbstractMatrix.add(b21, b22),\n        halfRows,\n        halfCols,\n      );\n\n      // Combine intermediate values into the output.\n      let c11 = AbstractMatrix.add(m1, m4);\n      c11.sub(m5);\n      c11.add(m7);\n      let c12 = AbstractMatrix.add(m3, m5);\n      let c21 = AbstractMatrix.add(m2, m4);\n      let c22 = AbstractMatrix.sub(m1, m2);\n      c22.add(m3);\n      c22.add(m6);\n\n      // Crop output to the desired size (undo dynamic padding).\n      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\n      resultat = resultat.setSubMatrix(c11, 0, 0);\n      resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n      resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n      return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n    }\n    return blockMult(x, y, r, c);\n  }\n\n  scaleRows(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.rows; i++) {\n      const row = this.getRow(i);\n      if (row.length > 0) {\n        (0,ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(row, { min, max, output: row });\n      }\n      newMatrix.setRow(i, row);\n    }\n    return newMatrix;\n  }\n\n  scaleColumns(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.columns; i++) {\n      const column = this.getColumn(i);\n      if (column.length) {\n        (0,ml_array_rescale__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(column, {\n          min: min,\n          max: max,\n          output: column,\n        });\n      }\n      newMatrix.setColumn(i, column);\n    }\n    return newMatrix;\n  }\n\n  flipRows() {\n    const middle = Math.ceil(this.columns / 2);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < middle; j++) {\n        let first = this.get(i, j);\n        let last = this.get(i, this.columns - 1 - j);\n        this.set(i, j, last);\n        this.set(i, this.columns - 1 - j, first);\n      }\n    }\n    return this;\n  }\n\n  flipColumns() {\n    const middle = Math.ceil(this.rows / 2);\n    for (let j = 0; j < this.columns; j++) {\n      for (let i = 0; i < middle; i++) {\n        let first = this.get(i, j);\n        let last = this.get(this.rows - 1 - i, j);\n        this.set(i, j, last);\n        this.set(this.rows - 1 - i, j, first);\n      }\n    }\n    return this;\n  }\n\n  kroneckerProduct(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.rows;\n    let q = other.columns;\n\n    let result = new Matrix(m * p, n * q);\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        for (let k = 0; k < p; k++) {\n          for (let l = 0; l < q; l++) {\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  kroneckerSum(other) {\n    other = Matrix.checkMatrix(other);\n    if (!this.isSquare() || !other.isSquare()) {\n      throw new Error('Kronecker Sum needs two Square Matrices');\n    }\n    let m = this.rows;\n    let n = other.rows;\n    let AxI = this.kroneckerProduct(Matrix.eye(n, n));\n    let IxB = Matrix.eye(m, m).kroneckerProduct(other);\n    return AxI.add(IxB);\n  }\n\n  transpose() {\n    let result = new Matrix(this.columns, this.rows);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n    return result;\n  }\n\n  sortRows(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.rows; i++) {\n      this.setRow(i, this.getRow(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  sortColumns(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.columns; i++) {\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  subMatrix(startRow, endRow, startColumn, endColumn) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRange)(this, startRow, endRow, startColumn, endColumn);\n    let newMatrix = new Matrix(\n      endRow - startRow + 1,\n      endColumn - startColumn + 1,\n    );\n    for (let i = startRow; i <= endRow; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixRow(indices, startColumn, endColumn) {\n    if (startColumn === undefined) startColumn = 0;\n    if (endColumn === undefined) endColumn = this.columns - 1;\n    if (\n      startColumn > endColumn ||\n      startColumn < 0 ||\n      startColumn >= this.columns ||\n      endColumn < 0 ||\n      endColumn >= this.columns\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        if (indices[i] < 0 || indices[i] >= this.rows) {\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixColumn(indices, startRow, endRow) {\n    if (startRow === undefined) startRow = 0;\n    if (endRow === undefined) endRow = this.rows - 1;\n    if (\n      startRow > endRow ||\n      startRow < 0 ||\n      startRow >= this.rows ||\n      endRow < 0 ||\n      endRow >= this.rows\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startRow; j <= endRow; j++) {\n        if (indices[i] < 0 || indices[i] >= this.columns) {\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n      }\n    }\n    return newMatrix;\n  }\n\n  setSubMatrix(matrix, startRow, startColumn) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (matrix.isEmpty()) {\n      return this;\n    }\n    let endRow = startRow + matrix.rows - 1;\n    let endColumn = startColumn + matrix.columns - 1;\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRange)(this, startRow, endRow, startColumn, endColumn);\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.columns; j++) {\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\n      }\n    }\n    return this;\n  }\n\n  selection(rowIndices, columnIndices) {\n    let indices = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkIndices)(this, rowIndices, columnIndices);\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\n    for (let i = 0; i < indices.row.length; i++) {\n      let rowIndex = indices.row[i];\n      for (let j = 0; j < indices.column.length; j++) {\n        let columnIndex = indices.column[j];\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\n      }\n    }\n    return newMatrix;\n  }\n\n  trace() {\n    let min = Math.min(this.rows, this.columns);\n    let trace = 0;\n    for (let i = 0; i < min; i++) {\n      trace += this.get(i, i);\n    }\n    return trace;\n  }\n\n  clone() {\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        newMatrix.set(row, column, this.get(row, column));\n      }\n    }\n    return newMatrix;\n  }\n\n  sum(by) {\n    switch (by) {\n      case 'row':\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.sumByRow)(this);\n      case 'column':\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.sumByColumn)(this);\n      case undefined:\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.sumAll)(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  product(by) {\n    switch (by) {\n      case 'row':\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.productByRow)(this);\n      case 'column':\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.productByColumn)(this);\n      case undefined:\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.productAll)(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  mean(by) {\n    const sum = this.sum(by);\n    switch (by) {\n      case 'row': {\n        for (let i = 0; i < this.rows; i++) {\n          sum[i] /= this.columns;\n        }\n        return sum;\n      }\n      case 'column': {\n        for (let i = 0; i < this.columns; i++) {\n          sum[i] /= this.rows;\n        }\n        return sum;\n      }\n      case undefined:\n        return sum / this.size;\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  variance(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { unbiased = true, mean = this.mean(by) } = options;\n    if (typeof unbiased !== 'boolean') {\n      throw new TypeError('unbiased must be a boolean');\n    }\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.varianceByRow)(this, unbiased, mean);\n      }\n      case 'column': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.varianceByColumn)(this, unbiased, mean);\n      }\n      case undefined: {\n        if (typeof mean !== 'number') {\n          throw new TypeError('mean must be a number');\n        }\n        return (0,_stat__WEBPACK_IMPORTED_MODULE_2__.varianceAll)(this, unbiased, mean);\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  standardDeviation(by, options) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    const variance = this.variance(by, options);\n    if (by === undefined) {\n      return Math.sqrt(variance);\n    } else {\n      for (let i = 0; i < variance.length; i++) {\n        variance[i] = Math.sqrt(variance[i]);\n      }\n      return variance;\n    }\n  }\n\n  center(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { center = this.mean(by) } = options;\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.centerByRow)(this, center);\n        return this;\n      }\n      case 'column': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.centerByColumn)(this, center);\n        return this;\n      }\n      case undefined: {\n        if (typeof center !== 'number') {\n          throw new TypeError('center must be a number');\n        }\n        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.centerAll)(this, center);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  scale(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    let scale = options.scale;\n    switch (by) {\n      case 'row': {\n        if (scale === undefined) {\n          scale = (0,_stat__WEBPACK_IMPORTED_MODULE_2__.getScaleByRow)(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.scaleByRow)(this, scale);\n        return this;\n      }\n      case 'column': {\n        if (scale === undefined) {\n          scale = (0,_stat__WEBPACK_IMPORTED_MODULE_2__.getScaleByColumn)(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.scaleByColumn)(this, scale);\n        return this;\n      }\n      case undefined: {\n        if (scale === undefined) {\n          scale = (0,_stat__WEBPACK_IMPORTED_MODULE_2__.getScaleAll)(this);\n        } else if (typeof scale !== 'number') {\n          throw new TypeError('scale must be a number');\n        }\n        (0,_stat__WEBPACK_IMPORTED_MODULE_2__.scaleAll)(this, scale);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  toString(options) {\n    return (0,_inspect__WEBPACK_IMPORTED_MODULE_3__.inspectMatrixWithOptions)(this, options);\n  }\n}\n\nAbstractMatrix.prototype.klass = 'Matrix';\nif (typeof Symbol !== 'undefined') {\n  AbstractMatrix.prototype[\n    Symbol.for('nodejs.util.inspect.custom')\n  ] = _inspect__WEBPACK_IMPORTED_MODULE_3__.inspectMatrix;\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\n// Synonyms\nAbstractMatrix.random = AbstractMatrix.rand;\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\nAbstractMatrix.diagonal = AbstractMatrix.diag;\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\nAbstractMatrix.identity = AbstractMatrix.eye;\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\nAbstractMatrix.prototype.tensorProduct =\n  AbstractMatrix.prototype.kroneckerProduct;\n\nclass Matrix extends AbstractMatrix {\n  constructor(nRows, nColumns) {\n    super();\n    if (Matrix.isMatrix(nRows)) {\n      // eslint-disable-next-line no-constructor-return\n      return nRows.clone();\n    } else if (Number.isInteger(nRows) && nRows >= 0) {\n      // Create an empty matrix\n      this.data = [];\n      if (Number.isInteger(nColumns) && nColumns >= 0) {\n        for (let i = 0; i < nRows; i++) {\n          this.data.push(new Float64Array(nColumns));\n        }\n      } else {\n        throw new TypeError('nColumns must be a positive integer');\n      }\n    } else if (Array.isArray(nRows)) {\n      // Copy the values from the 2D array\n      const arrayData = nRows;\n      nRows = arrayData.length;\n      nColumns = nRows ? arrayData[0].length : 0;\n      if (typeof nColumns !== 'number') {\n        throw new TypeError(\n          'Data must be a 2D array with at least one element',\n        );\n      }\n      this.data = [];\n      for (let i = 0; i < nRows; i++) {\n        if (arrayData[i].length !== nColumns) {\n          throw new RangeError('Inconsistent array dimensions');\n        }\n        this.data.push(Float64Array.from(arrayData[i]));\n      }\n    } else {\n      throw new TypeError(\n        'First argument must be a positive number or an array',\n      );\n    }\n    this.rows = nRows;\n    this.columns = nColumns;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n\n  removeRow(index) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index);\n    this.data.splice(index, 1);\n    this.rows -= 1;\n    return this;\n  }\n\n  addRow(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.rows;\n    }\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowIndex)(this, index, true);\n    array = Float64Array.from((0,_util__WEBPACK_IMPORTED_MODULE_1__.checkRowVector)(this, array));\n    this.data.splice(index, 0, array);\n    this.rows += 1;\n    return this;\n  }\n\n  removeColumn(index) {\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns - 1);\n      for (let j = 0; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      for (let j = index + 1; j < this.columns; j++) {\n        newRow[j - 1] = this.data[i][j];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns -= 1;\n    return this;\n  }\n\n  addColumn(index, array) {\n    if (typeof array === 'undefined') {\n      array = index;\n      index = this.columns;\n    }\n    (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnIndex)(this, index, true);\n    array = (0,_util__WEBPACK_IMPORTED_MODULE_1__.checkColumnVector)(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns + 1);\n      let j = 0;\n      for (; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      newRow[j++] = array[i];\n      for (; j < this.columns + 1; j++) {\n        newRow[j] = this.data[i][j - 1];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns += 1;\n    return this;\n  }\n}\n\n(0,_mathOperations__WEBPACK_IMPORTED_MODULE_4__.installMathOperations)(AbstractMatrix, Matrix);\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/matrix.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/stat.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/stat.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"sumByRow\": () => (/* binding */ sumByRow),\n/* harmony export */   \"sumByColumn\": () => (/* binding */ sumByColumn),\n/* harmony export */   \"sumAll\": () => (/* binding */ sumAll),\n/* harmony export */   \"productByRow\": () => (/* binding */ productByRow),\n/* harmony export */   \"productByColumn\": () => (/* binding */ productByColumn),\n/* harmony export */   \"productAll\": () => (/* binding */ productAll),\n/* harmony export */   \"varianceByRow\": () => (/* binding */ varianceByRow),\n/* harmony export */   \"varianceByColumn\": () => (/* binding */ varianceByColumn),\n/* harmony export */   \"varianceAll\": () => (/* binding */ varianceAll),\n/* harmony export */   \"centerByRow\": () => (/* binding */ centerByRow),\n/* harmony export */   \"centerByColumn\": () => (/* binding */ centerByColumn),\n/* harmony export */   \"centerAll\": () => (/* binding */ centerAll),\n/* harmony export */   \"getScaleByRow\": () => (/* binding */ getScaleByRow),\n/* harmony export */   \"scaleByRow\": () => (/* binding */ scaleByRow),\n/* harmony export */   \"getScaleByColumn\": () => (/* binding */ getScaleByColumn),\n/* harmony export */   \"scaleByColumn\": () => (/* binding */ scaleByColumn),\n/* harmony export */   \"getScaleAll\": () => (/* binding */ getScaleAll),\n/* harmony export */   \"scaleAll\": () => (/* binding */ scaleAll)\n/* harmony export */ });\n/* harmony import */ var _util__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./util */ \"./node_modules/ml-matrix/src/util.js\");\n\n\nfunction sumByRow(matrix) {\n  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.rows);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumByColumn(matrix) {\n  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.columns);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction sumAll(matrix) {\n  let v = 0;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v += matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction productByRow(matrix) {\n  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.rows, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productByColumn(matrix) {\n  let sum = (0,_util__WEBPACK_IMPORTED_MODULE_0__.newArray)(matrix.columns, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nfunction productAll(matrix) {\n  let v = 1;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v *= matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nfunction varianceByRow(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let i = 0; i < rows; i++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean[i];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\n    }\n  }\n  return variance;\n}\n\nfunction varianceByColumn(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let j = 0; j < cols; j++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let i = 0; i < rows; i++) {\n      x = matrix.get(i, j) - mean[j];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\n    }\n  }\n  return variance;\n}\n\nfunction varianceAll(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const size = rows * cols;\n\n  let sum1 = 0;\n  let sum2 = 0;\n  let x = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean;\n      sum1 += x;\n      sum2 += x * x;\n    }\n  }\n  if (unbiased) {\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\n  } else {\n    return (sum2 - (sum1 * sum1) / size) / size;\n  }\n}\n\nfunction centerByRow(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\n    }\n  }\n}\n\nfunction centerByColumn(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\n    }\n  }\n}\n\nfunction centerAll(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean);\n    }\n  }\n}\n\nfunction getScaleByRow(matrix) {\n  const scale = [];\n  for (let i = 0; i < matrix.rows; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix.columns; j++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByRow(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\n    }\n  }\n}\n\nfunction getScaleByColumn(matrix) {\n  const scale = [];\n  for (let j = 0; j < matrix.columns; j++) {\n    let sum = 0;\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nfunction scaleByColumn(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\n    }\n  }\n}\n\nfunction getScaleAll(matrix) {\n  const divider = matrix.size - 1;\n  let sum = 0;\n  for (let j = 0; j < matrix.columns; j++) {\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / divider;\n    }\n  }\n  return Math.sqrt(sum);\n}\n\nfunction scaleAll(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale);\n    }\n  }\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/stat.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/util.js":
/*!********************************************!*\
  !*** ./node_modules/ml-matrix/src/util.js ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"checkRowIndex\": () => (/* binding */ checkRowIndex),\n/* harmony export */   \"checkColumnIndex\": () => (/* binding */ checkColumnIndex),\n/* harmony export */   \"checkRowVector\": () => (/* binding */ checkRowVector),\n/* harmony export */   \"checkColumnVector\": () => (/* binding */ checkColumnVector),\n/* harmony export */   \"checkIndices\": () => (/* binding */ checkIndices),\n/* harmony export */   \"checkRowIndices\": () => (/* binding */ checkRowIndices),\n/* harmony export */   \"checkColumnIndices\": () => (/* binding */ checkColumnIndices),\n/* harmony export */   \"checkRange\": () => (/* binding */ checkRange),\n/* harmony export */   \"newArray\": () => (/* binding */ newArray),\n/* harmony export */   \"checkNonEmpty\": () => (/* binding */ checkNonEmpty)\n/* harmony export */ });\n/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nfunction checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nfunction checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nfunction checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices),\n  };\n}\n\nfunction checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some((r) => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n\n  return rowIndices;\n}\n\nfunction checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some((c) => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n\n  return columnIndices;\n}\n\nfunction checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nfunction newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n\nfunction checkNonEmpty(matrix) {\n  if (matrix.isEmpty()) {\n    throw new Error('Empty matrix has no elements to index');\n  }\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/util.js?");

/***/ }),

/***/ "./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js":
/*!************************************************************!*\
  !*** ./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ WrapperMatrix2D)\n/* harmony export */ });\n/* harmony import */ var _matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n\n\nclass WrapperMatrix2D extends _matrix__WEBPACK_IMPORTED_MODULE_0__.AbstractMatrix {\n  constructor(data) {\n    super();\n    this.data = data;\n    this.rows = data.length;\n    this.columns = data[0].length;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/ml-matrix/src/wrap/WrapperMatrix2D.js?");

/***/ }),

/***/ "./node_modules/svg-parser/dist/svg-parser.esm.js":
/*!********************************************************!*\
  !*** ./node_modules/svg-parser/dist/svg-parser.esm.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"parse\": () => (/* binding */ parse)\n/* harmony export */ });\nfunction getLocator(source, options) {\n    if (options === void 0) { options = {}; }\n    var offsetLine = options.offsetLine || 0;\n    var offsetColumn = options.offsetColumn || 0;\n    var originalLines = source.split('\\n');\n    var start = 0;\n    var lineRanges = originalLines.map(function (line, i) {\n        var end = start + line.length + 1;\n        var range = { start: start, end: end, line: i };\n        start = end;\n        return range;\n    });\n    var i = 0;\n    function rangeContains(range, index) {\n        return range.start <= index && index < range.end;\n    }\n    function getLocation(range, index) {\n        return { line: offsetLine + range.line, column: offsetColumn + index - range.start, character: index };\n    }\n    function locate(search, startIndex) {\n        if (typeof search === 'string') {\n            search = source.indexOf(search, startIndex || 0);\n        }\n        var range = lineRanges[i];\n        var d = search >= range.end ? 1 : -1;\n        while (range) {\n            if (rangeContains(range, search))\n                return getLocation(range, search);\n            i += d;\n            range = lineRanges[i];\n        }\n    }\n    return locate;\n}\nfunction locate(source, search, options) {\n    if (typeof options === 'number') {\n        throw new Error('locate takes a { startIndex, offsetLine, offsetColumn } object as the third argument');\n    }\n    return getLocator(source, options)(search, options && options.startIndex);\n}\n\nvar validNameCharacters = /[a-zA-Z0-9:_-]/;\nvar whitespace = /[\\s\\t\\r\\n]/;\nvar quotemark = /['\"]/;\n\nfunction repeat(str, i) {\n\tvar result = '';\n\twhile (i--) { result += str; }\n\treturn result;\n}\n\nfunction parse(source) {\n\tvar header = '';\n\tvar stack = [];\n\n\tvar state = metadata;\n\tvar currentElement = null;\n\tvar root = null;\n\n\tfunction error(message) {\n\t\tvar ref = locate(source, i);\n\t\tvar line = ref.line;\n\t\tvar column = ref.column;\n\t\tvar before = source.slice(0, i);\n\t\tvar beforeLine = /(^|\\n).*$/.exec(before)[0].replace(/\\t/g, '  ');\n\t\tvar after = source.slice(i);\n\t\tvar afterLine = /.*(\\n|$)/.exec(after)[0];\n\n\t\tvar snippet = \"\" + beforeLine + afterLine + \"\\n\" + (repeat(' ', beforeLine.length)) + \"^\";\n\n\t\tthrow new Error(\n\t\t\t(message + \" (\" + line + \":\" + column + \"). If this is valid SVG, it's probably a bug in svg-parser. Please raise an issue at https://github.com/Rich-Harris/svg-parser/issues – thanks!\\n\\n\" + snippet)\n\t\t);\n\t}\n\n\tfunction metadata() {\n\t\twhile ((i < source.length && source[i] !== '<') || !validNameCharacters.test(source[i + 1])) {\n\t\t\theader += source[i++];\n\t\t}\n\n\t\treturn neutral();\n\t}\n\n\tfunction neutral() {\n\t\tvar text = '';\n\t\twhile (i < source.length && source[i] !== '<') { text += source[i++]; }\n\n\t\tif (/\\S/.test(text)) {\n\t\t\tcurrentElement.children.push({ type: 'text', value: text });\n\t\t}\n\n\t\tif (source[i] === '<') {\n\t\t\treturn tag;\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction tag() {\n\t\tvar char = source[i];\n\n\t\tif (char === '?') { return neutral; } // <?xml...\n\n\t\tif (char === '!') {\n\t\t\tif (source.slice(i + 1, i + 3) === '--') { return comment; }\n\t\t\tif (source.slice(i + 1, i + 8) === '[CDATA[') { return cdata; }\n\t\t\tif (/doctype/i.test(source.slice(i + 1, i + 8))) { return neutral; }\n\t\t}\n\n\t\tif (char === '/') { return closingTag; }\n\n\t\tvar tagName = getName();\n\n\t\tvar element = {\n\t\t\ttype: 'element',\n\t\t\ttagName: tagName,\n\t\t\tproperties: {},\n\t\t\tchildren: []\n\t\t};\n\n\t\tif (currentElement) {\n\t\t\tcurrentElement.children.push(element);\n\t\t} else {\n\t\t\troot = element;\n\t\t}\n\n\t\tvar attribute;\n\t\twhile (i < source.length && (attribute = getAttribute())) {\n\t\t\telement.properties[attribute.name] = attribute.value;\n\t\t}\n\n\t\tvar selfClosing = false;\n\n\t\tif (source[i] === '/') {\n\t\t\ti += 1;\n\t\t\tselfClosing = true;\n\t\t}\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tif (!selfClosing) {\n\t\t\tcurrentElement = element;\n\t\t\tstack.push(element);\n\t\t}\n\n\t\treturn neutral;\n\t}\n\n\tfunction comment() {\n\t\tvar index = source.indexOf('-->', i);\n\t\tif (!~index) { error('expected -->'); }\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction cdata() {\n\t\tvar index = source.indexOf(']]>', i);\n\t\tif (!~index) { error('expected ]]>'); }\n\n\t\tcurrentElement.children.push(source.slice(i + 7, index));\n\n\t\ti = index + 2;\n\t\treturn neutral;\n\t}\n\n\tfunction closingTag() {\n\t\tvar tagName = getName();\n\n\t\tif (!tagName) { error('Expected tag name'); }\n\n\t\tif (tagName !== currentElement.tagName) {\n\t\t\terror((\"Expected closing tag </\" + tagName + \"> to match opening tag <\" + (currentElement.tagName) + \">\"));\n\t\t}\n\n\t\tallowSpaces();\n\n\t\tif (source[i] !== '>') {\n\t\t\terror('Expected >');\n\t\t}\n\n\t\tstack.pop();\n\t\tcurrentElement = stack[stack.length - 1];\n\n\t\treturn neutral;\n\t}\n\n\tfunction getName() {\n\t\tvar name = '';\n\t\twhile (i < source.length && validNameCharacters.test(source[i])) { name += source[i++]; }\n\n\t\treturn name;\n\t}\n\n\tfunction getAttribute() {\n\t\tif (!whitespace.test(source[i])) { return null; }\n\t\tallowSpaces();\n\n\t\tvar name = getName();\n\t\tif (!name) { return null; }\n\n\t\tvar value = true;\n\n\t\tallowSpaces();\n\t\tif (source[i] === '=') {\n\t\t\ti += 1;\n\t\t\tallowSpaces();\n\n\t\t\tvalue = getAttributeValue();\n\t\t\tif (!isNaN(value) && value.trim() !== '') { value = +value; } // TODO whitelist numeric attributes?\n\t\t}\n\n\t\treturn { name: name, value: value };\n\t}\n\n\tfunction getAttributeValue() {\n\t\treturn quotemark.test(source[i]) ? getQuotedAttributeValue() : getUnquotedAttributeValue();\n\t}\n\n\tfunction getUnquotedAttributeValue() {\n\t\tvar value = '';\n\t\tdo {\n\t\t\tvar char = source[i];\n\t\t\tif (char === ' ' || char === '>' || char === '/') {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tvalue += char;\n\t\t\ti += 1;\n\t\t} while (i < source.length);\n\n\t\treturn value;\n\t}\n\n\tfunction getQuotedAttributeValue() {\n\t\tvar quotemark = source[i++];\n\n\t\tvar value = '';\n\t\tvar escaped = false;\n\n\t\twhile (i < source.length) {\n\t\t\tvar char = source[i++];\n\t\t\tif (char === quotemark && !escaped) {\n\t\t\t\treturn value;\n\t\t\t}\n\n\t\t\tif (char === '\\\\' && !escaped) {\n\t\t\t\tescaped = true;\n\t\t\t}\n\n\t\t\tvalue += escaped ? (\"\\\\\" + char) : char;\n\t\t\tescaped = false;\n\t\t}\n\t}\n\n\tfunction allowSpaces() {\n\t\twhile (i < source.length && whitespace.test(source[i])) { i += 1; }\n\t}\n\n\tvar i = metadata.length;\n\twhile (i < source.length) {\n\t\tif (!state) { error('Unexpected character'); }\n\t\tstate = state();\n\t\ti += 1;\n\t}\n\n\tif (state !== neutral) {\n\t\terror('Unexpected end of input');\n\t}\n\n\tif (root.tagName === 'svg') { root.metadata = header; }\n\treturn {\n\t\ttype: 'root',\n\t\tchildren: [root]\n\t};\n}\n\n\n//# sourceMappingURL=svg-parser.esm.js.map\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/svg-parser/dist/svg-parser.esm.js?");

/***/ }),

/***/ "./node_modules/svg-path-parser/index.js":
/*!***********************************************!*\
  !*** ./node_modules/svg-path-parser/index.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("// v1.0 exported just the parser function. To maintain backwards compatibility,\n// we export additional named features as properties of that function.\nvar parserFunction = __webpack_require__(/*! ./parser.js */ \"./node_modules/svg-path-parser/parser.js\").parse;\nparserFunction.parseSVG = parserFunction;\nparserFunction.makeAbsolute = makeSVGPathCommandsAbsolute;\nmodule.exports = parserFunction;\n\nfunction makeSVGPathCommandsAbsolute(commands) {\n\tvar subpathStart, prevCmd={x:0,y:0};\n\tvar attr = {x:'x0',y:'y0',x1:'x0',y1:'y0',x2:'x0',y2:'y0'};\n\tcommands.forEach(function(cmd) {\n\t\tif (cmd.command==='moveto') subpathStart=cmd;\n\t\tcmd.x0=prevCmd.x; cmd.y0=prevCmd.y;\n\t\tfor (var a in attr) if (a in cmd) cmd[a] += cmd.relative ? cmd[attr[a]] : 0;\n\t\tif (!('x' in cmd)) cmd.x = prevCmd.x; // V\n\t\tif (!('y' in cmd)) cmd.y = prevCmd.y; // X\n\t\tcmd.relative = false;\n\t\tcmd.code = cmd.code.toUpperCase();\n\t\tif (cmd.command=='closepath') {\n\t\t\tcmd.x = subpathStart.x;\n\t\t\tcmd.y = subpathStart.y;\n\t\t}\n\t\tprevCmd = cmd;\n\t});\n\treturn commands;\n}\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/svg-path-parser/index.js?");

/***/ }),

/***/ "./node_modules/svg-path-parser/parser.js":
/*!************************************************!*\
  !*** ./node_modules/svg-path-parser/parser.js ***!
  \************************************************/
/***/ ((module) => {

"use strict";
eval("/*\n * Generated by PEG.js 0.10.0.\n *\n * http://pegjs.org/\n */\n\n\n\nfunction peg$subclass(child, parent) {\n  function ctor() { this.constructor = child; }\n  ctor.prototype = parent.prototype;\n  child.prototype = new ctor();\n}\n\nfunction peg$SyntaxError(message, expected, found, location) {\n  this.message  = message;\n  this.expected = expected;\n  this.found    = found;\n  this.location = location;\n  this.name     = \"SyntaxError\";\n\n  if (typeof Error.captureStackTrace === \"function\") {\n    Error.captureStackTrace(this, peg$SyntaxError);\n  }\n}\n\npeg$subclass(peg$SyntaxError, Error);\n\npeg$SyntaxError.buildMessage = function(expected, found) {\n  var DESCRIBE_EXPECTATION_FNS = {\n        literal: function(expectation) {\n          return \"\\\"\" + literalEscape(expectation.text) + \"\\\"\";\n        },\n\n        \"class\": function(expectation) {\n          var escapedParts = \"\",\n              i;\n\n          for (i = 0; i < expectation.parts.length; i++) {\n            escapedParts += expectation.parts[i] instanceof Array\n              ? classEscape(expectation.parts[i][0]) + \"-\" + classEscape(expectation.parts[i][1])\n              : classEscape(expectation.parts[i]);\n          }\n\n          return \"[\" + (expectation.inverted ? \"^\" : \"\") + escapedParts + \"]\";\n        },\n\n        any: function(expectation) {\n          return \"any character\";\n        },\n\n        end: function(expectation) {\n          return \"end of input\";\n        },\n\n        other: function(expectation) {\n          return expectation.description;\n        }\n      };\n\n  function hex(ch) {\n    return ch.charCodeAt(0).toString(16).toUpperCase();\n  }\n\n  function literalEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\"/g,  '\\\\\"')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function classEscape(s) {\n    return s\n      .replace(/\\\\/g, '\\\\\\\\')\n      .replace(/\\]/g, '\\\\]')\n      .replace(/\\^/g, '\\\\^')\n      .replace(/-/g,  '\\\\-')\n      .replace(/\\0/g, '\\\\0')\n      .replace(/\\t/g, '\\\\t')\n      .replace(/\\n/g, '\\\\n')\n      .replace(/\\r/g, '\\\\r')\n      .replace(/[\\x00-\\x0F]/g,          function(ch) { return '\\\\x0' + hex(ch); })\n      .replace(/[\\x10-\\x1F\\x7F-\\x9F]/g, function(ch) { return '\\\\x'  + hex(ch); });\n  }\n\n  function describeExpectation(expectation) {\n    return DESCRIBE_EXPECTATION_FNS[expectation.type](expectation);\n  }\n\n  function describeExpected(expected) {\n    var descriptions = new Array(expected.length),\n        i, j;\n\n    for (i = 0; i < expected.length; i++) {\n      descriptions[i] = describeExpectation(expected[i]);\n    }\n\n    descriptions.sort();\n\n    if (descriptions.length > 0) {\n      for (i = 1, j = 1; i < descriptions.length; i++) {\n        if (descriptions[i - 1] !== descriptions[i]) {\n          descriptions[j] = descriptions[i];\n          j++;\n        }\n      }\n      descriptions.length = j;\n    }\n\n    switch (descriptions.length) {\n      case 1:\n        return descriptions[0];\n\n      case 2:\n        return descriptions[0] + \" or \" + descriptions[1];\n\n      default:\n        return descriptions.slice(0, -1).join(\", \")\n          + \", or \"\n          + descriptions[descriptions.length - 1];\n    }\n  }\n\n  function describeFound(found) {\n    return found ? \"\\\"\" + literalEscape(found) + \"\\\"\" : \"end of input\";\n  }\n\n  return \"Expected \" + describeExpected(expected) + \" but \" + describeFound(found) + \" found.\";\n};\n\nfunction peg$parse(input, options) {\n  options = options !== void 0 ? options : {};\n\n  var peg$FAILED = {},\n\n      peg$startRuleFunctions = { svg_path: peg$parsesvg_path },\n      peg$startRuleFunction  = peg$parsesvg_path,\n\n      peg$c0 = function(data) {\n          if (!data) return [];\n          for (var cmds=[],i=0;i<data.length;i++) cmds=cmds.concat.apply(cmds,data[i]);\n          var first=cmds[0];\n          if (first && first.code=='m'){ // Per spec, first moveto is never relative\n            delete first.relative;\n            first.code = 'M';\n          }\n          return cmds;\n        },\n      peg$c1 = function(first, more) { return merge(first,more) },\n      peg$c2 = /^[Mm]/,\n      peg$c3 = peg$classExpectation([\"M\", \"m\"], false, false),\n      peg$c4 = function(c, first, more) {\n          var move = commands(c,[first]);\n          if (more) move = move.concat(commands(c=='M' ? 'L' : 'l',more[1]));\n          return move;\n        },\n      peg$c5 = /^[Zz]/,\n      peg$c6 = peg$classExpectation([\"Z\", \"z\"], false, false),\n      peg$c7 = function() { return commands('Z') },\n      peg$c8 = /^[Ll]/,\n      peg$c9 = peg$classExpectation([\"L\", \"l\"], false, false),\n      peg$c10 = function(c, args) { return commands(c,args) },\n      peg$c11 = /^[Hh]/,\n      peg$c12 = peg$classExpectation([\"H\", \"h\"], false, false),\n      peg$c13 = function(c, args) { return commands(c,args.map(function(x){ return {x:x}})) },\n      peg$c14 = /^[Vv]/,\n      peg$c15 = peg$classExpectation([\"V\", \"v\"], false, false),\n      peg$c16 = function(c, args) { return commands(c,args.map(function(y){ return {y:y}})) },\n      peg$c17 = /^[Cc]/,\n      peg$c18 = peg$classExpectation([\"C\", \"c\"], false, false),\n      peg$c19 = function(a, b, c) { return { x1:a.x, y1:a.y, x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c20 = /^[Ss]/,\n      peg$c21 = peg$classExpectation([\"S\", \"s\"], false, false),\n      peg$c22 = function(b, c) { return { x2:b.x, y2:b.y, x:c.x, y:c.y } },\n      peg$c23 = /^[Qq]/,\n      peg$c24 = peg$classExpectation([\"Q\", \"q\"], false, false),\n      peg$c25 = function(a, b) { return { x1:a.x, y1:a.y, x:b.x, y:b.y } },\n      peg$c26 = /^[Tt]/,\n      peg$c27 = peg$classExpectation([\"T\", \"t\"], false, false),\n      peg$c28 = /^[Aa]/,\n      peg$c29 = peg$classExpectation([\"A\", \"a\"], false, false),\n      peg$c30 = function(rx, ry, xrot, large, sweep, xy) { return { rx:rx, ry:ry, xAxisRotation:xrot, largeArc:large, sweep:sweep, x:xy.x, y:xy.y } },\n      peg$c31 = function(x, y) { return { x:x, y:y } },\n      peg$c32 = function(n) { return n*1 },\n      peg$c33 = function(parts) { return parts.join('')*1 },\n      peg$c34 = /^[01]/,\n      peg$c35 = peg$classExpectation([\"0\", \"1\"], false, false),\n      peg$c36 = function(bit) { return bit=='1' },\n      peg$c37 = function() { return '' },\n      peg$c38 = \",\",\n      peg$c39 = peg$literalExpectation(\",\", false),\n      peg$c40 = function(parts) { return parts.join('') },\n      peg$c41 = \".\",\n      peg$c42 = peg$literalExpectation(\".\", false),\n      peg$c43 = /^[eE]/,\n      peg$c44 = peg$classExpectation([\"e\", \"E\"], false, false),\n      peg$c45 = /^[+\\-]/,\n      peg$c46 = peg$classExpectation([\"+\", \"-\"], false, false),\n      peg$c47 = /^[0-9]/,\n      peg$c48 = peg$classExpectation([[\"0\", \"9\"]], false, false),\n      peg$c49 = function(digits) { return digits.join('') },\n      peg$c50 = /^[ \\t\\n\\r]/,\n      peg$c51 = peg$classExpectation([\" \", \"\\t\", \"\\n\", \"\\r\"], false, false),\n\n      peg$currPos          = 0,\n      peg$savedPos         = 0,\n      peg$posDetailsCache  = [{ line: 1, column: 1 }],\n      peg$maxFailPos       = 0,\n      peg$maxFailExpected  = [],\n      peg$silentFails      = 0,\n\n      peg$result;\n\n  if (\"startRule\" in options) {\n    if (!(options.startRule in peg$startRuleFunctions)) {\n      throw new Error(\"Can't start parsing from rule \\\"\" + options.startRule + \"\\\".\");\n    }\n\n    peg$startRuleFunction = peg$startRuleFunctions[options.startRule];\n  }\n\n  function text() {\n    return input.substring(peg$savedPos, peg$currPos);\n  }\n\n  function location() {\n    return peg$computeLocation(peg$savedPos, peg$currPos);\n  }\n\n  function expected(description, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildStructuredError(\n      [peg$otherExpectation(description)],\n      input.substring(peg$savedPos, peg$currPos),\n      location\n    );\n  }\n\n  function error(message, location) {\n    location = location !== void 0 ? location : peg$computeLocation(peg$savedPos, peg$currPos)\n\n    throw peg$buildSimpleError(message, location);\n  }\n\n  function peg$literalExpectation(text, ignoreCase) {\n    return { type: \"literal\", text: text, ignoreCase: ignoreCase };\n  }\n\n  function peg$classExpectation(parts, inverted, ignoreCase) {\n    return { type: \"class\", parts: parts, inverted: inverted, ignoreCase: ignoreCase };\n  }\n\n  function peg$anyExpectation() {\n    return { type: \"any\" };\n  }\n\n  function peg$endExpectation() {\n    return { type: \"end\" };\n  }\n\n  function peg$otherExpectation(description) {\n    return { type: \"other\", description: description };\n  }\n\n  function peg$computePosDetails(pos) {\n    var details = peg$posDetailsCache[pos], p;\n\n    if (details) {\n      return details;\n    } else {\n      p = pos - 1;\n      while (!peg$posDetailsCache[p]) {\n        p--;\n      }\n\n      details = peg$posDetailsCache[p];\n      details = {\n        line:   details.line,\n        column: details.column\n      };\n\n      while (p < pos) {\n        if (input.charCodeAt(p) === 10) {\n          details.line++;\n          details.column = 1;\n        } else {\n          details.column++;\n        }\n\n        p++;\n      }\n\n      peg$posDetailsCache[pos] = details;\n      return details;\n    }\n  }\n\n  function peg$computeLocation(startPos, endPos) {\n    var startPosDetails = peg$computePosDetails(startPos),\n        endPosDetails   = peg$computePosDetails(endPos);\n\n    return {\n      start: {\n        offset: startPos,\n        line:   startPosDetails.line,\n        column: startPosDetails.column\n      },\n      end: {\n        offset: endPos,\n        line:   endPosDetails.line,\n        column: endPosDetails.column\n      }\n    };\n  }\n\n  function peg$fail(expected) {\n    if (peg$currPos < peg$maxFailPos) { return; }\n\n    if (peg$currPos > peg$maxFailPos) {\n      peg$maxFailPos = peg$currPos;\n      peg$maxFailExpected = [];\n    }\n\n    peg$maxFailExpected.push(expected);\n  }\n\n  function peg$buildSimpleError(message, location) {\n    return new peg$SyntaxError(message, null, null, location);\n  }\n\n  function peg$buildStructuredError(expected, found, location) {\n    return new peg$SyntaxError(\n      peg$SyntaxError.buildMessage(expected, found),\n      expected,\n      found,\n      location\n    );\n  }\n\n  function peg$parsesvg_path() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    while (s2 !== peg$FAILED) {\n      s1.push(s2);\n      s2 = peg$parsewsp();\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsemoveTo_drawTo_commandGroups();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c0(s2);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroups() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveTo_drawTo_commandGroup();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsemoveTo_drawTo_commandGroup();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsemoveTo_drawTo_commandGroup();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveTo_drawTo_commandGroup() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsemoveto();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = [];\n      s5 = peg$parsewsp();\n      while (s5 !== peg$FAILED) {\n        s4.push(s5);\n        s5 = peg$parsewsp();\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsedrawto_command();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = [];\n        s5 = peg$parsewsp();\n        while (s5 !== peg$FAILED) {\n          s4.push(s5);\n          s5 = peg$parsewsp();\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsedrawto_command();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsedrawto_command() {\n    var s0;\n\n    s0 = peg$parseclosepath();\n    if (s0 === peg$FAILED) {\n      s0 = peg$parselineto();\n      if (s0 === peg$FAILED) {\n        s0 = peg$parsehorizontal_lineto();\n        if (s0 === peg$FAILED) {\n          s0 = peg$parsevertical_lineto();\n          if (s0 === peg$FAILED) {\n            s0 = peg$parsecurveto();\n            if (s0 === peg$FAILED) {\n              s0 = peg$parsesmooth_curveto();\n              if (s0 === peg$FAILED) {\n                s0 = peg$parsequadratic_bezier_curveto();\n                if (s0 === peg$FAILED) {\n                  s0 = peg$parsesmooth_quadratic_bezier_curveto();\n                  if (s0 === peg$FAILED) {\n                    s0 = peg$parseelliptical_arc();\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return s0;\n  }\n\n  function peg$parsemoveto() {\n    var s0, s1, s2, s3, s4, s5, s6;\n\n    s0 = peg$currPos;\n    if (peg$c2.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c3); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$currPos;\n          s5 = peg$parsecomma_wsp();\n          if (s5 === peg$FAILED) {\n            s5 = null;\n          }\n          if (s5 !== peg$FAILED) {\n            s6 = peg$parselineto_argument_sequence();\n            if (s6 !== peg$FAILED) {\n              s5 = [s5, s6];\n              s4 = s5;\n            } else {\n              peg$currPos = s4;\n              s4 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s4;\n            s4 = peg$FAILED;\n          }\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            peg$savedPos = s0;\n            s1 = peg$c4(s1, s3, s4);\n            s0 = s1;\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseclosepath() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c5.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c6); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c7();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parselineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c8.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c9); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parselineto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parselineto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsehorizontal_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c11.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c12); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c13(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsenumber();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsenumber();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsevertical_lineto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c14.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c15); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c16(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c17.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c18); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecurveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecurveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecurveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecurveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecurveto_argument() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsecoordinate_pair();\n            if (s5 !== peg$FAILED) {\n              peg$savedPos = s0;\n              s1 = peg$c19(s1, s3, s5);\n              s0 = s1;\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c20.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c21); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsesmooth_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsesmooth_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsesmooth_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c22(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c23.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c24); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsequadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsequadratic_bezier_curveto_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsequadratic_bezier_curveto_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsequadratic_bezier_curveto_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsequadratic_bezier_curveto_argument() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsecoordinate_pair();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c25(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c26.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c27); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsesmooth_quadratic_bezier_curveto_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsesmooth_quadratic_bezier_curveto_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parsecoordinate_pair();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parsecoordinate_pair();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parsecoordinate_pair();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    if (peg$c28.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c29); }\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$parsewsp();\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$parsewsp();\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseelliptical_arc_argument_sequence();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c10(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument_sequence() {\n    var s0, s1, s2, s3, s4, s5;\n\n    s0 = peg$currPos;\n    s1 = peg$parseelliptical_arc_argument();\n    if (s1 !== peg$FAILED) {\n      s2 = [];\n      s3 = peg$currPos;\n      s4 = peg$parsecomma_wsp();\n      if (s4 === peg$FAILED) {\n        s4 = null;\n      }\n      if (s4 !== peg$FAILED) {\n        s5 = peg$parseelliptical_arc_argument();\n        if (s5 !== peg$FAILED) {\n          s4 = [s4, s5];\n          s3 = s4;\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s3;\n        s3 = peg$FAILED;\n      }\n      while (s3 !== peg$FAILED) {\n        s2.push(s3);\n        s3 = peg$currPos;\n        s4 = peg$parsecomma_wsp();\n        if (s4 === peg$FAILED) {\n          s4 = null;\n        }\n        if (s4 !== peg$FAILED) {\n          s5 = peg$parseelliptical_arc_argument();\n          if (s5 !== peg$FAILED) {\n            s4 = [s4, s5];\n            s3 = s4;\n          } else {\n            peg$currPos = s3;\n            s3 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s3;\n          s3 = peg$FAILED;\n        }\n      }\n      if (s2 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c1(s1, s2);\n        s0 = s1;\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parseelliptical_arc_argument() {\n    var s0, s1, s2, s3, s4, s5, s6, s7, s8, s9, s10, s11;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenonnegative_number();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenonnegative_number();\n        if (s3 !== peg$FAILED) {\n          s4 = peg$parsecomma_wsp();\n          if (s4 === peg$FAILED) {\n            s4 = null;\n          }\n          if (s4 !== peg$FAILED) {\n            s5 = peg$parsenumber();\n            if (s5 !== peg$FAILED) {\n              s6 = peg$parsecomma_wsp();\n              if (s6 !== peg$FAILED) {\n                s7 = peg$parseflag();\n                if (s7 !== peg$FAILED) {\n                  s8 = peg$parsecomma_wsp();\n                  if (s8 === peg$FAILED) {\n                    s8 = null;\n                  }\n                  if (s8 !== peg$FAILED) {\n                    s9 = peg$parseflag();\n                    if (s9 !== peg$FAILED) {\n                      s10 = peg$parsecomma_wsp();\n                      if (s10 === peg$FAILED) {\n                        s10 = null;\n                      }\n                      if (s10 !== peg$FAILED) {\n                        s11 = peg$parsecoordinate_pair();\n                        if (s11 !== peg$FAILED) {\n                          peg$savedPos = s0;\n                          s1 = peg$c30(s1, s3, s5, s7, s9, s11);\n                          s0 = s1;\n                        } else {\n                          peg$currPos = s0;\n                          s0 = peg$FAILED;\n                        }\n                      } else {\n                        peg$currPos = s0;\n                        s0 = peg$FAILED;\n                      }\n                    } else {\n                      peg$currPos = s0;\n                      s0 = peg$FAILED;\n                    }\n                  } else {\n                    peg$currPos = s0;\n                    s0 = peg$FAILED;\n                  }\n                } else {\n                  peg$currPos = s0;\n                  s0 = peg$FAILED;\n                }\n              } else {\n                peg$currPos = s0;\n                s0 = peg$FAILED;\n              }\n            } else {\n              peg$currPos = s0;\n              s0 = peg$FAILED;\n            }\n          } else {\n            peg$currPos = s0;\n            s0 = peg$FAILED;\n          }\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecoordinate_pair() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$parsenumber();\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma_wsp();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsenumber();\n        if (s3 !== peg$FAILED) {\n          peg$savedPos = s0;\n          s1 = peg$c31(s1, s3);\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n\n    return s0;\n  }\n\n  function peg$parsenonnegative_number() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    s1 = peg$parsefloating_point_constant();\n    if (s1 === peg$FAILED) {\n      s1 = peg$parsedigit_sequence();\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c32(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsenumber() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsesign();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsefloating_point_constant();\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsesign();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parsedigit_sequence();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c33(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseflag() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c34.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c35); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c36(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsecomma_wsp() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = [];\n    s2 = peg$parsewsp();\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        s2 = peg$parsewsp();\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      s2 = peg$parsecomma();\n      if (s2 === peg$FAILED) {\n        s2 = null;\n      }\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s1 = [s1, s2, s3];\n          s0 = s1;\n        } else {\n          peg$currPos = s0;\n          s0 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s0;\n        s0 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s0;\n      s0 = peg$FAILED;\n    }\n    if (s0 === peg$FAILED) {\n      s0 = peg$currPos;\n      s1 = peg$currPos;\n      s2 = peg$parsecomma();\n      if (s2 !== peg$FAILED) {\n        s3 = [];\n        s4 = peg$parsewsp();\n        while (s4 !== peg$FAILED) {\n          s3.push(s4);\n          s4 = peg$parsewsp();\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n      if (s1 !== peg$FAILED) {\n        peg$savedPos = s0;\n        s1 = peg$c37();\n      }\n      s0 = s1;\n    }\n\n    return s0;\n  }\n\n  function peg$parsecomma() {\n    var s0;\n\n    if (input.charCodeAt(peg$currPos) === 44) {\n      s0 = peg$c38;\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c39); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsefloating_point_constant() {\n    var s0, s1, s2, s3;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsefractional_constant();\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parseexponent();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s2 = [s2, s3];\n        s1 = s2;\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        s3 = peg$parseexponent();\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsefractional_constant() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    s2 = peg$parsedigit_sequence();\n    if (s2 === peg$FAILED) {\n      s2 = null;\n    }\n    if (s2 !== peg$FAILED) {\n      if (input.charCodeAt(peg$currPos) === 46) {\n        s3 = peg$c41;\n        peg$currPos++;\n      } else {\n        s3 = peg$FAILED;\n        if (peg$silentFails === 0) { peg$fail(peg$c42); }\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 === peg$FAILED) {\n      s1 = peg$currPos;\n      s2 = peg$parsedigit_sequence();\n      if (s2 !== peg$FAILED) {\n        if (input.charCodeAt(peg$currPos) === 46) {\n          s3 = peg$c41;\n          peg$currPos++;\n        } else {\n          s3 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c42); }\n        }\n        if (s3 !== peg$FAILED) {\n          s2 = [s2, s3];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parseexponent() {\n    var s0, s1, s2, s3, s4;\n\n    s0 = peg$currPos;\n    s1 = peg$currPos;\n    if (peg$c43.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c44); }\n    }\n    if (s2 !== peg$FAILED) {\n      s3 = peg$parsesign();\n      if (s3 === peg$FAILED) {\n        s3 = null;\n      }\n      if (s3 !== peg$FAILED) {\n        s4 = peg$parsedigit_sequence();\n        if (s4 !== peg$FAILED) {\n          s2 = [s2, s3, s4];\n          s1 = s2;\n        } else {\n          peg$currPos = s1;\n          s1 = peg$FAILED;\n        }\n      } else {\n        peg$currPos = s1;\n        s1 = peg$FAILED;\n      }\n    } else {\n      peg$currPos = s1;\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c40(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsesign() {\n    var s0;\n\n    if (peg$c45.test(input.charAt(peg$currPos))) {\n      s0 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s0 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c46); }\n    }\n\n    return s0;\n  }\n\n  function peg$parsedigit_sequence() {\n    var s0, s1, s2;\n\n    s0 = peg$currPos;\n    s1 = [];\n    if (peg$c47.test(input.charAt(peg$currPos))) {\n      s2 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s2 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c48); }\n    }\n    if (s2 !== peg$FAILED) {\n      while (s2 !== peg$FAILED) {\n        s1.push(s2);\n        if (peg$c47.test(input.charAt(peg$currPos))) {\n          s2 = input.charAt(peg$currPos);\n          peg$currPos++;\n        } else {\n          s2 = peg$FAILED;\n          if (peg$silentFails === 0) { peg$fail(peg$c48); }\n        }\n      }\n    } else {\n      s1 = peg$FAILED;\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c49(s1);\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n  function peg$parsewsp() {\n    var s0, s1;\n\n    s0 = peg$currPos;\n    if (peg$c50.test(input.charAt(peg$currPos))) {\n      s1 = input.charAt(peg$currPos);\n      peg$currPos++;\n    } else {\n      s1 = peg$FAILED;\n      if (peg$silentFails === 0) { peg$fail(peg$c51); }\n    }\n    if (s1 !== peg$FAILED) {\n      peg$savedPos = s0;\n      s1 = peg$c37();\n    }\n    s0 = s1;\n\n    return s0;\n  }\n\n\n    function merge(first,more){\n      if (!more) return [first];\n      for (var a=[first],i=0,l=more.length;i<l;i++) a[i+1]=more[i][1];\n      return a;\n    }\n\n    var cmds = {m:'moveto',l:'lineto',h:'horizontal lineto',v:'vertical lineto',c:'curveto',s:'smooth curveto',q:'quadratic curveto',t:'smooth quadratic curveto',a:'elliptical arc',z:'closepath'};\n    for (var code in cmds) cmds[code.toUpperCase()]=cmds[code];\n    function commands(code,args){\n      if (!args) args=[{}];\n      for (var i=args.length;i--;){\n        var cmd={code:code,command:cmds[code]};\n        if (code==code.toLowerCase()) cmd.relative=true;\n        for (var k in args[i]) cmd[k]=args[i][k];\n        args[i] = cmd;\n      }\n      return args;\n    }\n\n\n  peg$result = peg$startRuleFunction();\n\n  if (peg$result !== peg$FAILED && peg$currPos === input.length) {\n    return peg$result;\n  } else {\n    if (peg$result !== peg$FAILED && peg$currPos < input.length) {\n      peg$fail(peg$endExpectation());\n    }\n\n    throw peg$buildStructuredError(\n      peg$maxFailExpected,\n      peg$maxFailPos < input.length ? input.charAt(peg$maxFailPos) : null,\n      peg$maxFailPos < input.length\n        ? peg$computeLocation(peg$maxFailPos, peg$maxFailPos + 1)\n        : peg$computeLocation(peg$maxFailPos, peg$maxFailPos)\n    );\n  }\n}\n\nmodule.exports = {\n  SyntaxError: peg$SyntaxError,\n  parse:       peg$parse\n};\n\n\n//# sourceURL=webpack://graph-art-creator/./node_modules/svg-path-parser/parser.js?");

/***/ }),

/***/ "./src/MyCalc.ts":
/*!***********************!*\
  !*** ./src/MyCalc.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MyCalcClass\": () => (/* binding */ MyCalcClass)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/lib.ts\");\n/* harmony import */ var svg_parser__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! svg-parser */ \"./node_modules/svg-parser/dist/svg-parser.esm.js\");\n/* harmony import */ var svg_path_parser__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! svg-path-parser */ \"./node_modules/svg-path-parser/index.js\");\n/* harmony import */ var svg_path_parser__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(svg_path_parser__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _actions_finalize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions/finalize */ \"./src/actions/finalize.ts\");\n/* harmony import */ var _graphs_Bezier__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graphs/Bezier */ \"./src/graphs/Bezier.ts\");\n/* harmony import */ var _actions_convertFromStandard__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./actions/convertFromStandard */ \"./src/actions/convertFromStandard.ts\");\n/* harmony import */ var _actions_hideCropLines__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./actions/hideCropLines */ \"./src/actions/hideCropLines.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nclass MyCalcClass {\r\n    constructor(_Calc) {\r\n        this.Calc = _Calc;\r\n        this.Controller = _Calc.controller;\r\n        this.logicalExpressions = {};\r\n        this.usedId = new Set();\r\n        this.globalVariablesObject = {};\r\n        this.globalFunctionsObject = {};\r\n        this.linkedVariables = {};\r\n        this.expressionsToRemove = [];\r\n        this.paths = [];\r\n        this.haxIndex = 0;\r\n        this.globalId = 1;\r\n        this.isProcessing = false;\r\n        this.toFinalizeId = new Set();\r\n        this.isProcessingFinalize = false;\r\n        this.haxOnTick = false;\r\n        this.minRes = 0;\r\n        this.doneLines = new Set();\r\n        this.existingExpressions = new Set();\r\n        this.precision = 6;\r\n        this.lastControlPoint = {\r\n            cubic: { x: 0, y: 0 },\r\n            quadratic: { x: 0, y: 0 },\r\n        };\r\n        this.update();\r\n        this.init();\r\n    }\r\n    unfinalizeAll() {\r\n        const expressions = this.getExpressions()\r\n            .filter(_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)\r\n            .map(x => (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(x.id))\r\n            .filter(_lib__WEBPACK_IMPORTED_MODULE_0__.isFinal);\r\n        expressions.forEach(x => (0,_actions_finalize__WEBPACK_IMPORTED_MODULE_3__.unfinalize)(x));\r\n        expressions.forEach(x => {\r\n            try {\r\n                (0,_actions_hideCropLines__WEBPACK_IMPORTED_MODULE_6__.hideCropLines)((0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(`${x.graphId}_0`));\r\n            }\r\n            catch {\r\n                console.log('you suck');\r\n            }\r\n        });\r\n    }\r\n    init() {\r\n        this.getExpressions().forEach((expression) => {\r\n            if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(expression)) {\r\n                const id = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(expression.id);\r\n                if (id.isEditable) {\r\n                    const matches = [...expression.latex.matchAll(_lib__WEBPACK_IMPORTED_MODULE_0__.functionRegex)];\r\n                    if (matches.length > 0) { // Is a function\r\n                        this.globalFunctionsObject[matches[0][1]] = {\r\n                            id: expression.id,\r\n                            args: matches[0][2].split(','),\r\n                            definition: expression.latex.split('=')[1],\r\n                        };\r\n                    }\r\n                    if (id.graphId === 0) {\r\n                        this.usedId.add(id.graphId);\r\n                    }\r\n                }\r\n                else if (id.isFinal) {\r\n                    this.usedId.add(id.graphId);\r\n                }\r\n            }\r\n        });\r\n        setInterval(() => this.tick(), 100);\r\n    }\r\n    update() {\r\n        const expressions = this.getExpressions();\r\n        const expressionsToSet = [];\r\n        const maxNumber = {};\r\n        expressions.forEach((_expression) => {\r\n            const expression = _expression;\r\n            if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(expression)) {\r\n                if (expression.latex) {\r\n                    if (expression.latex.includes('e_{')) {\r\n                        expression.latex = expression.latex.replace('e_{', 'q_{');\r\n                        expressionsToSet.push(expression);\r\n                    }\r\n                    if (expression.id.includes('_')) {\r\n                        const split = expression.id.split('_');\r\n                        if (split[0] === 'final') {\r\n                            // const graphId = parseInt(split[1])\r\n                            if (!expression.label) {\r\n                                const graphType = (0,_actions_convertFromStandard__WEBPACK_IMPORTED_MODULE_5__.getGraphTypeFromStandard)(expression.latex);\r\n                                expression.label = JSON.stringify({\r\n                                    graphType\r\n                                });\r\n                                expressionsToSet.push(expression);\r\n                            }\r\n                        }\r\n                        else if (!['final', 'shade'].includes(split[0])) {\r\n                            const id = parseInt(split[0]);\r\n                            const graphId = parseInt(split[1]);\r\n                            if (id in maxNumber) {\r\n                                if (graphId > maxNumber[id]) {\r\n                                    maxNumber[id] = graphId;\r\n                                }\r\n                            }\r\n                            else {\r\n                                maxNumber[id] = graphId;\r\n                            }\r\n                            if (graphId === 0) {\r\n                                if (!expression.label) {\r\n                                    const graphObject = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(expression);\r\n                                    graphObject.label = JSON.stringify({\r\n                                        graphType: graphObject.graphType\r\n                                    });\r\n                                    expressionsToSet.push(graphObject);\r\n                                }\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        });\r\n        this.updateExpressions(expressionsToSet);\r\n    }\r\n    getSelected() {\r\n        if (this.selectedExpressionId) {\r\n            return this.getExpression(this.selectedExpressionId);\r\n        }\r\n        return undefined;\r\n    }\r\n    getExpression(_id) {\r\n        if (Object.keys(this.logicalExpressions).includes(_id)) {\r\n            return this.logicalExpressions[_id];\r\n        }\r\n        else {\r\n            const expression = this.Controller.getItemModel(_id);\r\n            if (expression) {\r\n                return expression;\r\n            }\r\n        }\r\n    }\r\n    getExpressions() {\r\n        return this.Calc.getExpressions();\r\n    }\r\n    setLogicalExpression(expression) {\r\n        if (!Object.keys(this.logicalExpressions).includes(expression.id)) {\r\n            this.logicalExpressions[expression.id] = expression;\r\n        }\r\n    }\r\n    get expressionAnalysis() {\r\n        return this.Calc.expressionAnalysis;\r\n    }\r\n    get selectedExpressionId() {\r\n        return this.Calc.selectedExpressionId;\r\n    }\r\n    set selectedExpressionId(id) {\r\n        this.Controller.dispatch({ type: \"set-selected-id\", id: id });\r\n    }\r\n    removeExpressions(expressions) {\r\n        expressions.forEach((expression) => {\r\n            if (!expression.id) {\r\n                throw Error(\"Expression without id\");\r\n            }\r\n            const id = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(expression.id);\r\n            if (id.isFinal || id.isEditable) {\r\n                if (this.usedId.has(id.graphId)) {\r\n                    this.usedId.delete(id.graphId);\r\n                }\r\n            }\r\n        });\r\n        this.Calc.removeExpressions(expressions);\r\n    }\r\n    removeExpression(expression) {\r\n        if (this.isLogical(expression.id)) {\r\n            delete this.logicalExpressions[expression.id];\r\n        }\r\n        else {\r\n            this.Calc.removeExpression(expression);\r\n            const id = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(expression.id);\r\n            if (id.isFinal || id.isEditable) {\r\n                if (this.usedId.has(id.graphId)) {\r\n                    this.usedId.delete(id.graphId);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    removeExpressionById(_id) {\r\n        const id = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(_id);\r\n        if (id.isEditable || id.isFinal) {\r\n            if (this.isLogical(id.id)) {\r\n                const allExpressions = this.getExpressions();\r\n                const expressionList = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.substituteToAll)(allExpressions, id.graphId);\r\n                this.updateExpressions(expressionList);\r\n                delete this.logicalExpressions[id.id];\r\n            }\r\n            else {\r\n                const expression = this.getExpression(id.id);\r\n                if (expression) {\r\n                    this.removeExpression(expression);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    newGraph(id, expressions) {\r\n        if (this.usedId.has(id)) {\r\n            throw Error('id already in expressions list');\r\n        }\r\n        else {\r\n            this.setExpressions(expressions);\r\n            this.usedId.delete(id);\r\n        }\r\n    }\r\n    tick() {\r\n        if (this.haxOnTick) {\r\n            this.nextHax();\r\n        }\r\n        // this.updateVariables()\r\n        if (this.expressionsToRemove && !this.isProcessing) {\r\n            this.isProcessing = true;\r\n            this.expressionsToRemove.forEach((expressionGroup) => {\r\n                const success = true;\r\n                if (expressionGroup.beforeRemove === 'update') {\r\n                    this.updateVariables();\r\n                    const baseExpression = expressionGroup.expressions[0];\r\n                    if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(baseExpression)) {\r\n                        this.removeExpressionById(baseExpression.latex.split('_')[0]);\r\n                    }\r\n                }\r\n                if (success) {\r\n                    this.removeExpressions(expressionGroup.expressions);\r\n                }\r\n            });\r\n            this.isProcessing = false;\r\n        }\r\n        if (this.toFinalizeId && !this.isProcessingFinalize) {\r\n            this.isProcessingFinalize = true;\r\n            this.toFinalizeId.forEach((_id) => {\r\n                const id = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(_id);\r\n                const expression = this.getExpression(id.id);\r\n                if (expression && (0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(expression)) {\r\n                    if (expression.id.endsWith('_0')) {\r\n                        const variablesNeeded = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getVariablesNeeded)(expression.latex)\r\n                            .map((variable) => variable[0]);\r\n                        let values = {};\r\n                        const graphObject = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(expression);\r\n                        let hasValues = false;\r\n                        values = {};\r\n                        try {\r\n                            values = graphObject.getGraphVariables();\r\n                            hasValues = true;\r\n                        }\r\n                        catch {\r\n                        }\r\n                        if (hasValues) {\r\n                            // console.log(Object.entries(values).map(value => `${value[1].reference}:${value[1].value}`).join(','))\r\n                            if (Object.values(values).every(value => value.value)) {\r\n                                if (graphObject instanceof _graphs_Bezier__WEBPACK_IMPORTED_MODULE_4__.Bezier) {\r\n                                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.transformBezier)(graphObject.id);\r\n                                    this.expressionsToRemove.push({\r\n                                        beforeRemove: \"update\",\r\n                                        expressions: [graphObject.toExpression()]\r\n                                    });\r\n                                }\r\n                                else {\r\n                                    this.updateVariables();\r\n                                    if (id.isEditable) {\r\n                                        (0,_actions_finalize__WEBPACK_IMPORTED_MODULE_3__.finalize)(id);\r\n                                    }\r\n                                }\r\n                                this.toFinalizeId.delete(id.id);\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            });\r\n            this.isProcessingFinalize = false;\r\n        }\r\n    }\r\n    deleteById(_id) {\r\n        if (_id.includes('_')) {\r\n            if (['shade', 'final'].includes(_id.split('_')[0])) {\r\n                const expression = this.getExpression(_id);\r\n                if (expression) {\r\n                    this.removeExpression(expression);\r\n                }\r\n            }\r\n            else {\r\n                const graphId = parseInt(_id.split('_')[0]);\r\n                const idFilter = `${graphId}_`;\r\n                let filteredExpressions = this.getExpressions();\r\n                filteredExpressions = filteredExpressions.filter((x) => x.id.startsWith(idFilter));\r\n                this.removeExpressions(filteredExpressions);\r\n                // this.removeExpressions(this.dependsOn(parseInt(currId)))\r\n                const expressionList = this.dependsOn(graphId).map((_expression) => {\r\n                    const expression = _expression;\r\n                    expression.latex = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.substituteFromId)(expression.latex, graphId);\r\n                    return expression;\r\n                });\r\n                this.updateExpressions(expressionList);\r\n            }\r\n        }\r\n    }\r\n    setExpressions(expressions) {\r\n        const expressionsToBeCreated = [];\r\n        expressions.forEach((expression) => {\r\n            if (expression.id) {\r\n                if (this.getExpression(expression.id)) {\r\n                    throw Error(\"Tried to update create existent expression\");\r\n                }\r\n                else {\r\n                    expressionsToBeCreated.push(expression);\r\n                }\r\n            }\r\n        });\r\n        this.Calc.setExpressions(expressionsToBeCreated);\r\n    }\r\n    updateExpressions(expressions) {\r\n        const expressionsToBeUpdated = [];\r\n        expressions.forEach((expression) => {\r\n            if (this.getExpression(expression.id)) {\r\n                expressionsToBeUpdated.push(expression);\r\n            }\r\n            else {\r\n                throw Error(\"Tried to update non-existent expression\");\r\n            }\r\n        });\r\n        this.Calc.setExpressions(expressionsToBeUpdated);\r\n    }\r\n    updateExpression(expression, _logical) {\r\n        const logical = !!_logical;\r\n        if (logical) {\r\n            this.setLogicalExpression(expression);\r\n        }\r\n        else {\r\n            this.Calc.setExpression(expression);\r\n        }\r\n    }\r\n    setExpression(expression, _logical) {\r\n        const logical = !!_logical;\r\n        if (logical) {\r\n            this.setLogicalExpression(expression);\r\n        }\r\n        else {\r\n            this.Calc.setExpression(expression);\r\n        }\r\n    }\r\n    getOffset() {\r\n        const graphContainer = document.querySelector('#graph-container');\r\n        const graphContainerRect = graphContainer.getBoundingClientRect();\r\n        return { x: graphContainerRect.left, y: graphContainerRect.top };\r\n    }\r\n    pixelsToMath(point) {\r\n        const { x: xOffset, y: yOffset } = this.getOffset();\r\n        return this.Calc.pixelsToMath({\r\n            x: point.x - xOffset,\r\n            y: point.y - yOffset,\r\n        });\r\n    }\r\n    get graphpaperBounds() {\r\n        return this.Calc.graphpaperBounds;\r\n    }\r\n    getState() {\r\n        return this.Calc.getState();\r\n    }\r\n    setState(state) {\r\n        return this.Calc.setState(state);\r\n    }\r\n    getItemCount() {\r\n        return this.Controller.getItemCount();\r\n    }\r\n    isLogical(id) {\r\n        return Object.keys(this.logicalExpressions).includes(id);\r\n    }\r\n    dependsOn(graphId) {\r\n        const expressionList = [];\r\n        const allExpressions = this.getExpressions();\r\n        for (let i = 0; i < allExpressions.length; i++) {\r\n            const expression = allExpressions[i];\r\n            if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(expression)) {\r\n                if (expression.latex) {\r\n                    if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.usesVariable)(expression.latex, graphId)) {\r\n                        expressionList.push(expression);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        return expressionList;\r\n    }\r\n    table(points) {\r\n        const table = {\r\n            id: \"reg_table\",\r\n            type: \"table\",\r\n            columns: [\r\n                {\r\n                    latex: \"r_{x}\",\r\n                    color: \"BLACK\",\r\n                    id: \"reg_1\",\r\n                    values: points.map((point) => point.x.toFixed(this.precision))\r\n                },\r\n                {\r\n                    latex: \"r_{y}\",\r\n                    color: \"BLACK\",\r\n                    id: \"reg_2\",\r\n                    values: points.map((point) => point.y.toFixed(this.precision))\r\n                }\r\n            ]\r\n        };\r\n        return table;\r\n    }\r\n    regression(points) {\r\n        const newExp = {\r\n            reg: \"r_{A}r_{x}^{2}+r_{C}r_{x}^{2}+r_{D}r_{x}+r_{E}r_{y}+r_{F}\\\\sim0\\\\left\\{\\\\frac{r_{F}^{2}}{r_{A}r_{C}}>1\\\\right\\\\}\",\r\n            reg_exp: \"r_{A}r_{x}^{2}+r_{C}r_{x}^{2}+r_{D}r_{x}+r_{E}r_{y}+r_{F}\\\\sim0\\\\left\\\\{\\\\frac{r_{F}^{2}}{r_{A}r_{C}}>1\\\\right\\\\}\"\r\n        };\r\n        this.setExpression(this.table(points));\r\n    }\r\n    linkedVariable(reference, _value) {\r\n        if (typeof reference === 'number') {\r\n            return new _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable(reference, _value);\r\n        }\r\n        else if (typeof reference === 'object') {\r\n            if (reference) {\r\n                const newReference = {};\r\n                Object.entries(reference)\r\n                    .forEach(pair => {\r\n                    newReference[pair[0]] = this.linkedVariable(pair[1]);\r\n                });\r\n                return newReference;\r\n            }\r\n        }\r\n        else {\r\n            if (reference) {\r\n                if (reference in this.linkedVariables) {\r\n                    if (_value) {\r\n                        this.linkedVariables[reference].value = _value;\r\n                    }\r\n                    return this.linkedVariables[reference];\r\n                }\r\n                else {\r\n                    return new _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable(reference, _value);\r\n                }\r\n            }\r\n            else {\r\n                return new _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable(reference, _value);\r\n            }\r\n        }\r\n        throw Error(\"thing broke\");\r\n    }\r\n    addLinkedVariable(linkedVariable) {\r\n        if (linkedVariable.reference) {\r\n            if (linkedVariable.reference in this.linkedVariables) {\r\n                this.linkedVariables[linkedVariable.reference] = linkedVariable;\r\n            }\r\n            else {\r\n                this.linkedVariables[linkedVariable.reference] = linkedVariable;\r\n            }\r\n        }\r\n    }\r\n    updateLinkedVariables() {\r\n        Object.values(this.linkedVariables).forEach(linkedVariable => {\r\n            if (linkedVariable.reference && !linkedVariable.alwaysClean) {\r\n                this.linkedVariables[linkedVariable.reference].clean = false;\r\n            }\r\n        });\r\n    }\r\n    getConicById(id) {\r\n        let graph = this.getExpression(`final_${id}`);\r\n        if (!graph) {\r\n            graph = this.getExpression(`${id}_0`);\r\n            if (!graph) {\r\n                return undefined;\r\n            }\r\n        }\r\n        return graph;\r\n    }\r\n    intersectConicsById(a, b) {\r\n        const aExpression = this.getConicById(a);\r\n        const bExpression = this.getConicById(b);\r\n        if (aExpression && (0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(aExpression) && bExpression && (0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(bExpression)) {\r\n            const aGraph = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(aExpression);\r\n            const bGraph = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(bExpression);\r\n            // if (aGraph.isConic && bGraph.isConic) {\r\n            //   intersectConics(aGraph, bGraph)\r\n            // }\r\n        }\r\n    }\r\n    updateVariables(filter) {\r\n        // Object.keys(this.globalVariablesObject).forEach(key => {\r\n        //   delete this.globalVariablesObject[key];\r\n        // })\r\n        let currExpressions = this.getExpressions();\r\n        if (filter) {\r\n            const idFilter = `${filter}_`;\r\n            currExpressions = currExpressions.filter((x) => x.id.startsWith(idFilter));\r\n        }\r\n        for (let i = 0; i < currExpressions.length; i++) {\r\n            const expression = currExpressions[i];\r\n            const analysis = this.expressionAnalysis[expression.id];\r\n            if (analysis && (0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(expression)) {\r\n                if (analysis.evaluation) {\r\n                    if (analysis.evaluation.type === 'Number') {\r\n                        const variable = expression.latex.split('=')[0];\r\n                        if (variable.includes('_') && !(['x', 'y'].includes(variable))) {\r\n                            this.globalVariablesObject[variable] = analysis.evaluation.value.toString();\r\n                        }\r\n                    }\r\n                }\r\n                else if (expression.latex) {\r\n                    if (expression.latex.includes('f_')) {\r\n                        // console.log(expression);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    consoleSVG(n) {\r\n        console.log(this.paths[n]);\r\n    }\r\n    hax(n) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.hax)(this.paths[n]);\r\n    }\r\n    nextHax() {\r\n        if (this.haxIndex < this.paths.length) {\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.hax)(this.paths[this.haxIndex]);\r\n            this.haxIndex += 1;\r\n        }\r\n        else {\r\n            this.haxOnTick = false;\r\n        }\r\n    }\r\n    xhr() {\r\n        const url = \"http://localhost:8010/proxy/attachments/831873240694652948/906153339161554944/feather.svg\";\r\n        let paths = [];\r\n        fetch(url)\r\n            .then(r => r.text())\r\n            .then(t => {\r\n            const svg = (0,svg_parser__WEBPACK_IMPORTED_MODULE_1__.parse)(t);\r\n            const child1 = svg.children[0];\r\n            if (child1.type === \"element\") {\r\n                const child2 = child1.children[0];\r\n                if (typeof child2 !== \"string\") {\r\n                    if (child2.type === \"element\") {\r\n                        paths = child2.children.map(child => {\r\n                            if (typeof child !== \"string\") {\r\n                                if (child.type === \"element\") {\r\n                                    return child.properties;\r\n                                }\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n            this.paths = [];\r\n            paths.forEach((path) => {\r\n                let transform = \"\";\r\n                let _dx = \"0\";\r\n                let _dy = \"0\";\r\n                let style = \"\";\r\n                let color = \"#000000\";\r\n                if (path.transform) {\r\n                    [transform, _dx, _dy] = [...path.transform.matchAll(/translate\\((-?\\d+(?:.\\d+)?) (-?\\d+(?:.\\d+)?)\\)/g)][0];\r\n                }\r\n                if (path.style) {\r\n                    [style, color] = [...path.style.matchAll(/fill: (#[0-9a-f]{6})/g)][0];\r\n                }\r\n                const commands = (0,svg_path_parser__WEBPACK_IMPORTED_MODULE_2__.makeAbsolute)((0,svg_path_parser__WEBPACK_IMPORTED_MODULE_2__.parseSVG)(path.d));\r\n                const newCommands = commands.map((_command, index) => {\r\n                    return {\r\n                        command: _command,\r\n                        details: {\r\n                            dx: parseFloat(_dx),\r\n                            dy: parseFloat(_dy),\r\n                            color,\r\n                            isStart: index === 0\r\n                        }\r\n                    };\r\n                });\r\n                this.paths.push(...newCommands);\r\n            });\r\n        });\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/MyCalc.ts?");

/***/ }),

/***/ "./src/actions/convertFromStandard.ts":
/*!********************************************!*\
  !*** ./src/actions/convertFromStandard.ts ***!
  \********************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"regex\": () => (/* binding */ regex),\n/* harmony export */   \"getGraphTypeFromStandard\": () => (/* binding */ getGraphTypeFromStandard),\n/* harmony export */   \"convertFromStandard\": () => (/* binding */ convertFromStandard)\n/* harmony export */ });\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\nconst regex = [\r\n    /\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\+\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}=([-+]?\\d+\\.?\\d*)/g,\r\n    /\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}=([-+]?\\d+\\.?\\d*)\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)/g,\r\n    /\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}=([-+]?\\d+\\.?\\d*)\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)/g,\r\n    /\\\\frac\\{\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}\\+\\\\frac\\{\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}=1/g,\r\n    /\\\\frac\\{\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}-\\\\frac\\{\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}=1/g,\r\n    /\\\\frac\\{\\\\left\\(y([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}-\\\\frac\\{\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}\\{([-+]?\\d+\\.?\\d*)\\}=1/g,\r\n    /y=([-+]?\\d+\\.?\\d*)x([-+]?\\d+\\.?\\d*)\\\\left\\\\{([-+]?\\d+\\.?\\d*)<x<([-+]?\\d+\\.?\\d*)\\\\right\\\\}/g,\r\n];\r\nfunction getGraphTypeFromStandard(latex) {\r\n    const graphType = regex.findIndex((pattern) => pattern.test(latex));\r\n    return graphType;\r\n}\r\nfunction convertFromStandard(latex, graphId, options) {\r\n    const graphType = getGraphTypeFromStandard(latex);\r\n    if (graphType === -1) {\r\n        throw Error(`Failed converting expression '${latex}' to standard form`);\r\n    }\r\n    else {\r\n        const currRegex = regex[graphType];\r\n        const match = latex.match(currRegex);\r\n        if (match) {\r\n            const variables = [...match[0].matchAll(currRegex)][0].slice(1)\r\n                .map((x) => parseFloat(x));\r\n            const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.getDomainsFromLatex)(latex);\r\n            if (domains) {\r\n                const bounds = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.parseDomains)(domains);\r\n                (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(graphId, graphType, (0,_lib__WEBPACK_IMPORTED_MODULE_1__.transformVariables)(graphType, variables), bounds, options);\r\n            }\r\n        }\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/actions/convertFromStandard.ts?");

/***/ }),

/***/ "./src/actions/finalize.ts":
/*!*********************************!*\
  !*** ./src/actions/finalize.ts ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"unfinalize\": () => (/* binding */ unfinalize),\n/* harmony export */   \"finalize\": () => (/* binding */ finalize),\n/* harmony export */   \"finalizeId\": () => (/* binding */ finalizeId)\n/* harmony export */ });\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n/* harmony import */ var _convertFromStandard__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./convertFromStandard */ \"./src/actions/convertFromStandard.ts\");\n\r\n\r\n\r\nfunction unfinalizeConvert(id) {\r\n    const regex = /y=([-+]?(?:\\d+\\.?\\d*)?)\\\\sqrt\\{([-+]?\\d+\\.?\\d*)\\+\\\\left\\(x([-+]?\\d+\\.?\\d*)\\\\right\\)\\^\\{2\\}\\}([-+]?\\d+\\.?\\d*)/g;\r\n    const expression = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpression(id.id);\r\n    if (expression && (0,_lib__WEBPACK_IMPORTED_MODULE_1__.isBaseExpression)(expression)) {\r\n        const variables = [...expression.latex.matchAll(regex)][0].slice(1);\r\n        if (variables.length) {\r\n            const [_a, _b, _h, _k] = variables;\r\n            const a = parseFloat(_a === '-' ? '-1' : _a);\r\n            const b = parseFloat(_b);\r\n            const h = -parseFloat(_h);\r\n            const k = parseFloat(_k);\r\n            const a2 = b * a ** 2;\r\n            const b2 = b;\r\n            const { xMin: _xMin, xMax: _xMax, yMin: _yMin, yMax: _yMax } = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.parseDomains)((0,_lib__WEBPACK_IMPORTED_MODULE_1__.getDomainsFromLatex)(expression.latex));\r\n            const xMin = Math.max(-Infinity, _xMin);\r\n            const xMax = Math.min(Infinity, _xMax);\r\n            if (a < 0) { // down\r\n                const yMin = Math.max(-Infinity, _yMin);\r\n                const yMax = Math.min(k, _yMax);\r\n                if (b < 0) { // horizontal hyperbola\r\n                    (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId, 4, { h, a: Math.sqrt(Math.abs(b2)), k, b: Math.sqrt(Math.abs(a2)) }, { xMin, xMax, yMin, yMax });\r\n                }\r\n                else if (b > 0) { // vertical hyperbola\r\n                    (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId, 5, { h, a: Math.sqrt(Math.abs(a2)), k, b: Math.sqrt(Math.abs(b2)) }, { xMin, xMax, yMin, yMax });\r\n                }\r\n            }\r\n            else if (a > 0) { // up\r\n                const yMin = Math.max(k, _yMin);\r\n                const yMax = Math.min(Infinity, _yMax);\r\n                if (b < 0) { // horizontal hyperbola\r\n                    (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId, 4, { h, a: Math.sqrt(Math.abs(b2)), k, b: Math.sqrt(Math.abs(a2)) }, { xMin, xMax, yMin, yMax });\r\n                }\r\n                else if (b > 0) { // vertical parabola\r\n                    (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId, 5, { h, a: Math.sqrt(Math.abs(a2)), k, b: Math.sqrt(Math.abs(b2)) }, { xMin, xMax, yMin, yMax });\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction unfinalize(id, options) {\r\n    const graphExpression = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpression(id.id);\r\n    if (graphExpression && (0,_lib__WEBPACK_IMPORTED_MODULE_1__.isBaseExpression)(graphExpression)) {\r\n        (0,_convertFromStandard__WEBPACK_IMPORTED_MODULE_2__.convertFromStandard)(graphExpression.latex, id.graphId, { ...options, set: true });\r\n        if (!options?.logical) {\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.removeExpressions([graphExpression]);\r\n        }\r\n    }\r\n}\r\nfunction finalize(id) {\r\n    if (_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.isLogical(id.id)) {\r\n        const expressionList = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.dependsOn(id.graphId).map((_expression) => {\r\n            const expression = _expression;\r\n            expression.latex = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.substituteFromId)(expression.latex, id.graphId);\r\n            return expression;\r\n        });\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.updateExpressions(expressionList);\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.removeExpressionById(id.id);\r\n    }\r\n    else {\r\n        const sameIdItem = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpression(`final_${id.graphId}`);\r\n        if (sameIdItem) {\r\n            // throw Error('Same id for some reason')\r\n        }\r\n        const idFilter = `${id.graphId}_`;\r\n        const filteredExpressions = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpressions().filter((expression) => expression.id.startsWith(idFilter));\r\n        const baseExpression = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpression(`${id.graphId}_0`);\r\n        if (!baseExpression) {\r\n            throw Error(`Cannot find expression with id ${id.graphId}_0`);\r\n        }\r\n        if (baseExpression && (0,_lib__WEBPACK_IMPORTED_MODULE_1__.isBaseExpression)(baseExpression)) {\r\n            const conic = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.createGraphObject)(baseExpression);\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.removeExpressions(filteredExpressions);\r\n            const allExpressions = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpressions();\r\n            const expressionList = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.substituteToAll)(allExpressions, conic.graphId);\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.updateExpressions(expressionList);\r\n            conic.latex = conic.convertToStandard();\r\n            conic.id = `final_${conic.graphId}`;\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.setExpression(conic);\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId += 1;\r\n        }\r\n    }\r\n}\r\nfunction finalizeId(id) {\r\n    if (id.isFinal) {\r\n        unfinalize(id);\r\n    }\r\n    else if (id.isEditable) {\r\n        finalize(id);\r\n    }\r\n    else if (id.isInvalid) {\r\n        unfinalizeConvert(id);\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/actions/finalize.ts?");

/***/ }),

/***/ "./src/actions/hideCropLines.ts":
/*!**************************************!*\
  !*** ./src/actions/hideCropLines.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"hideCropLines\": () => (/* binding */ hideCropLines)\n/* harmony export */ });\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\nfunction hideCropLines(id) {\r\n    if (id.isEditable) {\r\n        const idFilter = `${id.graphId}_`;\r\n        const filteredExpressions = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpressions();\r\n        const baseExpressions = filteredExpressions.filter(_lib__WEBPACK_IMPORTED_MODULE_1__.isBaseExpression).filter((x) => x.id.startsWith(idFilter));\r\n        const graphExpression = baseExpressions.find((x) => x.id.endsWith('_0'));\r\n        if (!graphExpression) {\r\n            throw new Error();\r\n        }\r\n        const conic = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.createGraphObject)(graphExpression);\r\n        const { graphType } = conic;\r\n        const hidableBaseExpressions = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.typeFilter)(baseExpressions, graphType, ['hide']);\r\n        let [newExpression] = baseExpressions;\r\n        const newState = !hidableBaseExpressions.every(expression => expression.hidden);\r\n        const expressionsToSet = [];\r\n        const cropType = conic.getCropType();\r\n        const xBoundary = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.typeFilter)(hidableBaseExpressions, graphType, ['x']); // x only domain\r\n        const yBoundary = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.typeFilter)(hidableBaseExpressions, graphType, ['y']); // y only domain\r\n        const xyPoints = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.typeFilter)(hidableBaseExpressions, graphType, ['xy']); // points\r\n        const points = (0,_lib__WEBPACK_IMPORTED_MODULE_1__.typeFilter)(hidableBaseExpressions, graphType, ['point']); // points\r\n        if (!newState) {\r\n            for (let i = 0; i < points.length; i++) {\r\n                const newExpression = points[i];\r\n                newExpression.hidden = false;\r\n                expressionsToSet.push(newExpression);\r\n            }\r\n            for (let j = 0; j < xBoundary.length; j++) {\r\n                const newExpression = xBoundary[j];\r\n                if (!newExpression.hidden && (cropType % 2 === 1)) {\r\n                    newExpression.hidden = false;\r\n                    expressionsToSet.push(newExpression);\r\n                }\r\n            }\r\n            for (let j = 0; j < yBoundary.length; j++) {\r\n                const newExpression = yBoundary[j];\r\n                if (!newExpression.hidden && (cropType > 1)) {\r\n                    newExpression.hidden = false;\r\n                    expressionsToSet.push(newExpression);\r\n                }\r\n            }\r\n            for (let j = 0; j < xyPoints.length; j++) {\r\n                const newExpression = xyPoints[j];\r\n                if (!newExpression.hidden && !(cropType === 3)) {\r\n                    newExpression.hidden = false;\r\n                    expressionsToSet.push(newExpression);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            for (let i = 0; i < points.length; i++) {\r\n                const newExpression = points[i];\r\n                newExpression.hidden = true;\r\n                expressionsToSet.push(newExpression);\r\n            }\r\n            for (let i = 0; i < hidableBaseExpressions.length; i++) {\r\n                const newBaseExpression = hidableBaseExpressions[i];\r\n                newExpression = newBaseExpression;\r\n                newExpression.hidden = true;\r\n                expressionsToSet.push(newExpression);\r\n            }\r\n        }\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.updateExpressions(expressionsToSet);\r\n    }\r\n    else {\r\n        throw Error(\"Tried hiding crop lines from a non-editable expression\");\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/actions/hideCropLines.ts?");

/***/ }),

/***/ "./src/bezierLib.ts":
/*!**************************!*\
  !*** ./src/bezierLib.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getCriticalPoints\": () => (/* binding */ getCriticalPoints),\n/* harmony export */   \"subdivideCubic\": () => (/* binding */ subdivideCubic),\n/* harmony export */   \"bezierMinMax\": () => (/* binding */ bezierMinMax),\n/* harmony export */   \"evaluateBezier\": () => (/* binding */ evaluateBezier)\n/* harmony export */ });\nfunction compareNum(a, b) {\r\n    if (a < b)\r\n        return -1;\r\n    if (a > b)\r\n        return 1;\r\n    return 0;\r\n}\r\nfunction findInflectionPoints(p1, p2, p3, p4) {\r\n    const ax = -p1.x + 3 * p2.x - 3 * p3.x + p4.x;\r\n    const bx = 3 * p1.x - 6 * p2.x + 3 * p3.x;\r\n    const cx = -3 * p1.x + 3 * p2.x;\r\n    const ay = -p1.y + 3 * p2.y - 3 * p3.y + p4.y;\r\n    const by = 3 * p1.y - 6 * p2.y + 3 * p3.y;\r\n    const cy = -3 * p1.y + 3 * p2.y;\r\n    const a = 3 * (ay * bx - ax * by);\r\n    const b = 3 * (ay * cx - ax * cy);\r\n    const c = by * cx - bx * cy;\r\n    const r2 = b * b - 4 * a * c;\r\n    let firstIfp = 0;\r\n    let secondIfp = 0;\r\n    if (r2 >= 0 && a !== 0) {\r\n        const r = Math.sqrt(r2);\r\n        firstIfp = (-b + r) / (2 * a);\r\n        secondIfp = (-b - r) / (2 * a);\r\n        if ((firstIfp > 0 && firstIfp < 1) && (secondIfp > 0 && secondIfp < 1)) {\r\n            if (firstIfp > secondIfp) {\r\n                const tmp = firstIfp;\r\n                firstIfp = secondIfp;\r\n                secondIfp = tmp;\r\n            }\r\n            if (secondIfp - firstIfp > 0.00001)\r\n                return [firstIfp, secondIfp];\r\n            else\r\n                return [firstIfp];\r\n        }\r\n        else if (firstIfp > 0 && firstIfp < 1)\r\n            return [firstIfp];\r\n        else if (secondIfp > 0 && secondIfp < 1) {\r\n            firstIfp = secondIfp;\r\n            return [firstIfp];\r\n        }\r\n        return [];\r\n    }\r\n    else\r\n        return [];\r\n}\r\nfunction getCriticalPoints(p1, c1, c2, p2) {\r\n    let a = (c2.x - 2 * c1.x + p1.x) - (p2.x - 2 * c2.x + c1.x), b = 2 * (c1.x - p1.x) - 2 * (c2.x - c1.x), c = p1.x - c1.x, t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a, t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;\r\n    const tvalues = [];\r\n    Math.abs(t1) > 1e12 && (t1 = 0.5);\r\n    Math.abs(t2) > 1e12 && (t2 = 0.5);\r\n    if (t1 >= 0 && t1 <= 1 && tvalues.indexOf(t1) == -1)\r\n        tvalues.push(t1);\r\n    if (t2 >= 0 && t2 <= 1 && tvalues.indexOf(t2) == -1)\r\n        tvalues.push(t2);\r\n    a = (c2.y - 2 * c1.y + p1.y) - (p2.y - 2 * c2.y + c1.y);\r\n    b = 2 * (c1.y - p1.y) - 2 * (c2.y - c1.y);\r\n    c = p1.y - c1.y;\r\n    t1 = (-b + Math.sqrt(b * b - 4 * a * c)) / 2 / a;\r\n    t2 = (-b - Math.sqrt(b * b - 4 * a * c)) / 2 / a;\r\n    Math.abs(t1) > 1e12 && (t1 = 0.5);\r\n    Math.abs(t2) > 1e12 && (t2 = 0.5);\r\n    if (t1 >= 0 && t1 <= 1 && tvalues.indexOf(t1) == -1)\r\n        tvalues.push(t1);\r\n    if (t2 >= 0 && t2 <= 1 && tvalues.indexOf(t2) == -1)\r\n        tvalues.push(t2);\r\n    const inflectionpoints = findInflectionPoints(p1, c1, c2, p2);\r\n    if (inflectionpoints[0])\r\n        tvalues.push(inflectionpoints[0]);\r\n    if (inflectionpoints[1])\r\n        tvalues.push(inflectionpoints[1]);\r\n    tvalues.sort(compareNum);\r\n    return tvalues;\r\n}\r\nclass CPoint {\r\n    constructor(x, y) {\r\n        this.X = x;\r\n        this.Y = y;\r\n    }\r\n}\r\nfunction subdivideCubic(m_p1, m_p2, m_p3, m_p4, t) {\r\n    const p1p = new CPoint(m_p1.x + (m_p2.x - m_p1.x) * t, m_p1.y + (m_p2.y - m_p1.y) * t);\r\n    const p2p = new CPoint(m_p2.x + (m_p3.x - m_p2.x) * t, m_p2.y + (m_p3.y - m_p2.y) * t);\r\n    const p3p = new CPoint(m_p3.x + (m_p4.x - m_p3.x) * t, m_p3.y + (m_p4.y - m_p3.y) * t);\r\n    const p1d = new CPoint(p1p.X + (p2p.X - p1p.X) * t, p1p.Y + (p2p.Y - p1p.Y) * t);\r\n    const p2d = new CPoint(p2p.X + (p3p.X - p2p.X) * t, p2p.Y + (p3p.Y - p2p.Y) * t);\r\n    const p1t = new CPoint(p1d.X + (p2d.X - p1d.X) * t, p1d.Y + (p2d.Y - p1d.Y) * t);\r\n    return [[m_p1.x, m_p1.y, p1p.X, p1p.Y, p1d.X, p1d.Y, p1t.X, p1t.Y],\r\n        [p1t.X, p1t.Y, p2d.X, p2d.Y, p3p.X, p3p.Y, m_p4.x, m_p4.y]];\r\n}\r\nfunction bezierMinMax(p1, p2, p3, p4) {\r\n    const tvalues = [], xvalues = [], yvalues = [];\r\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\r\n    for (let i = 0; i < 2; ++i) {\r\n        if (i == 0) {\r\n            b = 6 * p1.x - 12 * p2.x + 6 * p3.x;\r\n            a = -3 * p1.x + 9 * p2.x - 9 * p3.x + 3 * p4.x;\r\n            c = 3 * p2.x - 3 * p1.x;\r\n        }\r\n        else {\r\n            b = 6 * p1.y - 12 * p2.y + 6 * p3.y;\r\n            a = -3 * p1.y + 9 * p2.y - 9 * p3.y + 3 * p4.y;\r\n            c = 3 * p2.y - 3 * p1.y;\r\n        }\r\n        if (Math.abs(a) < 1e-12) {\r\n            if (Math.abs(b) < 1e-12) {\r\n                continue;\r\n            }\r\n            t = -c / b;\r\n            if (0 < t && t < 1) {\r\n                tvalues.push(t);\r\n            }\r\n            continue;\r\n        }\r\n        b2ac = b * b - 4 * c * a;\r\n        if (b2ac < 0) {\r\n            if (Math.abs(b2ac) < 1e-12) {\r\n                t = -b / (2 * a);\r\n                if (0 < t && t < 1) {\r\n                    tvalues.push(t);\r\n                }\r\n            }\r\n            continue;\r\n        }\r\n        sqrtb2ac = Math.sqrt(b2ac);\r\n        t1 = (-b + sqrtb2ac) / (2 * a);\r\n        if (0 < t1 && t1 < 1) {\r\n            tvalues.push(t1);\r\n        }\r\n        t2 = (-b - sqrtb2ac) / (2 * a);\r\n        if (0 < t2 && t2 < 1) {\r\n            tvalues.push(t2);\r\n        }\r\n    }\r\n    let j = tvalues.length, mt;\r\n    while (j--) {\r\n        t = tvalues[j];\r\n        mt = 1 - t;\r\n        xvalues[j] = (mt * mt * mt * p1.x) + (3 * mt * mt * t * p2.x) + (3 * mt * t * t * p3.x) + (t * t * t * p4.x);\r\n        yvalues[j] = (mt * mt * mt * p1.y) + (3 * mt * mt * t * p2.y) + (3 * mt * t * t * p3.y) + (t * t * t * p4.y);\r\n    }\r\n    xvalues.push(p1.x, p4.x);\r\n    yvalues.push(p1.y, p4.y);\r\n    return {\r\n        min: { x: Math.min.apply(0, xvalues), y: Math.min.apply(0, yvalues) },\r\n        max: { x: Math.max.apply(0, xvalues), y: Math.max.apply(0, yvalues) }\r\n    };\r\n}\r\nfunction evaluateBezier(p1, p2, p3, p4, t) {\r\n    const x = p1.x * (1 - t) ** 3 + p2.x * 3 * t * (1 - t) ** 2 + p3.x * 3 * (1 - t) * t ** 2 + p4.x * t ** 3;\r\n    const y = p1.y * (1 - t) ** 3 + p2.y * 3 * t * (1 - t) ** 2 + p3.y * 3 * (1 - t) * t ** 2 + p4.y * t ** 3;\r\n    return {\r\n        x,\r\n        y,\r\n    };\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/bezierLib.ts?");

/***/ }),

/***/ "./src/classes/Graph.ts":
/*!******************************!*\
  !*** ./src/classes/Graph.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Graph\": () => (/* binding */ Graph)\n/* harmony export */ });\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\nclass Graph {\r\n    constructor(expression, graphType) {\r\n        this.color = expression.color;\r\n        this.hidden = expression.hidden;\r\n        this.id = expression.id;\r\n        this.latex = expression.latex;\r\n        this.type = expression.type;\r\n        const id = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getIdParts)(this.id);\r\n        this.graphId = -1;\r\n        if (id.isEditable || id.isFinal) {\r\n            this.graphId = id.graphId;\r\n        }\r\n        else {\r\n            throw Error(\"Tried to create Graph Object from a non-curve expression\");\r\n        }\r\n        this.label = expression.label ? expression.label : \"\";\r\n        if (graphType) {\r\n            this.graphType = graphType;\r\n        }\r\n        else {\r\n            this.graphType = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getGraphType)(expression);\r\n        }\r\n    }\r\n    // return `${A}x^{2}+${C}y^{2}+${D}x+${E}y+${F}=0`;\r\n    toExpression() {\r\n        return {\r\n            id: this.id,\r\n            latex: this.latex,\r\n            type: this.type,\r\n            color: this.color,\r\n            hidden: this.hidden,\r\n        };\r\n    }\r\n    evaluateBounds(variables, bounds) {\r\n        const ya = this.evaluator('y', variables, { x: bounds.xMin });\r\n        const yb = this.evaluator('y', variables, { x: bounds.xMax });\r\n        const xa = this.evaluator('x', variables, { y: bounds.yMin });\r\n        const xb = this.evaluator('x', variables, { y: bounds.yMax });\r\n        return { xa, xb, ya, yb };\r\n    }\r\n    getBoundPoints(domains, evaluations) {\r\n        const xPoints = [\r\n            { x: domains.xMin, y: evaluations.ya.min },\r\n            { x: domains.xMin, y: evaluations.ya.max },\r\n            { x: domains.xMax, y: evaluations.yb.min },\r\n            { x: domains.xMax, y: evaluations.yb.max },\r\n        ].filter((point) => Number.isFinite(point.x.value));\r\n        const yPoints = [\r\n            { x: evaluations.xa.min, y: domains.yMin },\r\n            { x: evaluations.xa.max, y: domains.yMin },\r\n            { x: evaluations.xb.min, y: domains.yMax },\r\n            { x: evaluations.xb.max, y: domains.yMax },\r\n        ].filter((point) => Number.isFinite(point.y.value));\r\n        return [...xPoints, ...yPoints];\r\n    }\r\n    getBounds() {\r\n        const { graphId } = this;\r\n        let { xMin, yMin, xMax, yMax } = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        const { specialPoints, cropPoints } = this.getEndpoints();\r\n        const points = [...specialPoints, ...cropPoints];\r\n        const innerPoints = points.filter((point) => (xMin.value <= point.x.value)\r\n            && (point.x.value <= xMax.value)\r\n            && (yMin.value <= point.y.value)\r\n            && (point.y.value <= yMax.value));\r\n        const x1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const x2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const y1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.y));\r\n        const y2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.y));\r\n        const x1s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(specialPoints.map((point) => point.x));\r\n        const x2s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(specialPoints.map((point) => point.x));\r\n        const y1s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(specialPoints.map((point) => point.y));\r\n        const y2s = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(specialPoints.map((point) => point.y));\r\n        xMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([xMin, x1]);\r\n        yMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([yMin, y1]);\r\n        xMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([xMax, x2]);\r\n        yMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([yMax, y2]);\r\n        const cropType = this.getCropType();\r\n        const { xMin: xMinDomain, yMin: yMinDomain, xMax: xMaxDomain, yMax: yMaxDomain, } = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(this.graphId);\r\n        xMin = parseFloat(xMinDomain.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) < parseFloat(xMin.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) ? xMin : xMinDomain;\r\n        xMax = parseFloat(xMaxDomain.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) > parseFloat(xMax.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) ? xMax : xMaxDomain;\r\n        yMin = parseFloat(yMinDomain.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) < parseFloat(yMin.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) ? yMin : yMinDomain;\r\n        yMax = parseFloat(yMaxDomain.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) > parseFloat(yMax.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision)) ? yMax : yMaxDomain;\r\n        xMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasXDomain)(cropType) ? xMin : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(-Infinity);\r\n        xMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasXDomain)(cropType) ? xMax : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(Infinity);\r\n        yMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasYDomain)(cropType) ? yMin : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(-Infinity);\r\n        yMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.hasYDomain)(cropType) ? yMax : _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(Infinity);\r\n        xMin.value -= 10 ** (-_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision);\r\n        xMax.value += 10 ** (-_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision);\r\n        yMin.value -= 10 ** (-_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision);\r\n        yMax.value += 10 ** (-_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.precision);\r\n        return { xMin, yMin, xMax, yMax };\r\n    }\r\n    getCropType() {\r\n        return 3\r\n            - (this.latex.includes('\\\\left\\\\{x') ? 2 : 0)\r\n            - (this.latex.includes('\\\\left\\\\{y') ? 1 : 0);\r\n    }\r\n    convertToYRelevant() {\r\n        const relevantIndices = this.getRelevant('y');\r\n        const converted = this.convertToY();\r\n        return relevantIndices.map((index) => converted[index]);\r\n    }\r\n    convertToXRelevant() {\r\n        const relevantIndices = this.getRelevant('x');\r\n        const converted = this.convertToX();\r\n        return relevantIndices.map((index) => converted[index]);\r\n    }\r\n    evaluator(axis, _variables, input) {\r\n        const variables = {};\r\n        const inputAxis = axis === 'x' ? 'y' : 'x';\r\n        Object.entries(_variables)\r\n            .forEach(([key, value]) => {\r\n            variables[key] = value.value;\r\n        });\r\n        variables[inputAxis] = input[inputAxis].value;\r\n        const values = [];\r\n        const expressions = axis === 'x' ? _constants__WEBPACK_IMPORTED_MODULE_0__.xExpressionsEval[this.graphType] : _constants__WEBPACK_IMPORTED_MODULE_0__.yExpressionsEval[this.graphType];\r\n        for (let i = 0; i < expressions.length; i++) {\r\n            let expression = expressions[i].replaceAll('_{1}', '');\r\n            expression = expression.replaceAll('}\\\\sqrt{', '}\\\\cdot\\\\sqrt{');\r\n            const value = evaluatex(expression, variables)();\r\n            if (value) {\r\n                values.push(_index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`f_{${this.graphId}${axis}${String.fromCharCode(97 + i)}}(${input[inputAxis].reference})`, value));\r\n            }\r\n        }\r\n        return { min: (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(values), max: (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(values) };\r\n    }\r\n    getRealBounds() {\r\n        const { graphId } = this;\r\n        let { xMin, yMin, xMax, yMax } = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let [newXMin, newXMax, newYMin, newYMax] = [\r\n            _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(-Infinity), _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(Infinity), _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(-Infinity), _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(Infinity),\r\n        ];\r\n        const { specialPoints, cropPoints } = this.getEndpoints();\r\n        const points = [...specialPoints, ...cropPoints];\r\n        const innerPoints = points.filter((point) => (xMin.value <= point.x.value)\r\n            && (point.x.value <= xMax.value)\r\n            && (yMin.value <= point.y.value)\r\n            && (point.y.value <= yMax.value));\r\n        const x1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const x2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.x));\r\n        const y1 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)(innerPoints.map((point) => point.y));\r\n        const y2 = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)(innerPoints.map((point) => point.y));\r\n        if (y1 !== undefined && y2 !== undefined) {\r\n            newYMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([y1, newYMin]);\r\n            newYMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([y2, newYMax]);\r\n        }\r\n        if (x1 !== undefined && x2 !== undefined) {\r\n            newXMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([x1, newXMin]);\r\n            newXMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([x2, newXMax]);\r\n        }\r\n        xMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([xMin, newXMin]);\r\n        yMin = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.maxLinkedVariable)([yMin, newYMin]);\r\n        xMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([xMax, newXMax]);\r\n        yMax = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.minLinkedVariable)([yMax, newYMax]);\r\n        return { xMin, yMin, xMax, yMax };\r\n    }\r\n    convertToY() {\r\n        const { graphType } = this;\r\n        const latexList = _constants__WEBPACK_IMPORTED_MODULE_0__.yExpressions[graphType];\r\n        const newLatexList = [];\r\n        for (let i = 0; i < latexList.length; i++) {\r\n            const latex = latexList[i].replaceAll('_{1', `_{${this.graphId}`);\r\n            newLatexList.push(latex);\r\n        }\r\n        return newLatexList;\r\n    }\r\n    convertToX() {\r\n        const { graphType } = this;\r\n        const latexList = _constants__WEBPACK_IMPORTED_MODULE_0__.xExpressions[graphType];\r\n        const newLatexList = [];\r\n        for (let i = 0; i < latexList.length; i++) {\r\n            const latex = latexList[i].replaceAll('_{1', `_{${this.graphId}`);\r\n            newLatexList.push(latex);\r\n        }\r\n        return newLatexList;\r\n    }\r\n    getClosestEndpoint(point) {\r\n        const endpoints = this.getEndpoints().cropPoints;\r\n        const currEndPoint = {\r\n            endpoint: null,\r\n            currMinSqrMagnitude: Infinity,\r\n        };\r\n        endpoints.forEach((endpoint) => {\r\n            const sqrMagnitude = (endpoint.x.value - point.x) ** 2 + (endpoint.y.value - point.y) ** 2;\r\n            if (sqrMagnitude < currEndPoint.currMinSqrMagnitude) {\r\n                currEndPoint.endpoint = endpoint;\r\n                currEndPoint.currMinSqrMagnitude = sqrMagnitude;\r\n            }\r\n        });\r\n        if (currEndPoint.endpoint) {\r\n            return currEndPoint.endpoint;\r\n        }\r\n        throw Error('No endpoint found');\r\n    }\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/classes/Graph.ts?");

/***/ }),

/***/ "./src/conicLib.ts":
/*!*************************!*\
  !*** ./src/conicLib.ts ***!
  \*************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"getConicFit\": () => (/* binding */ getConicFit)\n/* harmony export */ });\n/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ml-matrix */ \"./node_modules/ml-matrix/src/matrix.js\");\n/* harmony import */ var ml_matrix__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ml-matrix */ \"./node_modules/ml-matrix/src/dc/evd.js\");\n\r\nfunction getConicFit(points) {\r\n    const _x = points.map(point => point.x);\r\n    const _y = points.map(point => point.y);\r\n    const x = new ml_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([_x]).transpose();\r\n    const y = new ml_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([_y]).transpose();\r\n    const dMatrix = new ml_matrix__WEBPACK_IMPORTED_MODULE_0__[\"default\"]([\r\n        x.mul(x).getColumn(0),\r\n        y.mul(y).getColumn(0),\r\n        _x,\r\n        _y,\r\n        Array.from(Array(y.rows)).map(_ => 1)\r\n    ]);\r\n    const D_2 = dMatrix.mmul(dMatrix.transpose());\r\n    const eigen = new ml_matrix__WEBPACK_IMPORTED_MODULE_1__[\"default\"](D_2);\r\n    const minEigenvalue = Math.min(...eigen.realEigenvalues);\r\n    const minEigenvalueIndex = eigen.realEigenvalues.findIndex(x => x == minEigenvalue);\r\n    let [A, C, D, E, F] = eigen.eigenvectorMatrix.getColumn(minEigenvalueIndex);\r\n    const r = Math.sqrt(A ** 2 + C ** 2);\r\n    A = A / r;\r\n    C = C / r;\r\n    D = D / r;\r\n    E = E / r;\r\n    F = F / r;\r\n    return {\r\n        A,\r\n        B: 0,\r\n        C,\r\n        D,\r\n        E,\r\n        F,\r\n    };\r\n}\r\n// const {A, C, D, E, F} = (getConicFit([\r\n//   {x: -3, y: 3},\r\n//   {x: -3, y: 4},\r\n//   {x: -2, y: 6},\r\n//   {x: -3, y: 7},\r\n//   {x: -6, y: 9},\r\n//   {x: -7, y: 8},\r\n//   {x: -9, y: 7},\r\n//   {x: -10, y: 4},\r\n//   {x: -9, y: 2},\r\n//   {x: -7, y: 1},\r\n// ]))\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/conicLib.ts?");

/***/ }),

/***/ "./src/constants.ts":
/*!**************************!*\
  !*** ./src/constants.ts ***!
  \**************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"defaultExpressionFormat\": () => (/* binding */ defaultExpressionFormat),\n/* harmony export */   \"yExpressions\": () => (/* binding */ yExpressions),\n/* harmony export */   \"xExpressions\": () => (/* binding */ xExpressions),\n/* harmony export */   \"yExpressionsEval\": () => (/* binding */ yExpressionsEval),\n/* harmony export */   \"xExpressionsEval\": () => (/* binding */ xExpressionsEval)\n/* harmony export */ });\nconst defaultExpressionFormat = [\r\n    { latex: '\\\\left(x_{1cb},y_{1ca}+\\\\left(y_{1cb}-y_{1ca}\\\\right)t\\\\right)', types: ['segment', 'delete', 'hide', 'y'] },\r\n    { latex: '\\\\left(x_{1ca},y_{1ca}+\\\\left(y_{1cb}-y_{1ca}\\\\right)t\\\\right)', types: ['segment', 'delete', 'hide', 'y'] },\r\n    { latex: '\\\\left(x_{1ca}+\\\\left(x_{1cb}-x_{1ca}\\\\right)t,y_{1ca}\\\\right)', types: ['segment', 'delete', 'hide', 'x'] },\r\n    { latex: '\\\\left(x_{1ca}+\\\\left(x_{1cb}-x_{1ca}\\\\right)t,y_{1cb}\\\\right)', types: ['segment', 'delete', 'hide', 'x'] },\r\n    { latex: '\\\\left(x_{1cam}+\\\\operatorname{sgn}(h_{1})\\\\operatorname{abs}(h_{1}),y_{1cam}+\\\\operatorname{sgn}(k_{1})\\\\operatorname{abs}(k_{1})\\\\right)', types: ['point', 'delete', 'hide', 'xy'] },\r\n    { latex: '\\\\left(x_{1cbm}+\\\\operatorname{sgn}(h_{1})\\\\operatorname{abs}(h_{1}),y_{1cbm}+\\\\operatorname{sgn}(k_{1})\\\\operatorname{abs}(k_{1})\\\\right)', types: ['point', 'delete', 'hide', 'xy'] },\r\n    { latex: 'x_{1ca}=x_{1cam}+h_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'y_{1ca}=y_{1cam}+k_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'x_{1cb}=x_{1cbm}+h_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'y_{1cb}=y_{1cbm}+k_{1}', types: ['helper_var', 'delete'] },\r\n    { latex: 'x_{1cam}=0', types: ['var', 'delete'] },\r\n    { latex: 'y_{1cam}=0', types: ['var', 'delete'] },\r\n    { latex: 'x_{1cbm}=0', types: ['var', 'delete'] },\r\n    { latex: 'y_{1cbm}=0', types: ['var', 'delete'] },\r\n];\r\nconst yExpressions = [\r\n    ['k_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}', 'k_{1}+\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}'],\r\n    ['k_{1}+\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['k_{1}-\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['m_{1}x+b_{1}'],\r\n    []\r\n];\r\nconst xExpressions = [\r\n    ['h_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}+\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['h_{1}-\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}', 'h_{1}+\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}', 'h_{1}+\\\\frac{b_{1}}{a_{1}}\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['\\\\frac{\\\\left(y-b_{1}\\\\right)}{m_{1}}'],\r\n    []\r\n];\r\nconst yExpressionsEval = [\r\n    ['k_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}', 'k_{1}+\\\\sqrt{4c_{1}\\\\left(x-h_{1}\\\\right)}'],\r\n    ['k_{1}+\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{a_{1}^{2}-\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['k_{1}-\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}', 'k_{1}+\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(x-h_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['k_{1}-\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}', 'k_{1}+\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(x-h_{1}\\\\right)^{2}}'],\r\n    ['m_{1}\\\\cdot x+b_{1}'],\r\n];\r\nconst xExpressionsEval = [\r\n    ['h_{1}-\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\sqrt{r_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}+\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{4c_{1}}'],\r\n    ['h_{1}-\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}', 'h_{1}+\\\\sqrt{4c_{1}\\\\left(y-k_{1}\\\\right)}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}-\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}', 'h_{1}+\\\\frac{a_{1}}{b_{1}}\\\\cdot\\\\sqrt{b_{1}^{2}+\\\\left(y-k_{1}\\\\right)^{2}}'],\r\n    ['h_{1}-\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}', 'h_{1}+\\\\frac{b_{1}}{a_{1}}\\\\cdot\\\\sqrt{\\\\left(y-k_{1}\\\\right)^{2}-a_{1}^{2}}'],\r\n    ['\\\\frac{\\\\left(y-b_{1}\\\\right)}{m_{1}}'],\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/constants.ts?");

/***/ }),

/***/ "./src/graphs/Bezier.ts":
/*!******************************!*\
  !*** ./src/graphs/Bezier.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Bezier\": () => (/* binding */ Bezier)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n/* harmony import */ var _bezierLib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../bezierLib */ \"./src/bezierLib.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n\r\n\r\n\r\n\r\n\r\nclass Bezier extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 7);\r\n    }\r\n    convertToStandard() {\r\n        const { xa, ya, xb, yb, xc, yc, xd, yd } = this.getGraphVariables();\r\n        const criticalPoints = (0,_bezierLib__WEBPACK_IMPORTED_MODULE_3__.getCriticalPoints)({ x: xa.value, y: ya.value }, { x: xb.value, y: yb.value }, { x: xc.value, y: yc.value }, { x: xd.value, y: yd.value });\r\n        return '';\r\n    }\r\n    static fromGeneral(variable) {\r\n        throw Error(\"Tried to convert General Conic to Bezier\");\r\n    }\r\n    getGraphVariables() {\r\n        const { graphId } = this;\r\n        const xa = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}xa}`);\r\n        const xb = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}xb}`);\r\n        const xc = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}xc}`);\r\n        const xd = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}xd}`);\r\n        const ya = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}ya}`);\r\n        const yb = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}yb}`);\r\n        const yc = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}yc}`);\r\n        const yd = _index_user__WEBPACK_IMPORTED_MODULE_1__.MyCalc.linkedVariable(`p_{${graphId}yd}`);\r\n        return { xa, ya, xb, yb, xc, yc, xd, yd };\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getGraphVariables();\r\n        const { xa, ya, xb, yb, xc, yc, xd, yd } = variables;\r\n        points = [\r\n            { x: xa, y: ya },\r\n            { x: xb, y: yb },\r\n            { x: xc, y: yc },\r\n            { x: xd, y: yd },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: [],\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_2__.getVariable)(`h_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (h < xMax.value)\r\n                relevantIndices.push(1);\r\n            if (xMin.value < h)\r\n                relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        const [xa, ya, xb, yb, xc, yc, xd, yd] = variables;\r\n        return { xa, ya, xb, yb, xc, yc, xd, yd };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { xa, ya, xb, yb, xc, yc, xd, yd } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}xb}`, xb);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}xa}`, xa);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}xc}`, xc);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}xd}`, xd);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}ya}`, ya);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}yb}`, yb);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}yc}`, yc);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${graphId}yd}`, yd);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}xa}`, expressionPos.x + size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}ya}`, expressionPos.y + size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}xb}`, expressionPos.x + size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}yb}`, expressionPos.y + size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}xc}`, expressionPos.x + size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}yc}`, expressionPos.y + size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}xd}`, expressionPos.x + size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_2__.setVariable)(`p_{${id}yd}`, expressionPos.y + size * 0.3);\r\n    }\r\n    getControlPoints() {\r\n        const { xa, ya, xb, yb, xc, yc, xd, yd } = this.getGraphVariables();\r\n        return {\r\n            p1: {\r\n                x: xa.value,\r\n                y: ya.value,\r\n            },\r\n            p2: {\r\n                x: xb.value,\r\n                y: yb.value,\r\n            },\r\n            p3: {\r\n                x: xc.value,\r\n                y: yc.value,\r\n            },\r\n            p4: {\r\n                x: xd.value,\r\n                y: yd.value,\r\n            }\r\n        };\r\n    }\r\n}\r\nBezier.hasCenter = false;\r\nBezier.hasCrop = false;\r\nBezier.isConic = false;\r\nBezier.hasGeneralForm = false;\r\nBezier.graphType = 7;\r\nBezier.expressionFormat = [\r\n    { latex: `(B_{1x}(t),B_{1y}(t))`, types: ['graph'] },\r\n    { latex: `B_{1x}(t)=(1-t)^{3}p_{1xa}+3t(1-t)^{2}p_{1xb}+3t^{2}(1-t)p_{1xc}+t^{3}p_{1xd}`, types: ['function', 'hidden'] },\r\n    { latex: `B_{1y}(t)=(1-t)^{3}p_{1ya}+3t(1-t)^{2}p_{1yb}+3t^{2}(1-t)p_{1yc}+t^{3}p_{1yd}`, types: ['function', 'hidden'] },\r\n    { latex: `p_{1xa}=0`, types: ['var'] },\r\n    { latex: `p_{1xb}=0`, types: ['var'] },\r\n    { latex: `p_{1xc}=0`, types: ['var'] },\r\n    { latex: `p_{1xd}=0`, types: ['var'] },\r\n    { latex: `p_{1ya}=0`, types: ['var'] },\r\n    { latex: `p_{1yb}=0`, types: ['var'] },\r\n    { latex: `p_{1yc}=0`, types: ['var'] },\r\n    { latex: `p_{1yd}=0`, types: ['var'] },\r\n    { latex: `(p_{1xa},p_{1ya})`, types: ['point'] },\r\n    { latex: `(p_{1xb},p_{1yb})`, types: ['point'] },\r\n    { latex: `(p_{1xc},p_{1yc})`, types: ['point'] },\r\n    { latex: `(p_{1xd},p_{1yd})`, types: ['point'] },\r\n    { latex: `(p_{1xa}+t(p_{1xb}-p_{1xa}),p_{1ya}+t(p_{1yb}-p_{1ya}))`, types: ['handle'] },\r\n    { latex: `(p_{1xd}+t(p_{1xc}-p_{1xd}),p_{1yd}+t(p_{1yc}-p_{1yd}))`, types: ['handle'] },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_4__.yExpressions[7].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_4__.xExpressions[7].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/Bezier.ts?");

/***/ }),

/***/ "./src/graphs/Circle.ts":
/*!******************************!*\
  !*** ./src/graphs/Circle.ts ***!
  \******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Circle\": () => (/* binding */ Circle)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\n\r\nclass Circle extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 0);\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${this.graphId}}`);\r\n        const r = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`r_{${this.graphId}}`);\r\n        const A = 1;\r\n        const C = 1;\r\n        const D = -2 * h;\r\n        const E = -2 * k;\r\n        const F = k ** 2 + h ** 2 - r ** 2;\r\n        return { A, B: 0, C, D, E, F };\r\n    }\r\n    getData() {\r\n        const graphType = this.graphType;\r\n        const variables = this.getGraphVariables();\r\n        const bounds = this.getBounds();\r\n        const data = {\r\n            graphType, variables, bounds\r\n        };\r\n    }\r\n    static fromGeneral(variable) {\r\n        const { A, C, D, E, F } = variable;\r\n        const h = -D / (2 * A);\r\n        const k = -E / (2 * C);\r\n        const r = Math.sqrt(k ** 2 + h ** 2 - F);\r\n        return { h, k, r };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const r = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`r_{${graphId}}`);\r\n        return { h, k, r };\r\n    }\r\n    getGraphVariables() {\r\n        return this.getConicVariables();\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        const r2 = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`r_{${currId}}`) ** 2;\r\n        latex = latex.replace(`r_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_3__.simplify)(r2, 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_3__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, r } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${h.reference}-${r.reference}`, h.value - r.value), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${k.reference}-${r.reference}`, k.value - r.value) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${h.reference}+${r.reference}`, h.value + r.value), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${k.reference}+${r.reference}`, k.value + r.value) },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (h < xMax.value)\r\n                relevantIndices.push(1);\r\n            if (xMin.value < h)\r\n                relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            if (k < yMax.value)\r\n                relevantIndices.push(1);\r\n            if (yMin.value < k)\r\n                relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, k, r] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        r = Math.sqrt(Math.abs(r));\r\n        return { h, k, r };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, r } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${graphId}}`, r);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${graphId}}`, '0');\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`r_{${graphId}}`, r);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${id}}`, 0);\r\n    }\r\n}\r\nCircle.hasCenter = true;\r\nCircle.hasCrop = true;\r\nCircle.graphType = 0;\r\nCircle.isConic = true;\r\nCircle.hasGeneralForm = true;\r\nCircle.expressionFormat = [\r\n    { latex: '\\\\left(x-h_{1}\\\\right)^{2}+\\\\left(y-k_{1}\\\\right)^{2}=r_{1}^{2}', types: ['graph'], name: 'graph' },\r\n    { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1}+a_{1},k_{1}+b_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: 'r_{1}=\\\\sqrt{a_{1}^{2}+b_{1}^{2}}', types: ['helper_var'], name: 'r' },\r\n    { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n    { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n    { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n    { latex: 'b_{1}=0', types: ['var'], name: 'b' },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.defaultExpressionFormat,\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.yExpressions[0].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.xExpressions[0].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/Circle.ts?");

/***/ }),

/***/ "./src/graphs/Ellipse.ts":
/*!*******************************!*\
  !*** ./src/graphs/Ellipse.ts ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Ellipse\": () => (/* binding */ Ellipse)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\n\r\nclass Ellipse extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 3);\r\n    }\r\n    static fromGeneral(variable) {\r\n        let { A, C, D, E, F } = variable;\r\n        if (A < 0) {\r\n            A = -A;\r\n            C = -C;\r\n            D = -D;\r\n            E = -E;\r\n            F = -F;\r\n        }\r\n        const h = -D / (2 * A);\r\n        const k = -E / (2 * C);\r\n        const b = Math.sqrt((A * h ** 2 + C * k ** 2 - F) / C);\r\n        const a = Math.sqrt((A * h ** 2 + C * k ** 2 - F) / A);\r\n        return { h, k, a, b };\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${this.graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = b ** 2;\r\n        const C = a ** 2;\r\n        const D = -2 * h * b ** 2;\r\n        const E = -2 * k * a ** 2;\r\n        const F = b ** 2 * h ** 2 + a ** 2 * k ** 2 - a ** 2 * b ** 2;\r\n        return { A, B: 0, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const a = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`a_{${graphId}}`);\r\n        const b = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`b_{${graphId}}`);\r\n        return { h, k, a, b };\r\n    }\r\n    getGraphVariables() {\r\n        return this.getConicVariables();\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${currId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`b_{${currId}}`);\r\n        const a2 = a ** 2;\r\n        const b2 = b ** 2;\r\n        latex = latex.replace(`a_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_3__.simplify)(a2, 4));\r\n        latex = latex.replace(`b_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_3__.simplify)(b2, 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_3__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, a, b } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${h.reference}-${a.reference}`, h.value - a.value), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${k.reference}-${b.reference}`, k.value - b.value) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${h.reference}+${a.reference}`, h.value + a.value), y: k },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${k.reference}+${b.reference}`, k.value + b.value) },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (h < xMax.value)\r\n                relevantIndices.push(1);\r\n            if (xMin.value < h)\r\n                relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            if (k < yMax.value)\r\n                relevantIndices.push(1);\r\n            if (yMin.value < k)\r\n                relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, a, k, b] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        a = Math.sqrt(Math.abs(a));\r\n        b = Math.sqrt(Math.abs(b));\r\n        return { h, a, k, b };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, a, b } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${graphId}}`, a);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${graphId}}`, b);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${id}}`, size * 0.2);\r\n    }\r\n}\r\nEllipse.hasCenter = true;\r\nEllipse.hasCrop = true;\r\nEllipse.graphType = 3;\r\nEllipse.isConic = true;\r\nEllipse.hasGeneralForm = true;\r\nEllipse.expressionFormat = [\r\n    { latex: '\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{a_{1}^{2}}+\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{b_{1}^{2}}=1', types: ['graph'] },\r\n    { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1}+a_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1},k_{1}+b_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: 'k_{1}=0', types: ['var'], name: 'h' },\r\n    { latex: 'h_{1}=0', types: ['var'], name: 'k' },\r\n    { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n    { latex: 'b_{1}=1', types: ['var'], name: 'b' },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.defaultExpressionFormat,\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.yExpressions[3].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.xExpressions[3].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/Ellipse.ts?");

/***/ }),

/***/ "./src/graphs/HorizontalHyperbola.ts":
/*!*******************************************!*\
  !*** ./src/graphs/HorizontalHyperbola.ts ***!
  \*******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HorizontalHyperbola\": () => (/* binding */ HorizontalHyperbola)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\n\r\nclass HorizontalHyperbola extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 4);\r\n    }\r\n    static fromGeneral(variable) {\r\n        const { A, C, D, E, F } = variable;\r\n        const h = -D / (2 * A);\r\n        const k = -E / (2 * C);\r\n        const a = Math.sqrt((A * h ** 2 + C * k ** 2 - F) / A);\r\n        const b = Math.sqrt(-(A * h ** 2 + C * k ** 2 - F) / C);\r\n        return { h, k, a, b };\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${this.graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = b ** 2;\r\n        const C = -(a ** 2);\r\n        const D = -2 * h * b ** 2;\r\n        const E = 2 * k * a ** 2;\r\n        const F = b ** 2 * h ** 2 - a ** 2 * k ** 2 - a ** 2 * b ** 2;\r\n        return { A, B: 0, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const a = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`a_{${graphId}}`);\r\n        const b = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`b_{${graphId}}`);\r\n        return { h, k, a, b };\r\n    }\r\n    getGraphVariables() {\r\n        return this.getConicVariables();\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${currId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`b_{${currId}}`);\r\n        const a2 = a ** 2;\r\n        const b2 = b ** 2;\r\n        latex = latex.replace(`a_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_3__.simplify)(a2, 4));\r\n        latex = latex.replace(`b_{${currId}}^{2}`, (0,_lib__WEBPACK_IMPORTED_MODULE_3__.simplify)(b2, 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.substitute)(latex);\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, a, b } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${h.reference}-${a.reference}`, h.value - a.value), y: k },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${h.reference}+${a.reference}`, h.value + a.value), y: k },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${graphId}}`);\r\n        // const b = getVariable(`b_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (xMax.value < h + a)\r\n                relevantIndices.push(0);\r\n            if (xMin.value > h - a)\r\n                relevantIndices.push(1);\r\n        }\r\n        if (axis === 'y') {\r\n            if (yMax.value < k)\r\n                relevantIndices.push(0);\r\n            if (yMin.value > k)\r\n                relevantIndices.push(1);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, a, k, b] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        a = Math.sqrt(Math.abs(a));\r\n        b = Math.sqrt(Math.abs(b));\r\n        return { h, k, a, b };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, a, b } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${graphId}}`, a);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${graphId}}`, b);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${id}}`, size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${id}}`, size * 0.2);\r\n    }\r\n}\r\nHorizontalHyperbola.hasCenter = true;\r\nHorizontalHyperbola.hasCrop = true;\r\nHorizontalHyperbola.graphType = 4;\r\nHorizontalHyperbola.isConic = true;\r\nHorizontalHyperbola.hasGeneralForm = true;\r\nHorizontalHyperbola.expressionFormat = [\r\n    { latex: '\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{a_{1}^{2}}-\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{b_{1}^{2}}=1', types: ['graph'] },\r\n    { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1}+a_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1}+\\\\sqrt{2}a_{1},k_{1}+b_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n    { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n    { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n    { latex: 'b_{1}=1', types: ['var'], name: 'b' },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.defaultExpressionFormat,\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.yExpressions[4].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.xExpressions[4].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/HorizontalHyperbola.ts?");

/***/ }),

/***/ "./src/graphs/HorizontalParabola.ts":
/*!******************************************!*\
  !*** ./src/graphs/HorizontalParabola.ts ***!
  \******************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"HorizontalParabola\": () => (/* binding */ HorizontalParabola)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\n\r\nclass HorizontalParabola extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 1);\r\n    }\r\n    static fromGeneral(variable) {\r\n        const { A, C, D, E, F } = variable;\r\n        const c = -D / (4 * C);\r\n        const k = -E / (2 * C);\r\n        const h = (F - C * k ** 2) / (4 * c * C);\r\n        return { h, k, c };\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${this.graphId}}`);\r\n        const c = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`c_{${this.graphId}}`);\r\n        const A = 0;\r\n        const C = 1;\r\n        const D = -4 * c;\r\n        const E = -2 * k;\r\n        const F = 4 * c * h + k ** 2;\r\n        return { A, B: 0, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const c = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`c_{${graphId}}`);\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        return { h, k, c };\r\n    }\r\n    getGraphVariables() {\r\n        return this.getConicVariables();\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        latex = latex.replace(`4c_{${currId}}`, (0,_lib__WEBPACK_IMPORTED_MODULE_3__.simplify)(4 * (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`c_{${currId}}`), 4));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_3__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, c } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(-Infinity) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(Infinity) },\r\n            { x: h, y: k },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            if (k < yMax.value)\r\n                relevantIndices.push(1);\r\n            if (yMin.value < k)\r\n                relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [k, c, h] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        c /= 4;\r\n        return { h, k, c };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        let { k, c, h } = variables;\r\n        if (h instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            h = h.value;\r\n        if (c instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            c = c.value;\r\n        if (k instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            k = k.value;\r\n        const d = Math.sign(c) / 4;\r\n        const e = Math.sqrt(Math.abs(c));\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`d_{${graphId}}`, d);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`q_{${graphId}}`, e);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`c_{${graphId}}`, c);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`q_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`d_{${id}}`, size * 0.3);\r\n    }\r\n}\r\nHorizontalParabola.hasCenter = true;\r\nHorizontalParabola.hasCrop = true;\r\nHorizontalParabola.graphType = 1;\r\nHorizontalParabola.isConic = true;\r\nHorizontalParabola.hasGeneralForm = true;\r\nHorizontalParabola.expressionFormat = [\r\n    { latex: '\\\\left(y-k_{1}\\\\right)^{2}=4c_{1}\\\\left(x-h_{1}\\\\right)', types: ['graph'] },\r\n    { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1}+d_{1},k_{1}+q_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n    { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n    { latex: 'q_{1}=1', types: ['var'], name: 'e' },\r\n    { latex: 'd_{1}=1', types: ['var'], name: 'd' },\r\n    { latex: 'c_{1}=\\\\frac{q_{1}^{2}}{4d_{1}}', types: ['helper_var'], name: 'c' },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.defaultExpressionFormat,\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.yExpressions[1].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.xExpressions[1].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/HorizontalParabola.ts?");

/***/ }),

/***/ "./src/graphs/LineSegment.ts":
/*!***********************************!*\
  !*** ./src/graphs/LineSegment.ts ***!
  \***********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LineSegment\": () => (/* binding */ LineSegment)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\n\r\nclass LineSegment extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 6);\r\n    }\r\n    static fromGeneral(variable) {\r\n        const { A, C, D, E, F } = variable;\r\n        const m = D;\r\n        const b = F;\r\n        return { m, b };\r\n    }\r\n    getGeneralForm() {\r\n        const m = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`m_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = 0;\r\n        const C = 0;\r\n        const D = m;\r\n        const E = 0;\r\n        const F = b;\r\n        return { A, B: 0, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const x1 = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`x_{${graphId}a}`);\r\n        const x2 = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`x_{${graphId}b}`);\r\n        const y1 = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`y_{${graphId}a}`);\r\n        const y2 = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`y_{${graphId}b}`);\r\n        return { x1, x2, y1, y2 };\r\n    }\r\n    getGraphVariables() {\r\n        return this.getConicVariables();\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.substitute)(latex);\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getDomains)(graphId);\r\n        const points = [];\r\n        const variables = this.getConicVariables();\r\n        const { x1, x2, y1, y2 } = variables;\r\n        const xa = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.minMax)([x1, x2]);\r\n        const xb = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.minMax)([x1, x2]);\r\n        const ya = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.minMax)([y1, y2]);\r\n        const yb = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.minMax)([y1, y2]);\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, { xa, xb, ya, yb }),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        relevantIndices.push(0);\r\n        return relevantIndices;\r\n    }\r\n    getRealBounds() {\r\n        const { x1, x2, y1, y2 } = this.getGraphVariables();\r\n        const xMin = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.minLinkedVariable)([x1, x2]);\r\n        const yMin = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.minLinkedVariable)([y1, y2]);\r\n        const xMax = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.maxLinkedVariable)([x1, x2]);\r\n        const yMax = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.maxLinkedVariable)([y1, y2]);\r\n        return { xMin, yMin, xMax, yMax };\r\n    }\r\n    static transformVariables(variables) {\r\n        const [m, b, x1, x2] = variables;\r\n        return { m, b, x1, x2 };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        let { m, b, x1, x2 } = variables;\r\n        if (m instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            m = m.value;\r\n        if (b instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            b = b.value;\r\n        if (x1 instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            x1 = x1.value;\r\n        if (x2 instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            x2 = x2.value;\r\n        const y1 = m * x1 + b;\r\n        const y2 = m * x2 + b;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`x_{${graphId}a}`, x1.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`y_{${graphId}a}`, y1.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`x_{${graphId}b}`, x2.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`y_{${graphId}b}`, y2.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`m_{${graphId}}`, m.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${graphId}}`, b.toString());\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`x_{${id}a}`, expressionPos.x - size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`y_{${id}a}`, expressionPos.y - size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`x_{${id}b}`, expressionPos.x + size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`y_{${id}b}`, expressionPos.y + size * 0.2);\r\n    }\r\n}\r\nLineSegment.hasCenter = false;\r\nLineSegment.hasCrop = false;\r\nLineSegment.graphType = 6;\r\nLineSegment.isConic = true;\r\nLineSegment.hasGeneralForm = true;\r\nLineSegment.expressionFormat = [\r\n    { latex: 'y=m_{1}x+b_{1}\\\\left\\\\{x_{1ca}<x<x_{1cb}\\\\right\\\\}', types: ['graph'] },\r\n    { latex: '\\\\left(x_{1a},y_{1a}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(x_{1b},y_{1b}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: 'x_{1ca}=\\\\min\\\\left(x_{1a},x_{1b}\\\\right)', types: ['helper_var'] },\r\n    { latex: 'x_{1cb}=\\\\max\\\\left(x_{1a},x_{1b}\\\\right)', types: ['helper_var'] },\r\n    { latex: 'm_{1}=\\\\frac{\\\\left(y_{1b}-y_{1a}\\\\right)}{\\\\left(x_{1b}-x_{1a}\\\\right)}', types: ['helper_var'] },\r\n    { latex: 'b_{1}=y_{1a}-\\\\frac{\\\\left(y_{1b}-y_{1a}\\\\right)x_{1a}}{\\\\left(x_{1b}-x_{1a}\\\\right)}', types: ['helper_var'] },\r\n    { latex: 'y_{1a}=0', types: ['var'], name: 'ya' },\r\n    { latex: 'y_{1b}=1', types: ['var'], name: 'yb' },\r\n    { latex: 'x_{1a}=0', types: ['var'], name: 'xa' },\r\n    { latex: 'x_{1b}=1', types: ['var'], name: 'xb' },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.yExpressions[6].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.xExpressions[6].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n    { latex: 'y_{1ca}=m_{1}x_{1ca}+b_{1}', types: ['helper_var'] },\r\n    { latex: 'y_{1cb}=m_{1}x_{1cb}+b_{1}', types: ['helper_var'] },\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/LineSegment.ts?");

/***/ }),

/***/ "./src/graphs/VerticalHyperbola.ts":
/*!*****************************************!*\
  !*** ./src/graphs/VerticalHyperbola.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VerticalHyperbola\": () => (/* binding */ VerticalHyperbola)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\n\r\nclass VerticalHyperbola extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 5);\r\n    }\r\n    static fromGeneral(variable) {\r\n        const { A, C, D, E, F } = variable;\r\n        const h = -D / (2 * A);\r\n        const k = -E / (2 * C);\r\n        const a = Math.sqrt((A * h ** 2 + C * k ** 2 - F) / C);\r\n        const b = Math.sqrt(-(A * h ** 2 + C * k ** 2 - F) / A);\r\n        return { h, k, a, b };\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${this.graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${this.graphId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`b_{${this.graphId}}`);\r\n        const A = -(a ** 2);\r\n        const C = b ** 2;\r\n        const D = 2 * h * a ** 2;\r\n        const E = -2 * k * b ** 2;\r\n        const F = b ** 2 * k ** 2 - a ** 2 * h ** 2 - a ** 2 * b ** 2;\r\n        return { A, B: 0, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        const a = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`a_{${graphId}}`);\r\n        const b = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`b_{${graphId}}`);\r\n        return { h, k, a, b };\r\n    }\r\n    getGraphVariables() {\r\n        return this.getConicVariables();\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${currId}}`);\r\n        const b = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`b_{${currId}}`);\r\n        const a2 = a ** 2;\r\n        const b2 = b ** 2;\r\n        latex = latex.replace(`a_{${currId}}^{2}`, a2.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.precision));\r\n        latex = latex.replace(`b_{${currId}}^{2}`, b2.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.precision));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.substitute)(latex);\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, a, b } = variables;\r\n        points = [\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${k.reference}-${b.reference}`, k.value - b.value) },\r\n            { x: h, y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`${k.reference}+${b.reference}`, k.value + b.value) },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${graphId}}`);\r\n        const a = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`a_{${graphId}}`);\r\n        // const b = getVariable(`b_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (yMax.value < h)\r\n                relevantIndices.push(0);\r\n            if (yMin.value > h)\r\n                relevantIndices.push(1);\r\n        }\r\n        if (axis === 'y') {\r\n            if (yMax.value < k + a)\r\n                relevantIndices.push(0);\r\n            if (yMin.value > k - a)\r\n                relevantIndices.push(1);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [k, a, h, b] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        a = Math.sqrt(Math.abs(a));\r\n        b = Math.sqrt(Math.abs(b));\r\n        return { h, k, a, b };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        const { h, k, a, b } = variables;\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${graphId}}`, a);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${graphId}}`, b);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`a_{${id}}`, size * 0.2);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`b_{${id}}`, size * 0.2);\r\n    }\r\n}\r\nVerticalHyperbola.hasCenter = true;\r\nVerticalHyperbola.hasCrop = true;\r\nVerticalHyperbola.graphType = 5;\r\nVerticalHyperbola.isConic = true;\r\nVerticalHyperbola.hasGeneralForm = true;\r\nVerticalHyperbola.expressionFormat = [\r\n    { latex: '\\\\frac{\\\\left(y-k_{1}\\\\right)^{2}}{a_{1}^{2}}-\\\\frac{\\\\left(x-h_{1}\\\\right)^{2}}{b_{1}^{2}}=1', types: ['graph'] },\r\n    { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1},k_{1}+a_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1}+b_{1},k_{1}+\\\\sqrt{2}a_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n    { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n    { latex: 'a_{1}=1', types: ['var'], name: 'a' },\r\n    { latex: 'b_{1}=1', types: ['var'], name: 'b' },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.defaultExpressionFormat,\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.yExpressions[5].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.xExpressions[5].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/VerticalHyperbola.ts?");

/***/ }),

/***/ "./src/graphs/VerticalParabola.ts":
/*!****************************************!*\
  !*** ./src/graphs/VerticalParabola.ts ***!
  \****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"VerticalParabola\": () => (/* binding */ VerticalParabola)\n/* harmony export */ });\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../constants */ \"./src/constants.ts\");\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../lib */ \"./src/lib.ts\");\n\r\n\r\n\r\n\r\nclass VerticalParabola extends _classes_Graph__WEBPACK_IMPORTED_MODULE_0__.Graph {\r\n    constructor(expression) {\r\n        super(expression, 2);\r\n    }\r\n    static fromGeneral(variable) {\r\n        const { A, C, D, E, F } = variable;\r\n        const h = -D / (2 * A);\r\n        const c = -E / (4 * A);\r\n        const k = (F - A * h ** 2) / (4 * c * A);\r\n        return { h, k, c };\r\n    }\r\n    getGeneralForm() {\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${this.graphId}}`);\r\n        const k = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`k_{${this.graphId}}`);\r\n        const c = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`c_{${this.graphId}}`);\r\n        const A = 1;\r\n        const C = 0;\r\n        const D = -2 * h;\r\n        const E = -4 * c;\r\n        const F = 4 * c * k + h ** 2;\r\n        return { A, B: 0, C, D, E, F };\r\n    }\r\n    getConicVariables() {\r\n        const { graphId } = this;\r\n        const c = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`c_{${graphId}}`);\r\n        const h = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`h_{${graphId}}`);\r\n        const k = _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(`k_{${graphId}}`);\r\n        return { h, k, c };\r\n    }\r\n    getGraphVariables() {\r\n        return this.getConicVariables();\r\n    }\r\n    convertToStandard() {\r\n        let { latex } = this;\r\n        const currId = this.graphId;\r\n        const { xMin, yMin, xMax, yMax } = this.getBounds();\r\n        latex = latex.replace(`4c_{${currId}}`, (4 * (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`c_{${currId}}`)).toFixed(_index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.precision));\r\n        latex = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.substitute)(latex);\r\n        latex = `${latex.split('\\\\left\\\\{')[0]}${(0,_lib__WEBPACK_IMPORTED_MODULE_3__.generateBounds)(xMin, yMin, xMax, yMax).value}`;\r\n        latex = latex.replaceAll('--', '+');\r\n        latex = latex.replaceAll('+-', '-');\r\n        return latex;\r\n    }\r\n    getEndpoints() {\r\n        const { graphId } = this;\r\n        const domains = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getDomains)(graphId);\r\n        let points = [];\r\n        const variables = this.getConicVariables();\r\n        const evaluations = this.evaluateBounds(variables, domains);\r\n        const { h, k, c } = variables;\r\n        points = [\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(-Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(Infinity) },\r\n            { x: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(Infinity), y: _index_user__WEBPACK_IMPORTED_MODULE_2__.MyCalc.linkedVariable(Infinity) },\r\n            { x: h, y: k },\r\n        ];\r\n        return {\r\n            specialPoints: points,\r\n            cropPoints: this.getBoundPoints(domains, evaluations),\r\n        };\r\n    }\r\n    getRelevant(axis) {\r\n        const { graphType, graphId } = this;\r\n        const { xMin, yMin, xMax, yMax } = this.getRealBounds();\r\n        const relevantIndices = [];\r\n        const h = (0,_lib__WEBPACK_IMPORTED_MODULE_3__.getVariable)(`h_{${graphId}}`);\r\n        if (axis === 'x') {\r\n            if (h < xMax.value)\r\n                relevantIndices.push(1);\r\n            if (xMin.value < h)\r\n                relevantIndices.push(0);\r\n        }\r\n        if (axis === 'y') {\r\n            relevantIndices.push(0);\r\n        }\r\n        return relevantIndices;\r\n    }\r\n    static transformVariables(variables) {\r\n        let [h, c, k] = variables;\r\n        h = -h;\r\n        k = -k;\r\n        c /= 4;\r\n        return { h, k, c };\r\n    }\r\n    static setGraphVariables(variables, graphId) {\r\n        let { h, c, k } = variables;\r\n        if (h instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            h = h.value;\r\n        if (c instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            c = c.value;\r\n        if (k instanceof _lib__WEBPACK_IMPORTED_MODULE_3__.LinkedVariable)\r\n            k = k.value;\r\n        const d = Math.sign(c) / 4;\r\n        const e = Math.sqrt(Math.abs(c));\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`h_{${graphId}}`, h);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`k_{${graphId}}`, k);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`d_{${graphId}}`, d);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`q_{${graphId}}`, e);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`c_{${graphId}}`, c);\r\n    }\r\n    static setDefault(id, expressionPos, size) {\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`q_{${id}}`, size * 0.3);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_3__.setVariable)(`d_{${id}}`, size * 0.3);\r\n    }\r\n}\r\nVerticalParabola.hasCenter = true;\r\nVerticalParabola.hasCrop = true;\r\nVerticalParabola.graphType = 2;\r\nVerticalParabola.isConic = true;\r\nVerticalParabola.hasGeneralForm = true;\r\nVerticalParabola.expressionFormat = [\r\n    { latex: '\\\\left(x-h_{1}\\\\right)^{2}=4c_{1}\\\\left(y-k_{1}\\\\right)', types: ['graph'] },\r\n    { latex: '\\\\left(h_{1},k_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: '\\\\left(h_{1}+q_{1},k_{1}+d_{1}\\\\right)', types: ['point', 'hide'] },\r\n    { latex: 'k_{1}=0', types: ['var'], name: 'k' },\r\n    { latex: 'h_{1}=0', types: ['var'], name: 'h' },\r\n    { latex: 'q_{1}=1', types: ['var'], name: 'e' },\r\n    { latex: 'd_{1}=1', types: ['var'], name: 'd' },\r\n    { latex: 'c_{1}=\\\\frac{q_{1}^{2}}{4d_{1}}', types: ['helper_var'], name: 'c' },\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.defaultExpressionFormat,\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.yExpressions[2].map((yExpression, c) => ({ latex: `f_{1y${String.fromCharCode(97 + c)}}(x)=${yExpression}`, types: ['y_expression'], name: `f_{1y${String.fromCharCode(97 + c)}}` })),\r\n    ..._constants__WEBPACK_IMPORTED_MODULE_1__.xExpressions[2].map((xExpression, c) => ({ latex: `f_{1x${String.fromCharCode(97 + c)}}(y)=${xExpression}`, types: ['x_expression'], name: `f_{1x${String.fromCharCode(97 + c)}}` })),\r\n];\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/graphs/VerticalParabola.ts?");

/***/ }),

/***/ "./src/index.user.ts":
/*!***************************!*\
  !*** ./src/index.user.ts ***!
  \***************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"MyCalc\": () => (/* binding */ MyCalc),\n/* harmony export */   \"createGraphWithBounds\": () => (/* binding */ createGraphWithBounds)\n/* harmony export */ });\n/* harmony import */ var _lib__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lib */ \"./src/lib.ts\");\n/* harmony import */ var _classes_Graph__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./classes/Graph */ \"./src/classes/Graph.ts\");\n/* harmony import */ var _MyCalc__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MyCalc */ \"./src/MyCalc.ts\");\n/* harmony import */ var _actions_finalize__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./actions/finalize */ \"./src/actions/finalize.ts\");\n/* harmony import */ var _actions_hideCropLines__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./actions/hideCropLines */ \"./src/actions/hideCropLines.ts\");\n// ==UserScript==\r\n// @name         Precal thing\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1.2\r\n// @description  precal thing\r\n// @author       You (not Watanabe)\r\n// @match        https://www.desmos.com/calculator*\r\n// @icon         https://www.google.com/s2/favicons?domain=desmos.com\r\n// @grant        unsafeWindow\r\n// @updateURL    https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js\r\n// @downloadURL  https://github.com/Auriga05/graph-art-creator/raw/master/index.user.js\r\n// @require      https://code.jquery.com/jquery-3.5.1.slim.min.js\r\n// @require      https://cdn.jsdelivr.net/npm/evaluatex@2.2.0/dist/evaluatex.min.js\r\n// ==/UserScript==\r\n\r\n\r\n\r\n\r\n\r\nfunction isGraph(expression) {\r\n    return expression.id.endsWith('_0') || expression.id.startsWith('final_');\r\n}\r\nlet MyCalc;\r\nfunction createGraphWithBounds(graphId, graphType, variables, _bounds, options) {\r\n    const logical = !!options?.logical;\r\n    let xMin = _bounds.xMin instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable ? _bounds.xMin.value : _bounds.xMin;\r\n    let yMin = _bounds.yMin instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable ? _bounds.yMin.value : _bounds.yMin;\r\n    let xMax = _bounds.xMax instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable ? _bounds.xMax.value : _bounds.xMax;\r\n    let yMax = _bounds.yMax instanceof _lib__WEBPACK_IMPORTED_MODULE_0__.LinkedVariable ? _bounds.yMax.value : _bounds.yMax;\r\n    let cropType = 0;\r\n    // 0 - default (x and y), 1 - x only, 2 - y only, 3 - no crop\r\n    if (!Number.isFinite(xMin) && !Number.isFinite(xMax)) { // Has no x domain\r\n        cropType += 2;\r\n    }\r\n    if (!Number.isFinite(yMin) && !Number.isFinite(yMax)) { // Has no y domain\r\n        cropType += 1;\r\n    }\r\n    let h = 0;\r\n    let k = 0;\r\n    const graphFormat = _lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].expressionFormat;\r\n    const expressionsToSet = [];\r\n    _lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].setGraphVariables(variables, graphId);\r\n    if (_lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].hasCenter) {\r\n        ({ h, k } = variables);\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cam}`, (xMin - h).toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cam}`, (yMin - k).toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cbm}`, (xMax - h).toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cbm}`, (yMax - k).toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}ca}`, xMin.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}ca}`, yMin.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cb}`, xMax.toString());\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cb}`, yMax.toString());\r\n    }\r\n    if (logical || options?.finalize) {\r\n        const newExpression = graphFormat[0];\r\n        let newExpressionLatex = newExpression.latex;\r\n        newExpressionLatex = newExpressionLatex.replaceAll('_{1', `_{${graphId}`);\r\n        if (_lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].hasCenter) {\r\n            newExpressionLatex += (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(MyCalc.linkedVariable(`x_{${graphId}ca}`, xMin), MyCalc.linkedVariable(`y_{${graphId}ca}`, yMin), MyCalc.linkedVariable(`x_{${graphId}cb}`, xMax), MyCalc.linkedVariable(`y_{${graphId}cb}`, yMax)).reference;\r\n        }\r\n        const graphObject = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)({\r\n            id: `${graphId.toString()}_${0}`,\r\n            latex: newExpressionLatex,\r\n            color: 'BLACK',\r\n            hidden: false,\r\n            type: \"expression\",\r\n            label: JSON.stringify({\r\n                graphType\r\n            })\r\n        });\r\n        graphFormat\r\n            .map((expression, index) => { return { index, ...expression }; })\r\n            .filter(expression => (0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(expression.types, ['x_expression', 'y_expression']))\r\n            .forEach(_expression => {\r\n            const expression = _expression.latex.replaceAll('_{1', `_{${graphId}`);\r\n            const split = expression.split('=');\r\n            const matches = [...split[0].matchAll(_lib__WEBPACK_IMPORTED_MODULE_0__.functionRegex)];\r\n            if (matches.length > 0) {\r\n                const [full, name, args] = matches[0];\r\n                MyCalc.globalFunctionsObject[name] = {\r\n                    id: `${graphId}_${_expression.index}`,\r\n                    args: args.split(','),\r\n                    definition: split[1],\r\n                };\r\n            }\r\n        });\r\n        if (_lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].hasCrop) {\r\n            const bounds = graphObject.getRealBounds();\r\n            if (!Number.isFinite(xMin)) {\r\n                xMin = bounds.xMin.value - 2;\r\n            }\r\n            if (!Number.isFinite(yMin)) {\r\n                yMin = bounds.yMin.value - 2;\r\n            }\r\n            if (!Number.isFinite(xMax)) {\r\n                xMax = bounds.xMax.value + 2;\r\n            }\r\n            if (!Number.isFinite(yMax)) {\r\n                yMax = bounds.yMax.value + 2;\r\n            }\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cam}`, (xMin - h).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cam}`, (yMin - k).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cbm}`, (xMax - h).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cbm}`, (yMax - k).toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}ca}`, xMin.toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}ca}`, yMin.toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cb}`, xMax.toString());\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cb}`, yMax.toString());\r\n        }\r\n        if (options?.finalize) {\r\n            graphObject.latex = graphObject.convertToStandard();\r\n            graphObject.id = `final_${graphObject.graphId}`;\r\n            MyCalc.setExpression(graphObject);\r\n        }\r\n        else {\r\n            MyCalc.setLogicalExpression(graphObject);\r\n        }\r\n    }\r\n    else {\r\n        for (let i = 0; i < graphFormat.length; i++) {\r\n            const newExpression = graphFormat[i];\r\n            let newExpressionLatex = newExpression.latex;\r\n            newExpressionLatex = newExpressionLatex.replaceAll('_{1', `_{${graphId}`);\r\n            if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(newExpression.types, ['var'])) {\r\n                const [variable] = newExpressionLatex.split('=');\r\n                const value = MyCalc.globalVariablesObject[(0,_lib__WEBPACK_IMPORTED_MODULE_0__.toId)(variable, graphId)];\r\n                newExpressionLatex = `${variable}=${(0,_lib__WEBPACK_IMPORTED_MODULE_0__.simplify)(parseFloat(value), 4)}`;\r\n            }\r\n            let label = \"\";\r\n            if (graphType !== 6) {\r\n                if (i === 0) {\r\n                    label = JSON.stringify({\r\n                        graphType\r\n                    });\r\n                    newExpressionLatex += (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(MyCalc.linkedVariable(`x_{${graphId}ca}`, xMin), MyCalc.linkedVariable(`y_{${graphId}ca}`, yMin), MyCalc.linkedVariable(`x_{${graphId}cb}`, xMax), MyCalc.linkedVariable(`y_{${graphId}cb}`, yMax)).reference;\r\n                    const conic = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)({\r\n                        id: `${graphId.toString()}_${i}`,\r\n                        latex: newExpressionLatex, color: 'BLACK',\r\n                        hidden: (0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['x_expression', 'y_expression']),\r\n                        type: \"expression\",\r\n                        label: JSON.stringify({\r\n                            graphType\r\n                        })\r\n                    });\r\n                    const bounds = conic.getRealBounds();\r\n                    if (!Number.isFinite(xMin)) {\r\n                        xMin = bounds.xMin.value - 2;\r\n                    }\r\n                    if (!Number.isFinite(yMin)) {\r\n                        yMin = bounds.yMin.value - 2;\r\n                    }\r\n                    if (!Number.isFinite(xMax)) {\r\n                        xMax = bounds.xMax.value + 2;\r\n                    }\r\n                    if (!Number.isFinite(yMax)) {\r\n                        yMax = bounds.yMax.value + 2;\r\n                    }\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cam}`, (xMin - h).toString());\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cam}`, (yMin - k).toString());\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cbm}`, (xMax - h).toString());\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cbm}`, (yMax - k).toString());\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}ca}`, xMin.toString());\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}ca}`, yMin.toString());\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${graphId}cb}`, xMax.toString());\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${graphId}cb}`, yMax.toString());\r\n                }\r\n            }\r\n            let isHidden;\r\n            if (options?.hideCropLines) {\r\n                isHidden = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['x_expression', 'y_expression', 'x', 'y', 'xy']);\r\n            }\r\n            else {\r\n                isHidden = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['x_expression', 'y_expression']);\r\n                if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['x']))\r\n                    isHidden = (cropType % 2 === 1);\r\n                if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['y']))\r\n                    isHidden = cropType > 1;\r\n                if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['xy']))\r\n                    isHidden = cropType === 3;\r\n            }\r\n            if (options?.hideAll) {\r\n                isHidden = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['x_expression', 'y_expression', 'x', 'y', 'xy', 'point']);\r\n            }\r\n            if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.doesIntersect)(graphFormat[i].types, ['x_expression', 'y_expression'])) {\r\n                const split = newExpressionLatex.split('=');\r\n                const matches = [...split[0].matchAll(_lib__WEBPACK_IMPORTED_MODULE_0__.functionRegex)];\r\n                if (matches.length > 0) {\r\n                    const [full, name, args] = matches[0];\r\n                    MyCalc.globalFunctionsObject[name] = {\r\n                        id: `${graphId}_${i}`,\r\n                        args: args.split(','),\r\n                        definition: split[1],\r\n                    };\r\n                }\r\n            }\r\n            const newBaseExpression = {\r\n                id: `${graphId}_${i}`,\r\n                latex: newExpressionLatex,\r\n                color: 'BLACK',\r\n                hidden: isHidden,\r\n                type: \"expression\",\r\n                label: label\r\n            };\r\n            expressionsToSet.push(newBaseExpression);\r\n        }\r\n        if (options?.update) {\r\n            MyCalc.updateExpressions(expressionsToSet);\r\n        }\r\n        else if (options?.set) {\r\n            MyCalc.setExpressions(expressionsToSet);\r\n        }\r\n        else {\r\n            MyCalc.newGraph(graphId, expressionsToSet);\r\n        }\r\n    }\r\n}\r\nfunction main() {\r\n    MyCalc = new _MyCalc__WEBPACK_IMPORTED_MODULE_2__.MyCalcClass(Calc);\r\n    const selections = [];\r\n    let easySelections = [];\r\n    const graphAbbrev = ['C', 'HP', 'VP', 'E', 'HH', 'VH', 'LS'];\r\n    let easyMode = false;\r\n    let lastSelectedId = '';\r\n    let currentlyPressed = [];\r\n    let shadeIdSet = false;\r\n    let altTime = 0;\r\n    let ctrlTime = 0;\r\n    let expressionPos = { x: 0, y: 0 };\r\n    let shadeId = 1;\r\n    let currGraphId = 0;\r\n    let centerPoint = {\r\n        x: Infinity,\r\n        y: Infinity,\r\n    };\r\n    let lastCenterPoint = {\r\n        x: Infinity,\r\n        y: Infinity,\r\n    };\r\n    function getShadeId() {\r\n        return Math.max(...MyCalc\r\n            .getExpressions()\r\n            .filter((x) => x.id.startsWith('shade_'))\r\n            .filter((x) => !x.id.includes('folder'))\r\n            .map((x) => parseInt(x.id.split('_')[1], 10)), 0);\r\n    }\r\n    const shadingData = {\r\n        lastUpperBoundary: {\r\n            x: MyCalc.linkedVariable(-Infinity),\r\n            y: MyCalc.linkedVariable(-Infinity),\r\n        },\r\n        lastLowerBoundary: {\r\n            x: MyCalc.linkedVariable(Infinity),\r\n            y: MyCalc.linkedVariable(Infinity),\r\n        },\r\n    };\r\n    function createDefaultConic(graphType) {\r\n        const coordinates = MyCalc.graphpaperBounds.mathCoordinates;\r\n        expressionPos = { x: parseFloat(((coordinates.left + coordinates.right) / 2).toFixed(MyCalc.precision)), y: parseFloat(((coordinates.top + coordinates.bottom) / 2).toFixed(MyCalc.precision)) };\r\n        const verticalSize = (coordinates.top - coordinates.bottom);\r\n        const horizontalSize = (coordinates.right - coordinates.left);\r\n        const size = Math.min(verticalSize, horizontalSize);\r\n        _lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].setDefault(MyCalc.globalId, expressionPos, size);\r\n        if (_lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].hasCenter) {\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`h_{${MyCalc.globalId}}`, expressionPos.x);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`k_{${MyCalc.globalId}}`, expressionPos.y);\r\n        }\r\n        if (_lib__WEBPACK_IMPORTED_MODULE_0__.GraphTypes[graphType].hasCrop) {\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${MyCalc.globalId}cam}`, -size * 0.4);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${MyCalc.globalId}cam}`, -size * 0.4);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`x_{${MyCalc.globalId}cbm}`, size * 0.4);\r\n            (0,_lib__WEBPACK_IMPORTED_MODULE_0__.setVariable)(`y_{${MyCalc.globalId}cbm}`, size * 0.4);\r\n        }\r\n        (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createConic)(graphType, MyCalc.globalId);\r\n        MyCalc.globalId += 1;\r\n    }\r\n    function freeze(force, append) {\r\n        let newId = 1;\r\n        const numExpressions = MyCalc.getItemCount();\r\n        if (append) {\r\n            const expressionsString = localStorage.getItem('expressions');\r\n            if (expressionsString) {\r\n                const expressions = JSON.parse(expressionsString);\r\n                let newId = MyCalc.globalId;\r\n                let newShadeId = shadeId;\r\n                const baseExpressions = expressions.filter(_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression);\r\n                const newExpressions = [];\r\n                baseExpressions.forEach((_expression) => {\r\n                    const expression = _expression;\r\n                    if (!MyCalc.existingExpressions.has(expression.latex)) {\r\n                        const split = expression.id.split(\"_\");\r\n                        if (split[0] === \"final\") {\r\n                            expression.id = `final_${newId}`;\r\n                            newId += 1;\r\n                        }\r\n                        else if (split[0] === \"shade\") {\r\n                            expression.id = `shade_${newShadeId}`;\r\n                            newShadeId += 1;\r\n                        }\r\n                        MyCalc.existingExpressions.add(expression.latex);\r\n                        newExpressions.push(expression);\r\n                    }\r\n                });\r\n                MyCalc.setExpressions(newExpressions);\r\n                MyCalc.globalId = newId;\r\n                shadeId = newShadeId;\r\n            }\r\n        }\r\n        else {\r\n            if (numExpressions !== 1) {\r\n                const expressions = MyCalc.getExpressions();\r\n                let graphExpressionsNormal = [];\r\n                if (force) {\r\n                    graphExpressionsNormal = expressions.filter((x) => !x.id.includes('_'));\r\n                }\r\n                const graphExpressionsBase = expressions.filter((x) => x.id.endsWith('_0') && !x.id.startsWith('final_'));\r\n                const graphExpressionsFinal = expressions.filter((x) => x.id.startsWith('final_') && !x.id.includes('folder'));\r\n                const graphExpressionsShade = expressions.filter((x) => x.id.startsWith('shade_') && !x.id.includes('folder'));\r\n                const graphExpressionsNormalLatex = graphExpressionsNormal.map((_graphExpression) => {\r\n                    const graphExpression = _graphExpression;\r\n                    graphExpression.id = `final_${newId}`;\r\n                    newId += 1;\r\n                    return graphExpression;\r\n                });\r\n                const graphExpressionsBaseLatex = graphExpressionsBase.map((_graphExpression) => {\r\n                    if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(_graphExpression)) {\r\n                        const conic = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(_graphExpression);\r\n                        conic.latex = conic.convertToStandard();\r\n                        conic.id = `final_${newId}`;\r\n                        conic.graphId = newId;\r\n                        newId += 1;\r\n                        return conic.toExpression();\r\n                    }\r\n                });\r\n                const graphExpressionsFinalLatex = graphExpressionsFinal.map((_graphExpression) => {\r\n                    const graphExpression = _graphExpression;\r\n                    graphExpression.id = `final_${newId}`;\r\n                    newId += 1;\r\n                    return graphExpression;\r\n                });\r\n                const graphExpressionsShadeLatex = graphExpressionsShade.map((_graphExpression) => {\r\n                    const graphExpression = _graphExpression;\r\n                    if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(graphExpression)) {\r\n                        const latex = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.substituteParenthesis)(graphExpression.latex);\r\n                        const expression = {\r\n                            color: graphExpression.color,\r\n                            fillOpacity: graphExpression.fillOpacity,\r\n                            hidden: false,\r\n                            id: graphExpression.id,\r\n                            latex,\r\n                            type: \"expression\",\r\n                            label: JSON.stringify({\r\n                                graphType: \"shade\"\r\n                            })\r\n                        };\r\n                        return expression;\r\n                    }\r\n                });\r\n                const _latexAll = [\r\n                    ...graphExpressionsNormalLatex,\r\n                    ...graphExpressionsShadeLatex,\r\n                    ...graphExpressionsBaseLatex,\r\n                    ...graphExpressionsFinalLatex,\r\n                ];\r\n                const latexAll = _latexAll.filter(expression => {\r\n                    if (expression && (0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(expression)) {\r\n                        if (!MyCalc.existingExpressions.has(expression.latex)) {\r\n                            MyCalc.existingExpressions.add(expression.latex);\r\n                            return true;\r\n                        }\r\n                        console.log('bruh');\r\n                    }\r\n                    return false;\r\n                });\r\n                localStorage.setItem('expressions', JSON.stringify(latexAll));\r\n            }\r\n            else {\r\n                const expressionsString = localStorage.getItem('expressions');\r\n                if (expressionsString) {\r\n                    const expressions = JSON.parse(expressionsString);\r\n                    MyCalc.setExpressions(expressions);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function resetSelection() {\r\n        shadingData.lastUpperBoundary = { x: MyCalc.linkedVariable(-Infinity), y: MyCalc.linkedVariable(-Infinity) };\r\n        shadingData.lastLowerBoundary = { x: MyCalc.linkedVariable(Infinity), y: MyCalc.linkedVariable(Infinity) };\r\n    }\r\n    function fixNegative() {\r\n        let toFix = [];\r\n        const allExpressions = MyCalc.getExpressions().filter(_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression);\r\n        const negativeab = allExpressions.filter((x) => /[ab]_{\\d*\\w+}=-\\d+[.]{0,1}\\d*/g.test(x.latex)); // Selects ellipse, hyperbola with negative a, b\r\n        toFix = [...toFix, ...negativeab.map((expression) => {\r\n                expression.latex.replaceAll('-', '');\r\n                return expression;\r\n            })];\r\n        MyCalc.updateExpressions(toFix);\r\n    }\r\n    function changeCropMode(_id) {\r\n        if (_id.includes('_')) {\r\n            const graphId = _id.split('_')[0];\r\n            const idFilter = `${graphId}_`;\r\n            const filteredExpressions = MyCalc.getExpressions();\r\n            const baseExpressions = filteredExpressions.filter(_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression);\r\n            const idFilteredExpressions = baseExpressions.filter((x) => x.id.startsWith(idFilter));\r\n            const graphExpression = filteredExpressions.find((x) => x.id.endsWith('_0'));\r\n            if (!graphExpression) {\r\n                throw new Error();\r\n            }\r\n            else if (!(0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(graphExpression)) {\r\n                throw new Error(\"Selected item is not a BaseExpression\");\r\n            }\r\n            const conic = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(graphExpression);\r\n            const { graphType } = conic;\r\n            // 0 - default (x and y), 1 - x only, 2 - y only, 3 - no crop\r\n            let cropType = conic.getCropType();\r\n            cropType = (cropType + 1) % 4;\r\n            [conic.latex] = conic.latex.split('\\\\left\\\\{');\r\n            const addition = (cropType < 2 ? '\\\\left\\\\{x_{1ca}<x<x_{1cb}\\\\right\\\\}' : '') + (!(cropType % 2) ? '\\\\left\\\\{y_{1ca}<y<y_{1cb}\\\\right\\\\}' : '');\r\n            conic.latex += addition.replaceAll('_{1', `_{${graphId}`);\r\n            const xBoundary = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.typeFilter)(idFilteredExpressions, graphType, ['x']); // x only domain\r\n            const yBoundary = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.typeFilter)(idFilteredExpressions, graphType, ['y']); // y only domain\r\n            const xyPoints = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.typeFilter)(idFilteredExpressions, graphType, ['xy']); // points\r\n            const expressionsToSet = [];\r\n            for (let i = 0; i < xBoundary.length; i++) {\r\n                const expression = xBoundary[i];\r\n                expression.hidden = (cropType % 2 === 1);\r\n                expressionsToSet.push(expression);\r\n            }\r\n            for (let i = 0; i < yBoundary.length; i++) {\r\n                const expression = yBoundary[i];\r\n                expression.hidden = (cropType > 1);\r\n                expressionsToSet.push(expression);\r\n            }\r\n            for (let i = 0; i < xyPoints.length; i++) {\r\n                const expression = xyPoints[i];\r\n                expression.hidden = (cropType === 3);\r\n                expressionsToSet.push(expression);\r\n            }\r\n            expressionsToSet.push(conic);\r\n            MyCalc.updateExpressions(expressionsToSet);\r\n        }\r\n    }\r\n    function setId() {\r\n        const baseId = Math.max(0, Math.max(...MyCalc.getExpressions()\r\n            .filter((x) => x.id.endsWith('_0'))\r\n            .map((x) => parseInt(x.id.split('_')[0], 10))\r\n            .filter((x) => !Number.isNaN(x)))) + 1;\r\n        const finalId = Math.max(0, Math.max(...MyCalc.getExpressions()\r\n            .filter((x) => x.id.startsWith('final_'))\r\n            .map((x) => parseInt(x.id.split('_')[1], 10))\r\n            .filter((x) => !Number.isNaN(x)))) + 1;\r\n        MyCalc.globalId = Math.max(baseId, finalId);\r\n    }\r\n    function shadeToBack() {\r\n        const state = MyCalc.getState();\r\n        state.expressions.list = state.expressions.list\r\n            .filter((x) => x.id.startsWith('shade_'))\r\n            .concat(state.expressions.list.filter((x) => !x.id.startsWith('shade_')));\r\n        MyCalc.setState(state);\r\n    }\r\n    function toggleShading() {\r\n        const baseExpressions = MyCalc.getExpressions().filter(_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression);\r\n        const shade = baseExpressions.filter((x) => x.id.startsWith('shade_'));\r\n        const newState = !shade[0].hidden;\r\n        MyCalc.updateExpressions(shade.map((_x) => {\r\n            const x = _x;\r\n            x.hidden = newState;\r\n            return x;\r\n        }));\r\n    }\r\n    function getBoundsById(_id) {\r\n        const graphExpression = MyCalc.getExpression(_id);\r\n        if (graphExpression) {\r\n            if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(graphExpression)) {\r\n                console.log(((0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(graphExpression))\r\n                    .getRealBounds());\r\n            }\r\n        }\r\n    }\r\n    function expressionToFront(id) {\r\n        const state = MyCalc.getState();\r\n        const expression = state.expressions.list\r\n            .filter((_expression) => _expression.id === id.id);\r\n        const multipleExpressions = state.expressions.list\r\n            .filter((_expression) => _expression.id !== id.id);\r\n        state.expressions.list = expression.concat(multipleExpressions);\r\n        MyCalc.setState(state);\r\n    }\r\n    function keyUpHandler(e) {\r\n        if (MyCalc)\r\n            MyCalc.updateLinkedVariables();\r\n        MyCalc.updateVariables();\r\n        setId();\r\n        if (currentlyPressed.includes(e.keyCode)) {\r\n            currentlyPressed = currentlyPressed.filter((key) => key !== e.keyCode);\r\n        }\r\n        if (e.ctrlKey && e.shiftKey) {\r\n            const { key } = e;\r\n            if (key === '<') {\r\n                if (MyCalc.selectedExpressionId) {\r\n                    expressionToFront((0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(MyCalc.selectedExpressionId));\r\n                }\r\n            }\r\n            if (key === 'F') { // F - Finalize\r\n                if (MyCalc.selectedExpressionId) {\r\n                    (0,_actions_finalize__WEBPACK_IMPORTED_MODULE_3__.finalizeId)((0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(MyCalc.selectedExpressionId));\r\n                }\r\n            }\r\n        }\r\n        if (e.key === 'Control') {\r\n            ctrlTime = Date.now();\r\n        }\r\n        if (e.key === 'Alt') {\r\n            altTime = Date.now();\r\n        }\r\n        if (e.ctrlKey || (Date.now() - ctrlTime) < 100) {\r\n            ctrlTime = Date.now();\r\n            const { key } = e;\r\n        }\r\n        if (e.altKey || (Date.now() - altTime) < 100) {\r\n            altTime = Date.now();\r\n            const { keyCode } = e;\r\n            if (keyCode === 71) {\r\n                if (MyCalc.selectedExpressionId) {\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.transformBezier)(MyCalc.selectedExpressionId);\r\n                }\r\n            }\r\n            if (keyCode === 87) {\r\n                const selection = selections.pop();\r\n            }\r\n            if (keyCode === 77) {\r\n                if (MyCalc.selectedExpressionId) {\r\n                    getBoundsById(MyCalc.selectedExpressionId);\r\n                }\r\n            }\r\n            if (keyCode === 219) {\r\n                fixNegative();\r\n            }\r\n            if (keyCode === 189) {\r\n                shadeToBack();\r\n            }\r\n            else if (keyCode === 187) {\r\n                toggleShading();\r\n            }\r\n            else if ((keyCode >= 49) && (keyCode <= 56)) {\r\n                createDefaultConic(keyCode - 49);\r\n            }\r\n            else if (keyCode === 83) { // bottom\r\n                resetSelection();\r\n            }\r\n            else if (keyCode === 48) {\r\n                freeze(e.shiftKey, e.ctrlKey);\r\n            }\r\n            else if (keyCode === 88) {\r\n                if (MyCalc.selectedExpressionId)\r\n                    MyCalc.deleteById(MyCalc.selectedExpressionId);\r\n            }\r\n            else if (keyCode === 81) {\r\n                if (MyCalc.selectedExpressionId)\r\n                    changeCropMode(MyCalc.selectedExpressionId);\r\n            }\r\n            else if (keyCode === 72) {\r\n                if (MyCalc.selectedExpressionId)\r\n                    (0,_actions_hideCropLines__WEBPACK_IMPORTED_MODULE_4__.hideCropLines)((0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(MyCalc.selectedExpressionId));\r\n            }\r\n            else if (keyCode === 70) {\r\n                easyMode = !easyMode;\r\n            }\r\n        }\r\n        e.preventDefault();\r\n    }\r\n    function keyDownHandler(e) {\r\n        if (MyCalc)\r\n            MyCalc.updateLinkedVariables();\r\n        if (e.altKey) {\r\n            if (!currentlyPressed.includes(e.keyCode)) {\r\n                currentlyPressed.push(e.keyCode);\r\n            }\r\n        }\r\n    }\r\n    function fillInside(id) {\r\n        const expression = MyCalc.getExpression(id);\r\n        if (expression) {\r\n            if ((0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(expression)) {\r\n                const conic = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(expression);\r\n                if ([0, 4].includes(conic.graphType)) {\r\n                    conic.latex = conic.latex.replace('=', '>');\r\n                }\r\n                else if ([1, 2, 3, 5, 6].includes(conic.graphType)) {\r\n                    conic.latex = conic.latex.replace('=', '<');\r\n                }\r\n                MyCalc.setExpression({\r\n                    color: 'BLACK',\r\n                    hidden: false,\r\n                    type: \"expression\",\r\n                    id: `shade_${shadeId}`,\r\n                    latex: conic.latex,\r\n                    label: JSON.stringify({\r\n                        graphType: \"shade\"\r\n                    })\r\n                });\r\n                shadeId += 1;\r\n            }\r\n        }\r\n    }\r\n    function fillIntersection(lowerId, upperId, axis, options) {\r\n        const lowerObject = MyCalc.getExpression(lowerId);\r\n        const upperObject = MyCalc.getExpression(upperId);\r\n        if (!upperObject || !lowerObject) {\r\n            throw new Error(\"This shouldn't happen\");\r\n        }\r\n        if (!(0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(lowerObject) || !(0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(upperObject)) {\r\n            throw new Error('bruh');\r\n        }\r\n        const lowerConic = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(lowerObject);\r\n        const upperConic = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(upperObject);\r\n        const lowerBounds = lowerConic.getRealBounds();\r\n        const upperBounds = upperConic.getRealBounds();\r\n        if (axis === 'y') {\r\n            let realMin = lowerBounds.xMin.value < upperBounds.xMin.value\r\n                ? upperBounds.xMin : lowerBounds.xMin;\r\n            let realMax = lowerBounds.xMax.value > upperBounds.xMax.value\r\n                ? upperBounds.xMax : lowerBounds.xMax;\r\n            if (Number.isFinite(lastCenterPoint.x)) {\r\n                if (shadingData.lastUpperBoundary.y.value > realMin.value && lastCenterPoint.x < centerPoint.x) { // To right\r\n                    realMin = shadingData.lastUpperBoundary.y;\r\n                }\r\n                if (shadingData.lastLowerBoundary.y.value < realMax.value && lastCenterPoint.x > centerPoint.x) {\r\n                    realMax = shadingData.lastLowerBoundary.y;\r\n                }\r\n            }\r\n            shadingData.lastUpperBoundary.y = realMax;\r\n            shadingData.lastLowerBoundary.y = realMin;\r\n            const boundsObject = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(realMin, MyCalc.linkedVariable(-Infinity), realMax, MyCalc.linkedVariable(Infinity));\r\n            let bounds;\r\n            if (options?.useValue) {\r\n                bounds = boundsObject.value;\r\n            }\r\n            else {\r\n                bounds = boundsObject.reference;\r\n            }\r\n            const newExpressions = [];\r\n            const lowerConicConverted = lowerConic.convertToYRelevant();\r\n            const upperConicConverted = upperConic.convertToYRelevant();\r\n            for (let lowerIndex = 0; lowerIndex < lowerConicConverted.length; lowerIndex++) {\r\n                const currLowerConic = lowerConicConverted[lowerIndex];\r\n                for (let upperIndex = 0; upperIndex < upperConicConverted.length; upperIndex++) {\r\n                    const currUpperConic = upperConicConverted[upperIndex];\r\n                    const newExpression = `${currLowerConic}<y<${currUpperConic}${bounds}`;\r\n                    newExpressions.push({\r\n                        color: 'BLACK',\r\n                        hidden: false,\r\n                        type: \"expression\",\r\n                        id: `shade_${shadeId}`,\r\n                        latex: newExpression,\r\n                        fillOpacity: '1',\r\n                        label: JSON.stringify({\r\n                            graphType: \"shade\"\r\n                        })\r\n                    });\r\n                    shadeId += 1;\r\n                }\r\n            }\r\n            MyCalc.setExpressions(newExpressions);\r\n        }\r\n        else if (axis === 'x') {\r\n            let realMin = lowerBounds.yMin.value < upperBounds.yMin.value\r\n                ? upperBounds.yMin : lowerBounds.yMin;\r\n            let realMax = lowerBounds.yMax.value > upperBounds.yMax.value\r\n                ? upperBounds.yMax : lowerBounds.yMax;\r\n            if (Number.isFinite(lastCenterPoint.y)) {\r\n                if (shadingData.lastUpperBoundary.x.value > realMin.value && lastCenterPoint.y < centerPoint.y) {\r\n                    realMin = shadingData.lastUpperBoundary.x;\r\n                }\r\n                if (shadingData.lastLowerBoundary.x.value < realMax.value && lastCenterPoint.y > centerPoint.y) {\r\n                    realMax = shadingData.lastLowerBoundary.x;\r\n                }\r\n            }\r\n            shadingData.lastUpperBoundary.x = realMax;\r\n            shadingData.lastLowerBoundary.x = realMin;\r\n            const boundsObject = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.generateBounds)(MyCalc.linkedVariable(-Infinity), realMin, MyCalc.linkedVariable(Infinity), realMax);\r\n            let bounds;\r\n            if (options?.useValue) {\r\n                bounds = boundsObject.value;\r\n            }\r\n            else {\r\n                bounds = boundsObject.reference;\r\n            }\r\n            const newExpressions = [];\r\n            const lowerConicConverted = lowerConic.convertToXRelevant();\r\n            const upperConicConverted = upperConic.convertToXRelevant();\r\n            for (let lowerIndex = 0; lowerIndex < lowerConicConverted.length; lowerIndex++) {\r\n                const currLowerConic = lowerConicConverted[lowerIndex];\r\n                for (let upperIndex = 0; upperIndex < upperConicConverted.length; upperIndex++) {\r\n                    const currUpperConic = upperConicConverted[upperIndex];\r\n                    const newExpression = `${currLowerConic}<x<${currUpperConic}${bounds}`;\r\n                    newExpressions.push({\r\n                        color: 'BLACK',\r\n                        hidden: false,\r\n                        type: \"expression\",\r\n                        id: `shade_${shadeId}`,\r\n                        latex: newExpression,\r\n                        label: JSON.stringify({\r\n                            graphType: \"shade\"\r\n                        })\r\n                    });\r\n                    shadeId += 1;\r\n                }\r\n            }\r\n            MyCalc.setExpressions(newExpressions);\r\n        }\r\n    }\r\n    function mouseUpHandler(e) {\r\n        if (MyCalc)\r\n            MyCalc.updateLinkedVariables();\r\n        setId();\r\n        if (MyCalc.selectedExpressionId) {\r\n            lastSelectedId = MyCalc.selectedExpressionId;\r\n        }\r\n        MyCalc.updateVariables();\r\n        if (!shadeIdSet) {\r\n            shadeId = getShadeId() + 1;\r\n            shadeIdSet = true;\r\n        }\r\n        if (easyMode) {\r\n            // if (easySelections.length > 4) {\r\n            //   easySelections.pop()\r\n            // }\r\n            if (e.button === 0) {\r\n                const selectedExpression = MyCalc.getSelected();\r\n                MyCalc.selectedExpressionId = undefined;\r\n                if (selectedExpression && (0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(selectedExpression) && isGraph(selectedExpression)) {\r\n                    const point = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createGraphObject)(selectedExpression).getClosestEndpoint(MyCalc.pixelsToMath({\r\n                        x: e.clientX,\r\n                        y: e.clientY,\r\n                    }));\r\n                    easySelections.push({\r\n                        x: point.x.value,\r\n                        y: point.y.value,\r\n                    });\r\n                }\r\n                else {\r\n                    easySelections.push(MyCalc.pixelsToMath({ x: e.clientX, y: e.clientY }));\r\n                }\r\n            }\r\n            console.log(easySelections, e.button);\r\n            if (e.button == 1) {\r\n                if (easySelections.length === 1) {\r\n                }\r\n                if (easySelections.length === 2) {\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createLineSegment)(easySelections[0], easySelections[1], MyCalc.globalId, { finalize: true });\r\n                }\r\n                if (easySelections.length === 4) {\r\n                    (0,_lib__WEBPACK_IMPORTED_MODULE_0__.createBezier)(easySelections[0], easySelections[1], easySelections[2], easySelections[3], MyCalc.globalId);\r\n                    // MyCalc.regression(easySelections)\r\n                }\r\n                easySelections = [];\r\n            }\r\n        }\r\n        else {\r\n            if (e.button === 1) {\r\n                const shade = MyCalc.getExpressions().filter((expression) => expression.id.includes(\"shade_\"));\r\n                shade.forEach((shade) => {\r\n                    // const {xMin, xMax, yMin, yMax} = parseDomains(getDomainsFromLatex(shade.latex))\r\n                });\r\n            }\r\n            if (currentlyPressed.includes(65)) {\r\n                const selected = MyCalc.getSelected();\r\n                if (selected && isGraph(selected)) {\r\n                    selections.push({ id: selected.id, pos: MyCalc.pixelsToMath({ x: e.clientX, y: e.clientY }) });\r\n                }\r\n                if (selections.length >= 2) {\r\n                    const lowerSelection = selections.shift();\r\n                    const upperSelection = selections.shift();\r\n                    if (!upperSelection || !lowerSelection) {\r\n                        throw new Error(\"This shouldn't happen\");\r\n                    }\r\n                    centerPoint = {\r\n                        x: (upperSelection.pos.x + lowerSelection.pos.x) / 2,\r\n                        y: (upperSelection.pos.x + lowerSelection.pos.y) / 2,\r\n                    };\r\n                    const slope = (Math.abs(upperSelection.pos.y - lowerSelection.pos.y) + 1)\r\n                        / (Math.abs(upperSelection.pos.x - lowerSelection.pos.x) + 1);\r\n                    const axis = (slope > 1) ? 'y' : 'x';\r\n                    let upperId = upperSelection.id;\r\n                    let lowerId = lowerSelection.id;\r\n                    const lowerIdParts = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(lowerId);\r\n                    const upperIdParts = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(upperId);\r\n                    if (upperId === lowerId) {\r\n                        if (lowerIdParts.isFinal) {\r\n                            (0,_actions_finalize__WEBPACK_IMPORTED_MODULE_3__.unfinalize)(lowerIdParts);\r\n                            lowerId = `${lowerIdParts.graphId}_0`;\r\n                        }\r\n                        const newLowerIdParts = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(lowerId);\r\n                        fillInside(lowerId);\r\n                        if (newLowerIdParts.isEditable && lowerIdParts.isFinal)\r\n                            (0,_actions_finalize__WEBPACK_IMPORTED_MODULE_3__.finalize)(newLowerIdParts);\r\n                    }\r\n                    else {\r\n                        if (lowerIdParts.isFinal) {\r\n                            (0,_actions_finalize__WEBPACK_IMPORTED_MODULE_3__.unfinalize)(lowerIdParts, { logical: true });\r\n                            lowerId = `${lowerIdParts.graphId}_0`;\r\n                        }\r\n                        if (upperIdParts.isFinal) {\r\n                            (0,_actions_finalize__WEBPACK_IMPORTED_MODULE_3__.unfinalize)(upperIdParts, { logical: true });\r\n                            upperId = `${upperIdParts.graphId}_0`;\r\n                        }\r\n                        const newLowerIdParts = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(lowerId);\r\n                        const newUpperIdParts = (0,_lib__WEBPACK_IMPORTED_MODULE_0__.getIdParts)(upperId);\r\n                        fillIntersection(lowerId, upperId, axis, { useValue: true });\r\n                        if (newLowerIdParts.isEditable && lowerIdParts.isFinal)\r\n                            MyCalc.removeExpressionById(lowerId);\r\n                        if (newUpperIdParts.isEditable && upperIdParts.isFinal)\r\n                            MyCalc.removeExpressionById(upperId);\r\n                    }\r\n                    lastCenterPoint = centerPoint;\r\n                }\r\n            }\r\n        }\r\n    }\r\n    document.addEventListener('keydown', keyDownHandler, false);\r\n    document.addEventListener('keyup', keyUpHandler, false);\r\n    document.addEventListener('pointerup', mouseUpHandler, false);\r\n    function toggleArtist() {\r\n        const x = document.querySelector('#artist');\r\n        const y = document.querySelector('#artist-container');\r\n        if (x)\r\n            x.style.display = x.style.display === 'none' ? 'block' : 'none';\r\n        if (y)\r\n            y.style.display = y.style.display === 'none' ? 'block' : 'none';\r\n    }\r\n    function changeColor() {\r\n        const graphExpression = MyCalc.getExpression(lastSelectedId);\r\n        if (graphExpression && (0,_lib__WEBPACK_IMPORTED_MODULE_0__.isBaseExpression)(graphExpression)) {\r\n            const colorForm = $('#colorForm');\r\n            if (colorForm) {\r\n                const [color, fillOpacity] = colorForm.serializeArray();\r\n                graphExpression.color = color.value;\r\n                graphExpression.fillOpacity = fillOpacity.value;\r\n                MyCalc.updateExpression(graphExpression);\r\n            }\r\n        }\r\n    }\r\n    function changegraphType() {\r\n        currGraphId = (currGraphId + 1) % 7;\r\n        const button = document.querySelector('#artist-button');\r\n        if (button) {\r\n            button.innerHTML = graphAbbrev[currGraphId];\r\n        }\r\n    }\r\n    function createConicHandler() {\r\n        createDefaultConic(currGraphId);\r\n    }\r\n    const shortcutButtons = false;\r\n    const pillbox = unsafeWindow.document.querySelector('.dcg-overgraph-pillbox-elements');\r\n    if (pillbox) {\r\n        pillbox.insertAdjacentHTML('beforeend', '<div id=\"artist-button-container\"><div class=\"dcg-tooltip-hit-area-container\"><div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings\" role=\"button\" onclick=\\'toggleArtist()\\' style=\"background:#ededed\"><i class=\"dcg-icon-wrench\" aria-hidden=\"true\"></i></div></div><div style=\"display: none\"></div></div>');\r\n        pillbox.insertAdjacentHTML('beforeend', '<div id=\"artist-container\" class=\"dcg-artist-view-container\"></div>');\r\n        const artistContainer = unsafeWindow.document.querySelector('#artist-container');\r\n        if (shortcutButtons) {\r\n            if (artistContainer) {\r\n                artistContainer.insertAdjacentHTML('beforeend', `<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div id=\"artist-button\" class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" oncontextmenu=\"createConicHandler();return false;\" onclick=\"changegraphType()\" style=\"background:#ededed\">${graphAbbrev[currGraphId]}</div></div>`);\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"deleteById(Calc.selectedExpressionId)\" style=\"background:#ededed\">X</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"hideCropLines(Calc.selectedExpressionId)\" style=\"background:#ededed\">H</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"changeCropMode(Calc.selectedExpressionId)\" style=\"background:#ededed\">Q</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" onclick=\"finalizeId(Calc.selectedExpressionId)\" style=\"background:#ededed\">F</div></div>');\r\n                artistContainer.insertAdjacentHTML('beforeend', '<div class=\"dcg-tooltip-hit-area-container dcg-hovered\"> <div class=\"dcg-btn-flat-gray dcg-settings-pillbox dcg-action-settings dcg-hovered\" role=\"button\" oncontextmenu=\"freeze(false);return false;\" style=\"background:#ededed\">S</div></div>');\r\n            }\r\n        }\r\n    }\r\n    const body = document.querySelector('.dcg-grapher');\r\n    if (body) {\r\n        body.insertAdjacentHTML('beforeend', '<div id=\"artist\" style=\"position: absolute; bottom: 5%; right: 5%; padding: 10px; border: 1px solid black; border-radius: 10px\"><form id=\"colorForm\" onSubmit=\"return changeColor()\"><div> Color <input name=\"color\" type=\"color\"></div><div> Opacity <input name=\"fillOpacity\" type=\"number\" min=\"0\" max=\"1\" value=\"0.4\"></div><div><input type=\"button\" value=\"Apply\" onclick=\"changeColor()\"></div></form></div>');\r\n    }\r\n    unsafeWindow.MyCalc = MyCalc;\r\n    unsafeWindow.Graph = _classes_Graph__WEBPACK_IMPORTED_MODULE_1__.Graph;\r\n    unsafeWindow.changeColor = changeColor;\r\n    unsafeWindow.changegraphType = changegraphType;\r\n    unsafeWindow.createConicHandler = createConicHandler;\r\n    unsafeWindow.deleteById = MyCalc.deleteById;\r\n    unsafeWindow.toggleArtist = toggleArtist;\r\n}\r\n(async () => {\r\n    while (typeof Calc === 'undefined') {\r\n        await new Promise((resolve) => setTimeout(resolve, 1000));\r\n    }\r\n    main();\r\n})();\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/index.user.ts?");

/***/ }),

/***/ "./src/lib.ts":
/*!********************!*\
  !*** ./src/lib.ts ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"GraphTypes\": () => (/* binding */ GraphTypes),\n/* harmony export */   \"baseExpressionFormat\": () => (/* binding */ baseExpressionFormat),\n/* harmony export */   \"functionRegex\": () => (/* binding */ functionRegex),\n/* harmony export */   \"functionVariableRegex\": () => (/* binding */ functionVariableRegex),\n/* harmony export */   \"getVariable\": () => (/* binding */ getVariable),\n/* harmony export */   \"substituteParenthesis\": () => (/* binding */ substituteParenthesis),\n/* harmony export */   \"LinkedVariable\": () => (/* binding */ LinkedVariable),\n/* harmony export */   \"isNumeric\": () => (/* binding */ isNumeric),\n/* harmony export */   \"getIdParts\": () => (/* binding */ getIdParts),\n/* harmony export */   \"getGraphType\": () => (/* binding */ getGraphType),\n/* harmony export */   \"hasXDomain\": () => (/* binding */ hasXDomain),\n/* harmony export */   \"hasYDomain\": () => (/* binding */ hasYDomain),\n/* harmony export */   \"getDomains\": () => (/* binding */ getDomains),\n/* harmony export */   \"parseDomains\": () => (/* binding */ parseDomains),\n/* harmony export */   \"maxLinkedVariable\": () => (/* binding */ maxLinkedVariable),\n/* harmony export */   \"minLinkedVariable\": () => (/* binding */ minLinkedVariable),\n/* harmony export */   \"minMax\": () => (/* binding */ minMax),\n/* harmony export */   \"simplify\": () => (/* binding */ simplify),\n/* harmony export */   \"getVariablesNeeded\": () => (/* binding */ getVariablesNeeded),\n/* harmony export */   \"substitute\": () => (/* binding */ substitute),\n/* harmony export */   \"generateBounds\": () => (/* binding */ generateBounds),\n/* harmony export */   \"usesVariable\": () => (/* binding */ usesVariable),\n/* harmony export */   \"substituteFromId\": () => (/* binding */ substituteFromId),\n/* harmony export */   \"setVariable\": () => (/* binding */ setVariable),\n/* harmony export */   \"toId\": () => (/* binding */ toId),\n/* harmony export */   \"intersect\": () => (/* binding */ intersect),\n/* harmony export */   \"doesIntersect\": () => (/* binding */ doesIntersect),\n/* harmony export */   \"typeFilter\": () => (/* binding */ typeFilter),\n/* harmony export */   \"isBaseExpression\": () => (/* binding */ isBaseExpression),\n/* harmony export */   \"isFinal\": () => (/* binding */ isFinal),\n/* harmony export */   \"createGraphObject\": () => (/* binding */ createGraphObject),\n/* harmony export */   \"createConic\": () => (/* binding */ createConic),\n/* harmony export */   \"createLineSegment\": () => (/* binding */ createLineSegment),\n/* harmony export */   \"createBezier\": () => (/* binding */ createBezier),\n/* harmony export */   \"getDomainsFromLatex\": () => (/* binding */ getDomainsFromLatex),\n/* harmony export */   \"transformVariables\": () => (/* binding */ transformVariables),\n/* harmony export */   \"hax\": () => (/* binding */ hax),\n/* harmony export */   \"transformBezier\": () => (/* binding */ transformBezier),\n/* harmony export */   \"substituteToAll\": () => (/* binding */ substituteToAll)\n/* harmony export */ });\n/* harmony import */ var _index_user__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index.user */ \"./src/index.user.ts\");\n/* harmony import */ var _graphs_Circle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./graphs/Circle */ \"./src/graphs/Circle.ts\");\n/* harmony import */ var _graphs_Ellipse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./graphs/Ellipse */ \"./src/graphs/Ellipse.ts\");\n/* harmony import */ var _graphs_HorizontalHyperbola__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./graphs/HorizontalHyperbola */ \"./src/graphs/HorizontalHyperbola.ts\");\n/* harmony import */ var _graphs_HorizontalParabola__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./graphs/HorizontalParabola */ \"./src/graphs/HorizontalParabola.ts\");\n/* harmony import */ var _graphs_LineSegment__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./graphs/LineSegment */ \"./src/graphs/LineSegment.ts\");\n/* harmony import */ var _graphs_VerticalHyperbola__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./graphs/VerticalHyperbola */ \"./src/graphs/VerticalHyperbola.ts\");\n/* harmony import */ var _graphs_VerticalParabola__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./graphs/VerticalParabola */ \"./src/graphs/VerticalParabola.ts\");\n/* harmony import */ var _bezierLib__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./bezierLib */ \"./src/bezierLib.ts\");\n/* harmony import */ var _graphs_Bezier__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./graphs/Bezier */ \"./src/graphs/Bezier.ts\");\n/* harmony import */ var _svgLib__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./svgLib */ \"./src/svgLib.ts\");\n/* harmony import */ var _conicLib__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./conicLib */ \"./src/conicLib.ts\");\n/* harmony import */ var _actions_convertFromStandard__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./actions/convertFromStandard */ \"./src/actions/convertFromStandard.ts\");\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\nconst GraphTypes = [\r\n    _graphs_Circle__WEBPACK_IMPORTED_MODULE_1__.Circle,\r\n    _graphs_HorizontalParabola__WEBPACK_IMPORTED_MODULE_4__.HorizontalParabola,\r\n    _graphs_VerticalParabola__WEBPACK_IMPORTED_MODULE_7__.VerticalParabola,\r\n    _graphs_Ellipse__WEBPACK_IMPORTED_MODULE_2__.Ellipse,\r\n    _graphs_HorizontalHyperbola__WEBPACK_IMPORTED_MODULE_3__.HorizontalHyperbola,\r\n    _graphs_VerticalHyperbola__WEBPACK_IMPORTED_MODULE_6__.VerticalHyperbola,\r\n    _graphs_LineSegment__WEBPACK_IMPORTED_MODULE_5__.LineSegment,\r\n    _graphs_Bezier__WEBPACK_IMPORTED_MODULE_9__.Bezier,\r\n];\r\nconst baseExpressionFormat = GraphTypes.map(graphClass => graphClass.expressionFormat[0].latex);\r\nconst functionRegex = /([a-zA-Z]+_{[\\w\\d]+})(?:\\(([^,\\n=<>]+(?:,.+)*)\\))/g;\r\nconst functionVariableRegex = /([a-zA-Z]+_{[\\w\\d]+})(?:\\(([^,\\n=<>]+(?:,.+)*)\\))?/g;\r\nfunction getVariable(name) {\r\n    const match = name.match(/(\\w_{\\d+\\w*})/g);\r\n    if (match && match[0].length === name.length) {\r\n        if (name in _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalVariablesObject) {\r\n            return parseFloat(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalVariablesObject[name]);\r\n        }\r\n        else if (name in _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariables) {\r\n            return _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariables[name].value;\r\n        }\r\n    }\r\n    else {\r\n        const match = [...name.matchAll(functionRegex)];\r\n        if (match.length > 0) {\r\n            const parts = match[0];\r\n            const args = parts[2].split(',');\r\n            const value = evaluateFunction(parts[1], args.map((arg) => getVariable(arg)));\r\n            return value;\r\n        }\r\n        else {\r\n            const substituted = substitute(name);\r\n            const value = evaluatex(substituted)();\r\n            if (value) {\r\n                return value;\r\n            }\r\n        }\r\n    }\r\n    throw Error(`The variable ${name} is missing`);\r\n}\r\nfunction substituteParenthesis(_latex) {\r\n    let latex = _latex;\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    for (let j = 0; j < variablesNeeded.length; j++) {\r\n        const variableNeeded = variablesNeeded[j][0];\r\n        latex = latex.replace(variableNeeded, `(${simplify(getVariable(variableNeeded), 4)})`);\r\n    }\r\n    return latex;\r\n}\r\nfunction evaluateFunction(_func, values) {\r\n    const funcObject = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalFunctionsObject[_func];\r\n    if (!funcObject) {\r\n        throw Error(`Cannot find function with name ${_func}`);\r\n    }\r\n    const args = funcObject.args;\r\n    if (args.length !== values.length) {\r\n        throw Error(`Variable length (${args.length}) and value length (${values.length}) mismatch`);\r\n    }\r\n    else {\r\n        const variablesNeeded = getVariablesNeeded(funcObject.definition)\r\n            .map((variable) => variable[0])\r\n            .filter((variable) => !args.includes(variable));\r\n        const variableObject = {};\r\n        args.forEach((value, index) => variableObject[value] = values[index]);\r\n        variablesNeeded.forEach((value) => variableObject[value.replace(/([a-zA-Z])(?:_{(\\d+[a-zA-Z]*)})/g, '$1_$2')] = getVariable(value));\r\n        let newDefinition = funcObject.definition;\r\n        variablesNeeded.forEach((value) => {\r\n            newDefinition = newDefinition.replace(value, value.replace(/([a-zA-Z])(?:_{(\\d+[a-zA-Z]*)})/g, '$1_$2'));\r\n        });\r\n        newDefinition = newDefinition.replaceAll('}\\\\sqrt{', '}\\\\cdot\\\\sqrt{');\r\n        const value = evaluatex(newDefinition, variableObject)();\r\n        if (value !== undefined) {\r\n            return value;\r\n        }\r\n    }\r\n    throw Error('function broken lul');\r\n}\r\nclass LinkedVariable {\r\n    constructor(reference, _value) {\r\n        if (typeof reference === 'number') {\r\n            this.reference = null;\r\n            this._value = reference;\r\n            this.clean = true;\r\n            this.alwaysClean = true;\r\n        }\r\n        else {\r\n            this.clean = true;\r\n            this.alwaysClean = false;\r\n            this.reference = reference;\r\n            if (_value === undefined) {\r\n                if (reference != null) {\r\n                    this._value = getVariable(reference);\r\n                }\r\n                else {\r\n                    throw new Error('Null reference and undefined value');\r\n                }\r\n            }\r\n            else {\r\n                this._value = _value;\r\n            }\r\n        }\r\n        if (_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc) {\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.addLinkedVariable(this);\r\n        }\r\n    }\r\n    get value() {\r\n        if (!this.clean) {\r\n            if (this.reference) {\r\n                try {\r\n                    return getVariable(this.reference);\r\n                }\r\n                catch {\r\n                    return this._value;\r\n                }\r\n            }\r\n        }\r\n        return this._value;\r\n    }\r\n    set value(_value) {\r\n        if (!this.alwaysClean) {\r\n            this.clean = true;\r\n        }\r\n        if (this.reference) {\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalVariablesObject[this.reference] = _value.toString();\r\n        }\r\n        this._value = _value;\r\n    }\r\n}\r\nfunction isNumeric(str) {\r\n    return !isNaN(parseFloat(str));\r\n}\r\nfunction getIdParts(id) {\r\n    let isFinal = false;\r\n    let isShade = false;\r\n    let isEditable = false;\r\n    let isInvalid = false;\r\n    const split = id.split('_');\r\n    if (id.split('_')) {\r\n        if (split.length === 2) {\r\n            if (split[0] === 'final') {\r\n                isFinal = true;\r\n                const graphId = parseInt(split[1], 10);\r\n                return {\r\n                    id,\r\n                    isFinal,\r\n                    isShade,\r\n                    isEditable,\r\n                    isInvalid,\r\n                    graphId\r\n                };\r\n            }\r\n            else if (split[0] === 'shade') {\r\n                isShade = true;\r\n                return {\r\n                    id,\r\n                    isFinal,\r\n                    isShade,\r\n                    isEditable,\r\n                    isInvalid,\r\n                };\r\n            }\r\n            else if (isNumeric(split[0])) {\r\n                isEditable = true;\r\n                const graphId = parseInt(split[0], 10);\r\n                const editIndex = parseInt(split[1], 10);\r\n                return {\r\n                    id,\r\n                    isFinal,\r\n                    isShade,\r\n                    isEditable,\r\n                    isInvalid,\r\n                    graphId,\r\n                    editIndex,\r\n                };\r\n            }\r\n        }\r\n    }\r\n    isInvalid = true;\r\n    return {\r\n        isFinal,\r\n        isShade,\r\n        isEditable,\r\n        isInvalid,\r\n    };\r\n}\r\nfunction getGraphType(expression) {\r\n    const id = getIdParts(expression.id);\r\n    if (id.isFinal) {\r\n        return (0,_actions_convertFromStandard__WEBPACK_IMPORTED_MODULE_12__.getGraphTypeFromStandard)(expression.latex);\r\n    }\r\n    else if (id.isEditable) {\r\n        let type = null;\r\n        for (let i = 0; i < baseExpressionFormat.length; i++) {\r\n            const currExpressionFormat = baseExpressionFormat[i];\r\n            const newExpression = currExpressionFormat.replaceAll('_{1', `_{${id.graphId}`);\r\n            if (expression.latex.includes(newExpression)) {\r\n                type = i;\r\n                break;\r\n            }\r\n        }\r\n        if (type === null) {\r\n            throw new Error('Cannot find conic type');\r\n        }\r\n        else {\r\n            return type;\r\n        }\r\n    }\r\n    throw Error(`Expression with id ${expression.id} is not a graph expression`);\r\n}\r\nfunction hasXDomain(cropType) {\r\n    return cropType <= 1;\r\n}\r\nfunction hasYDomain(cropType) {\r\n    return !(cropType % 2);\r\n}\r\nfunction getDomains(currId) {\r\n    return {\r\n        xMin: _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(`x_{${currId}ca}`),\r\n        yMin: _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(`y_{${currId}ca}`),\r\n        xMax: _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(`x_{${currId}cb}`),\r\n        yMax: _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(`y_{${currId}cb}`),\r\n    };\r\n}\r\nfunction parseDomains(domains) {\r\n    let [xMin, yMin, xMax, yMax] = [-Infinity, -Infinity, Infinity, Infinity];\r\n    for (let i = 0; i < domains.length; i++) {\r\n        const latex = domains[i];\r\n        const split = latex.split('<');\r\n        let variable = '';\r\n        if (split.includes('x')) {\r\n            variable = 'x';\r\n        }\r\n        else if (split.includes('y')) {\r\n            variable = 'y';\r\n        }\r\n        if (variable !== '') {\r\n            if (['x', 'y'].includes(split[0])) { // x < 2\r\n                if (variable === 'x') {\r\n                    xMax = parseFloat(split[1]);\r\n                }\r\n                else if (variable === 'y') {\r\n                    yMax = parseFloat(split[1]);\r\n                }\r\n            }\r\n            else if (['x', 'y'].includes(split[1]) && split.length === 2) { // 2 < x\r\n                if (variable === 'x') {\r\n                    xMin = parseFloat(split[0]);\r\n                }\r\n                else if (variable === 'y') {\r\n                    yMin = parseFloat(split[0]);\r\n                }\r\n            }\r\n            else if (['x', 'y'].includes(split[1]) && split.length === 3) { // 2 < x < 3\r\n                if (variable === 'x') {\r\n                    xMin = parseFloat(split[0]);\r\n                    xMax = parseFloat(split[2]);\r\n                }\r\n                else if (variable === 'y') {\r\n                    yMin = parseFloat(split[0]);\r\n                    yMax = parseFloat(split[2]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return { xMin, xMax, yMin, yMax };\r\n}\r\nfunction maxLinkedVariable(linkedVariables) {\r\n    let maxVariable = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(-Infinity);\r\n    linkedVariables.forEach((variable) => {\r\n        maxVariable = variable.value > maxVariable.value ? variable : maxVariable;\r\n    });\r\n    return maxVariable;\r\n}\r\nfunction minLinkedVariable(linkedVariables) {\r\n    let minVariable = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(Infinity);\r\n    linkedVariables.forEach((variable) => {\r\n        minVariable = variable.value < minVariable.value ? variable : minVariable;\r\n    });\r\n    return minVariable;\r\n}\r\nfunction minMax(variables) {\r\n    return {\r\n        min: minLinkedVariable(variables),\r\n        max: maxLinkedVariable(variables),\r\n    };\r\n}\r\nfunction simplify(_number, decimalPlaces) {\r\n    return parseFloat(_number.toFixed(decimalPlaces))\r\n        .toString();\r\n}\r\nfunction getVariablesNeeded(latex) {\r\n    return [...latex.matchAll(functionVariableRegex)];\r\n}\r\nfunction substitute(_latex) {\r\n    let latex = _latex;\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    for (let j = 0; j < variablesNeeded.length; j++) {\r\n        const variableNeeded = variablesNeeded[j][0];\r\n        latex = latex.replace(variableNeeded, simplify(getVariable(variableNeeded), 4));\r\n    }\r\n    return latex;\r\n}\r\nfunction generateBounds(_xMin, _yMin, _xMax, _yMax) {\r\n    const xMin = _xMin;\r\n    xMin.value = parseFloat(xMin.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision));\r\n    const yMin = _yMin;\r\n    yMin.value = parseFloat(yMin.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision));\r\n    const xMax = _xMax;\r\n    xMax.value = parseFloat(xMax.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision));\r\n    const yMax = _yMax;\r\n    yMax.value = parseFloat(yMax.value.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision));\r\n    const xBounds = { value: '', reference: '' };\r\n    const yBounds = { value: '', reference: '' };\r\n    if (xMin.value === -Infinity) {\r\n        if (xMax.value !== Infinity) {\r\n            xBounds.value = `\\\\left\\\\{x<${xMax.value}\\\\right\\\\}`;\r\n            xBounds.reference = `\\\\left\\\\{x<${xMax.reference}\\\\right\\\\}`;\r\n        }\r\n    }\r\n    else if (xMax.value === Infinity) {\r\n        xBounds.value = `\\\\left\\\\{${xMin.value}<x\\\\right\\\\}`;\r\n        xBounds.reference = `\\\\left\\\\{${xMin.reference}<x\\\\right\\\\}`;\r\n    }\r\n    else {\r\n        xBounds.value = `\\\\left\\\\{${xMin.value}<x<${xMax.value}\\\\right\\\\}`;\r\n        xBounds.reference = `\\\\left\\\\{${xMin.reference}<x<${xMax.reference}\\\\right\\\\}`;\r\n    }\r\n    if (yMin.value === -Infinity) {\r\n        if (yMax.value !== Infinity) {\r\n            yBounds.value = `\\\\left\\\\{y<${yMax.value}\\\\right\\\\}`;\r\n            yBounds.reference = `\\\\left\\\\{y<${yMax.reference}\\\\right\\\\}`;\r\n        }\r\n    }\r\n    else if (yMax.value === Infinity) {\r\n        yBounds.value = `\\\\left\\\\{${yMin.value}<y\\\\right\\\\}`;\r\n        yBounds.reference = `\\\\left\\\\{${yMin.reference}<y\\\\right\\\\}`;\r\n    }\r\n    else {\r\n        yBounds.value = `\\\\left\\\\{${yMin.value}<y<${yMax.value}\\\\right\\\\}`;\r\n        yBounds.reference = `\\\\left\\\\{${yMin.reference}<y<${yMax.reference}\\\\right\\\\}`;\r\n    }\r\n    return { value: `${xBounds.value}${yBounds.value}`, reference: `${xBounds.reference}${yBounds.reference}` };\r\n}\r\nfunction usesVariable(latex, _id) {\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    return variablesNeeded.some((variable) => {\r\n        if (variable) {\r\n            const newVariable = [...variable[0].matchAll(/[a-zA-Z]_{(\\d+)[a-zA-Z]*}/g)][0];\r\n            if (newVariable) {\r\n                return newVariable[1] === _id.toString();\r\n            }\r\n        }\r\n    });\r\n}\r\nfunction substituteFromId(_latex, graphId) {\r\n    let latex = _latex;\r\n    const variablesNeeded = getVariablesNeeded(latex);\r\n    for (let j = 0; j < variablesNeeded.length; j++) {\r\n        const variableNeeded = variablesNeeded[j][0];\r\n        if (usesVariable(variableNeeded, graphId)) {\r\n            const variableValue = simplify(getVariable(variableNeeded), 4);\r\n            latex = latex.replace(variableNeeded, `(${variableValue})`);\r\n        }\r\n    }\r\n    return latex;\r\n}\r\nfunction setVariable(variable, _value) {\r\n    let value = _value;\r\n    if (value instanceof LinkedVariable) {\r\n        value = value.value.toString();\r\n    }\r\n    else if (typeof value === 'number') {\r\n        value = value.toString();\r\n    }\r\n    else if (value == undefined) {\r\n        throw Error('undefined bruh what');\r\n    }\r\n    _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalVariablesObject[variable] = value;\r\n}\r\nfunction toId(expression, _id) {\r\n    return expression.replace(/_\\{\\d+([a-zA-Z]*)}/g, `_{${_id}$1}`);\r\n}\r\nfunction intersect(array1, array2) {\r\n    return array1.filter((value) => array2.includes(value));\r\n}\r\nfunction doesIntersect(array1, array2) {\r\n    const filteredArray = intersect(array1, array2);\r\n    return (filteredArray.length > 0);\r\n}\r\nfunction typeFilter(expressionList, graphType, types) {\r\n    const ceTypes = GraphTypes[graphType].expressionFormat;\r\n    return expressionList.filter((x) => doesIntersect(ceTypes[parseInt(x.id.split('_')[1], 10)].types, types));\r\n}\r\nfunction isBaseExpression(argument) {\r\n    return argument.type === \"expression\";\r\n}\r\nfunction isFinal(argument) {\r\n    return argument.isFinal;\r\n}\r\nfunction createGraphObject(expression) {\r\n    const id = getIdParts(expression.id);\r\n    const graphType = getGraphType(expression);\r\n    if (id.isEditable || id.isFinal) {\r\n        const Class = GraphTypes[graphType];\r\n        if (Class) {\r\n            return new Class(expression);\r\n        }\r\n        throw Error('Tried to convert non-conic to a conic');\r\n    }\r\n    throw Error('Tried to convert a graph object from a non-curve object');\r\n}\r\nfunction createConic(graphType, id, options) {\r\n    const expression = GraphTypes[graphType].expressionFormat;\r\n    const expressionsToSet = [];\r\n    const willHide = ['x_expression', 'y_expression', 'hidden'];\r\n    if (options) {\r\n        if (options.hideHandles) {\r\n            willHide.push('handle');\r\n        }\r\n        if (options.hidePoints) {\r\n            willHide.push('point');\r\n        }\r\n    }\r\n    for (let i = 0; i < expression.length; i++) {\r\n        const newExpression = expression[i];\r\n        let newExpressionLatex = newExpression.latex;\r\n        if (i === 0) {\r\n            if (GraphTypes[graphType].hasCrop) {\r\n                newExpressionLatex += '\\\\left\\\\{x_{1ca}<x<x_{1cb}\\\\right\\\\}\\\\left\\\\{y_{1ca}<y<y_{1cb}\\\\right\\\\}';\r\n            }\r\n        }\r\n        newExpressionLatex = newExpressionLatex.replace(/_\\{\\d+([a-zA-Z]*)}/g, `_{${id}$1}`);\r\n        if (doesIntersect(newExpression.types, ['var'])) {\r\n            const [variable] = newExpressionLatex.split('=');\r\n            const value = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalVariablesObject[toId(variable, id)];\r\n            newExpressionLatex = `${variable}=${simplify(parseFloat(value), 4)}`;\r\n        }\r\n        const hidden = doesIntersect(expression[i].types, willHide);\r\n        if (hidden) {\r\n            const split = newExpressionLatex.split('=');\r\n            const matches = [...split[0].matchAll(functionRegex)];\r\n            if (matches.length > 0) {\r\n                const [full, name, args] = matches[0];\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalFunctionsObject[name] = {\r\n                    id: `${id.toString()}_${i}`,\r\n                    args: args.split(','),\r\n                    definition: split[1],\r\n                };\r\n            }\r\n        }\r\n        const label = i === 0 ? JSON.stringify({\r\n            graphType\r\n        }) : \"\";\r\n        const expressionToAdd = {\r\n            id: `${id.toString()}_${i}`,\r\n            latex: newExpressionLatex,\r\n            color: 'BLACK',\r\n            hidden,\r\n            type: 'expression',\r\n            label\r\n        };\r\n        expressionsToSet.push(expressionToAdd);\r\n    }\r\n    _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.newGraph(id, expressionsToSet);\r\n}\r\n// createLineSegment(p1, p2, startId, {finalize: true})\r\nfunction createLineSegment(p1, p2, id, options) {\r\n    if (options?.finalize) {\r\n        const xMin = Math.min(p1.x, p2.x);\r\n        const yMin = Math.min(p1.y, p2.y);\r\n        const xMax = Math.max(p1.x, p2.x);\r\n        const yMax = Math.max(p1.y, p2.y);\r\n        const bounds = generateBounds(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(parseFloat(xMin.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision))), _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(-Infinity), _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(parseFloat(xMax.toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision))), _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.linkedVariable(Infinity)).value;\r\n        const m = parseFloat(((p1.y - p2.y) / (p1.x - p2.x)).toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision));\r\n        const b = parseFloat((p1.y - m * p1.x).toFixed(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.precision));\r\n        const newExpression = {\r\n            color: \"BLACK\",\r\n            hidden: false,\r\n            id: `final_${id}`,\r\n            latex: `y=${m}x${b >= 0 ? '+' : ''}${b}${bounds}`,\r\n            type: 'expression',\r\n            label: JSON.stringify({\r\n                graphType: 6\r\n            })\r\n        };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.setExpression(newExpression);\r\n    }\r\n    _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId += 1;\r\n}\r\nfunction createBezier(p1, p2, p3, p4, id, options) {\r\n    _graphs_Bezier__WEBPACK_IMPORTED_MODULE_9__.Bezier.setGraphVariables({\r\n        xa: p1.x,\r\n        ya: p1.y,\r\n        xb: p2.x,\r\n        yb: p2.y,\r\n        xc: p3.x,\r\n        yc: p3.y,\r\n        xd: p4.x,\r\n        yd: p4.y\r\n    }, id);\r\n    if (options?.finalize) {\r\n        let criticalPoints = [];\r\n        criticalPoints = (0,_bezierLib__WEBPACK_IMPORTED_MODULE_8__.getCriticalPoints)(p1, p2, p3, p4);\r\n        if (criticalPoints.length === 1) {\r\n            const criticalPoint = criticalPoints[0];\r\n            // criticalPoints = [criticalPoint / 2, criticalPoint, (1 + criticalPoint) / 2]\r\n        }\r\n        for (let i = 0; i < criticalPoints.length + 1; i++) {\r\n            const arr = [0, ...criticalPoints, 1];\r\n            const tValues = [\r\n                (4 * arr[i] + 0 * arr[i + 1]) / 4,\r\n                (3 * arr[i] + 1 * arr[i + 1]) / 4,\r\n                (2 * arr[i] + 2 * arr[i + 1]) / 4,\r\n                (1 * arr[i] + 3 * arr[i + 1]) / 4,\r\n                (0 * arr[i] + 4 * arr[i + 1]) / 4,\r\n            ];\r\n            const _tPoints = tValues.map((t) => (0,_bezierLib__WEBPACK_IMPORTED_MODULE_8__.evaluateBezier)(p1, p2, p3, p4, t));\r\n            const tPoints = {\r\n                x: tValues.map((t, index) => _tPoints[index].x),\r\n                y: tValues.map((t, index) => _tPoints[index].y),\r\n            };\r\n            const minMax = {\r\n                xMin: Math.min(...tPoints.x),\r\n                yMin: Math.min(...tPoints.y),\r\n                xMax: Math.max(...tPoints.x),\r\n                yMax: Math.max(...tPoints.y),\r\n            };\r\n            const variables = (0,_conicLib__WEBPACK_IMPORTED_MODULE_11__.getConicFit)(_tPoints);\r\n            const { A, B, C, D, E, F } = variables;\r\n            let graphType = 0;\r\n            if (A > 0) {\r\n                if (C > 0) {\r\n                    if (A === C) { // Circle\r\n                        graphType = 0;\r\n                    }\r\n                    else { // Ellipse\r\n                        graphType = 3;\r\n                    }\r\n                }\r\n                else if (C === 0) { // Vertical Parabola\r\n                    graphType = 2;\r\n                }\r\n                else if (C < 0) { // Hyperbola\r\n                    const delta = A * (C * D ** 2 + A * E ** 2 - 4 * A * C * F);\r\n                    if (delta < 0) {\r\n                        graphType = 4;\r\n                    }\r\n                    else {\r\n                        graphType = 5;\r\n                    }\r\n                }\r\n            }\r\n            else if (A === 0) {\r\n                if (C > 0) { // Horizontal Parabola\r\n                    graphType = 1;\r\n                }\r\n                else if (C === 0) { // Line\r\n                    graphType = 6;\r\n                }\r\n                else if (C < 0) { // Horizontal Parabola\r\n                    graphType = 1;\r\n                }\r\n            }\r\n            else if (A < 0) {\r\n                if (C > 0) { // Hyperbola\r\n                    const delta = A * (C * D ** 2 + A * E ** 2 - 4 * A * C * F);\r\n                    if (delta < 0) {\r\n                        graphType = 4;\r\n                    }\r\n                    else {\r\n                        graphType = 5;\r\n                    }\r\n                }\r\n                else if (C === 0) { // Vertical Parabola\r\n                    graphType = 2;\r\n                }\r\n                else if (C < 0) {\r\n                    if (A === C) { // Circle\r\n                        graphType = 0;\r\n                    }\r\n                    else { // Ellipse\r\n                    }\r\n                    graphType = 3;\r\n                }\r\n            }\r\n            const Class = GraphTypes[graphType];\r\n            const newVar = Class.fromGeneral(variables);\r\n            if (newVar) {\r\n                Class.setGraphVariables(newVar, _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId);\r\n                if (Object.values(newVar).every((x) => !Number.isNaN(x) && Number.isFinite(x))) {\r\n                    if ((minMax.yMax - minMax.yMin < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes) && (minMax.xMax - minMax.xMin < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes)) {\r\n                        console.log('bounds smaller than minres');\r\n                    }\r\n                    else {\r\n                        if (graphType === 4 || graphType === 5) {\r\n                            if (newVar.a < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes ** 2 && newVar.b < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes ** 2) {\r\n                                console.log('hypersmall');\r\n                            }\r\n                            else {\r\n                                (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId, graphType, newVar, minMax, { hideAll: true, logical: true, finalize: true });\r\n                                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId += 1;\r\n                            }\r\n                        }\r\n                        else {\r\n                            (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId, graphType, newVar, minMax, { hideAll: true, logical: true, finalize: true });\r\n                            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId += 1;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else {\r\n        createConic(7, id, options);\r\n    }\r\n}\r\nfunction getDomainsFromLatex(latex) {\r\n    return [\r\n        ...latex.matchAll(/\\\\left\\\\{((?:[-+]?\\d+\\.?\\d*<)?[xy](?:<[-+]?\\d+\\.?\\d*)?)\\\\right\\\\}/g),\r\n    ].map((domain) => domain[1]);\r\n}\r\nfunction transformVariables(graphType, variables) {\r\n    return GraphTypes[graphType].transformVariables(variables);\r\n}\r\nfunction dist(a, b) {\r\n    return Math.sqrt((a.x - b.x) ** 2 + (a.y - b.y) ** 2);\r\n}\r\nfunction hax(_paths) {\r\n    let startId = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId;\r\n    const paths = _paths;\r\n    const stroke = paths.command;\r\n    const { dx, dy, color } = paths.details;\r\n    let startPos;\r\n    if (startId !== 1) {\r\n        // finalize(`${startId - 1}_0`, startId - 1)\r\n    }\r\n    if (stroke.command === 'moveto') {\r\n        if (paths.details.isStart) {\r\n            startPos = {\r\n                x: stroke.x,\r\n                y: -stroke.y,\r\n            };\r\n        }\r\n    }\r\n    else if (stroke.command === 'horizontal lineto' || stroke.command === 'vertical lineto' || stroke.command === 'lineto') {\r\n        const p1 = { x: stroke.x0 + dx, y: -stroke.y0 - dy };\r\n        const p2 = { x: stroke.x + dx, y: -stroke.y - dy };\r\n        if (dist(p1, p2) > _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes) {\r\n            const defArray = [\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes)\r\n            ].sort().toString();\r\n            if (!_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.has(defArray)) {\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.add(defArray);\r\n                createLineSegment(p1, p2, startId, { finalize: true });\r\n            }\r\n            else {\r\n                console.log('skip');\r\n            }\r\n        }\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic = { x: 0, y: 0 };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic = { x: 0, y: 0 };\r\n    }\r\n    else if (stroke.command === 'curveto') {\r\n        const p0 = { x: stroke.x0 + dx, y: -stroke.y0 - dy };\r\n        const p1 = { x: stroke.x1 + dx, y: -stroke.y1 - dy };\r\n        const p2 = { x: stroke.x2 + dx, y: -stroke.y2 - dy };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic = p2;\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic = { x: 0, y: 0 };\r\n        const p3 = { x: stroke.x + dx, y: -stroke.y - dy };\r\n        const minMax = (0,_bezierLib__WEBPACK_IMPORTED_MODULE_8__.bezierMinMax)(p0, p1, p2, p3);\r\n        if ((minMax.max.y - minMax.min.y < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes) && (minMax.max.x - minMax.min.x < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes)) {\r\n        }\r\n        else {\r\n            const defArray = [\r\n                Math.floor(p0.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            ].sort().toString();\r\n            if (!_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.has(defArray)) {\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.add(defArray);\r\n                createBezier(p0, p1, p2, p3, startId, { hideHandles: true, hidePoints: true, finalize: true });\r\n            }\r\n            else {\r\n                console.log('skip');\r\n            }\r\n        }\r\n    }\r\n    else if (stroke.command === 'smooth curveto') {\r\n        const p0 = { x: stroke.x0 + dx, y: -stroke.y0 - dy };\r\n        const p1 = {\r\n            x: 2 * stroke.x0 - _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic.x + 2 * dx,\r\n            y: 2 * -stroke.y0 - _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic.y - 2 * dy,\r\n        };\r\n        const p2 = { x: stroke.x2 + dx, y: -stroke.y2 - dy };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic = p2;\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic = { x: 0, y: 0 };\r\n        const p3 = { x: stroke.x + dx, y: -stroke.y - dy };\r\n        const minMax = (0,_bezierLib__WEBPACK_IMPORTED_MODULE_8__.bezierMinMax)(p0, p1, p2, p3);\r\n        if ((minMax.max.y - minMax.min.y < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes) && (minMax.max.x - minMax.min.x < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes)) {\r\n        }\r\n        else {\r\n            const defArray = [\r\n                Math.floor(p0.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            ].sort().toString();\r\n            if (!_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.has(defArray)) {\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.add(defArray);\r\n                createBezier(p0, p1, p2, p3, startId, { hideHandles: true, hidePoints: true, finalize: true });\r\n            }\r\n            else {\r\n                console.log('skip');\r\n            }\r\n        }\r\n    }\r\n    else if (stroke.command === 'elliptical arc') {\r\n        const r = stroke.rx;\r\n        const centerParam = (0,_svgLib__WEBPACK_IMPORTED_MODULE_10__.svgArcToCenterParam)(stroke.x0, stroke.y0, r, r, 0, stroke.largeArc, stroke.sweep, stroke.x, stroke.y);\r\n        centerParam.cx = centerParam.cx + dx;\r\n        centerParam.cy = -centerParam.cy - dy;\r\n        const p1x = stroke.x0 + dx;\r\n        const p1y = -stroke.y0 - dy;\r\n        const p2x = stroke.x + dx;\r\n        const p2y = -stroke.y - dy;\r\n        const defArray = [\r\n            Math.floor(p1x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            Math.floor(p1y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            Math.floor(p2x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            Math.floor(p2y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            Math.floor(centerParam.cx / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            Math.floor(centerParam.cy / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n        ].sort().toString();\r\n        if (!_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.has(defArray)) {\r\n            _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.add(defArray);\r\n            (0,_index_user__WEBPACK_IMPORTED_MODULE_0__.createGraphWithBounds)(startId, 0, {\r\n                h: centerParam.cx,\r\n                k: centerParam.cy,\r\n                r: r\r\n            }, {\r\n                xMin: Math.min(p1x, p2x),\r\n                yMin: Math.min(p1y, p2y),\r\n                xMax: Math.max(p1x, p2x),\r\n                yMax: Math.max(p1y, p2y),\r\n            }, { hideAll: true, finalize: true });\r\n        }\r\n        else {\r\n            console.log('skip');\r\n        }\r\n        startId += 1;\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.globalId = startId;\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic = { x: 0, y: 0 };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic = { x: 0, y: 0 };\r\n    }\r\n    else if (stroke.command === 'closepath') {\r\n        if (stroke.x0 != stroke.x && stroke.y0 != stroke.y) {\r\n            const p0 = { x: stroke.x0 + dx, y: -stroke.y0 - dy };\r\n            const p1 = { x: stroke.x + dx, y: -stroke.y - dy };\r\n            const defArray = [\r\n                Math.floor(p0.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            ].sort().toString();\r\n            if (!_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.has(defArray)) {\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.add(defArray);\r\n                createLineSegment(p0, p1, startId, { finalize: true });\r\n            }\r\n            else {\r\n                console.log('skip');\r\n            }\r\n        }\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic = { x: 0, y: 0 };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic = { x: 0, y: 0 };\r\n    }\r\n    else if (stroke.command === 'quadratic curveto') {\r\n        const p0 = { x: stroke.x0 + dx, y: -stroke.y0 - dy };\r\n        let p1 = { x: stroke.x1 + dx, y: -stroke.y1 - dy };\r\n        const p3 = { x: stroke.x + dx, y: -stroke.y - dy };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic = { x: p1.x, y: p1.y };\r\n        p1 = {\r\n            x: p0.x / 3 + 2 * p1.x / 3,\r\n            y: p0.y / 3 + 2 * p1.y / 3,\r\n        };\r\n        const p2 = {\r\n            x: 2 * p1.x / 3 + p3.x / 3,\r\n            y: 2 * p1.y / 3 + p3.y / 3,\r\n        };\r\n        const minMax = (0,_bezierLib__WEBPACK_IMPORTED_MODULE_8__.bezierMinMax)(p0, p1, p2, p3);\r\n        if ((minMax.max.y - minMax.min.y < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes) && (minMax.max.x - minMax.min.x < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes)) {\r\n        }\r\n        else {\r\n            const defArray = [\r\n                Math.floor(p0.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            ].sort().toString();\r\n            if (!_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.has(defArray)) {\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.add(defArray);\r\n                createBezier(p0, p1, p2, p3, startId, { hideHandles: true, hidePoints: true, finalize: true });\r\n            }\r\n            else {\r\n                console.log('skip');\r\n            }\r\n        }\r\n    }\r\n    else if (stroke.command === 'smooth quadratic curveto') {\r\n        const p0 = { x: stroke.x0 + dx, y: -stroke.y0 - dy };\r\n        let p1 = {\r\n            x: 2 * stroke.x0 - _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic.x + 2 * dx,\r\n            y: 2 * -stroke.y0 - _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic.y - 2 * dy,\r\n        };\r\n        const p3 = { x: stroke.x + dx, y: -stroke.y - dy };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.cubic = { x: 0, y: 0 };\r\n        _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.lastControlPoint.quadratic = { x: p1.x, y: p1.y };\r\n        p1 = {\r\n            x: p0.x / 3 + 2 * p1.x / 3,\r\n            y: p0.y / 3 + 2 * p1.y / 3,\r\n        };\r\n        const p2 = {\r\n            x: 2 * p1.x / 3 + p3.x / 3,\r\n            y: 2 * p1.y / 3 + p3.y / 3,\r\n        };\r\n        const minMax = (0,_bezierLib__WEBPACK_IMPORTED_MODULE_8__.bezierMinMax)(p0, p1, p2, p3);\r\n        if ((minMax.max.y - minMax.min.y < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes) && (minMax.max.x - minMax.min.x < _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes)) {\r\n        }\r\n        else {\r\n            const defArray = [\r\n                Math.floor(p0.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p1.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p2.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.x / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n                Math.floor(p3.y / _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.minRes),\r\n            ].sort().toString();\r\n            if (!_index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.has(defArray)) {\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.doneLines.add(defArray);\r\n                createBezier(p0, p1, p2, p3, startId, { hideHandles: true, hidePoints: true, finalize: true });\r\n            }\r\n            else {\r\n                console.log('skip');\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction transformBezier(id) {\r\n    if (id) {\r\n        const expression = _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.getExpression(id);\r\n        if (expression && isBaseExpression(expression)) {\r\n            const graphObject = createGraphObject(expression);\r\n            if (graphObject instanceof _graphs_Bezier__WEBPACK_IMPORTED_MODULE_9__.Bezier) {\r\n                const { p1, p2, p3, p4 } = graphObject.getControlPoints();\r\n                createBezier(p1, p2, p3, p4, graphObject.graphId, { finalize: true });\r\n                _index_user__WEBPACK_IMPORTED_MODULE_0__.MyCalc.deleteById(graphObject.id);\r\n            }\r\n        }\r\n    }\r\n}\r\nfunction substituteToAll(expressions, graphId) {\r\n    const expressionList = [];\r\n    for (let i = 0; i < expressions.length; i++) {\r\n        const expression = expressions[i];\r\n        if (isBaseExpression(expression)) {\r\n            if (expression.latex) {\r\n                if (usesVariable(expression.latex, graphId)) {\r\n                    expression.latex = substituteFromId(expression.latex, graphId);\r\n                    expressionList.push(expression);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    return expressionList;\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/lib.ts?");

/***/ }),

/***/ "./src/svgLib.ts":
/*!***********************!*\
  !*** ./src/svgLib.ts ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"svgArcToCenterParam\": () => (/* binding */ svgArcToCenterParam)\n/* harmony export */ });\n// svg : [A | a] (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\r\nfunction radian(ux, uy, vx, vy) {\r\n    const dot = ux * vx + uy * vy;\r\n    const mod = Math.sqrt((ux * ux + uy * uy) * (vx * vx + vy * vy));\r\n    let rad = Math.acos(dot / mod);\r\n    if (ux * vy - uy * vx < 0.0) {\r\n        rad = -rad;\r\n    }\r\n    return rad;\r\n}\r\n//conversion_from_endpoint_to_center_parameterization\r\n//sample :  svgArcToCenterParam(200,200,50,50,0,1,1,300,200)\r\n// x1 y1 rx ry φ fA fS x2 y2\r\nfunction svgArcToCenterParam(x1, y1, rx, ry, phi, fA, fS, x2, y2) {\r\n    let deltaAngle, endAngle;\r\n    const PIx2 = Math.PI * 2.0;\r\n    if (rx < 0) {\r\n        rx = -rx;\r\n    }\r\n    if (ry < 0) {\r\n        ry = -ry;\r\n    }\r\n    if (rx == 0.0 || ry == 0.0) { // invalid arguments\r\n        throw Error('rx and ry can not be 0');\r\n    }\r\n    const s_phi = Math.sin(phi);\r\n    const c_phi = Math.cos(phi);\r\n    const hd_x = (x1 - x2) / 2.0; // half diff of x\r\n    const hd_y = (y1 - y2) / 2.0; // half diff of y\r\n    const hs_x = (x1 + x2) / 2.0; // half sum of x\r\n    const hs_y = (y1 + y2) / 2.0; // half sum of y\r\n    // F6.5.1\r\n    const x1_ = c_phi * hd_x + s_phi * hd_y;\r\n    const y1_ = c_phi * hd_y - s_phi * hd_x;\r\n    // F.6.6 Correction of out-of-range radii\r\n    //   Step 3: Ensure radii are large enough\r\n    const lambda = (x1_ * x1_) / (rx * rx) + (y1_ * y1_) / (ry * ry);\r\n    if (lambda > 1) {\r\n        rx = rx * Math.sqrt(lambda);\r\n        ry = ry * Math.sqrt(lambda);\r\n    }\r\n    const rxry = rx * ry;\r\n    const rxy1_ = rx * y1_;\r\n    const ryx1_ = ry * x1_;\r\n    const sum_of_sq = rxy1_ * rxy1_ + ryx1_ * ryx1_; // sum of square\r\n    if (!sum_of_sq) {\r\n        throw Error('start point can not be same as end point');\r\n    }\r\n    let coe = Math.sqrt(Math.abs((rxry * rxry - sum_of_sq) / sum_of_sq));\r\n    if (fA == fS) {\r\n        coe = -coe;\r\n    }\r\n    // F6.5.2\r\n    const cx_ = coe * rxy1_ / ry;\r\n    const cy_ = -coe * ryx1_ / rx;\r\n    // F6.5.3\r\n    const cx = c_phi * cx_ - s_phi * cy_ + hs_x;\r\n    const cy = s_phi * cx_ + c_phi * cy_ + hs_y;\r\n    const xcr1 = (x1_ - cx_) / rx;\r\n    const xcr2 = (x1_ + cx_) / rx;\r\n    const ycr1 = (y1_ - cy_) / ry;\r\n    const ycr2 = (y1_ + cy_) / ry;\r\n    // F6.5.5\r\n    const startAngle = radian(1.0, 0.0, xcr1, ycr1);\r\n    // F6.5.6\r\n    deltaAngle = radian(xcr1, ycr1, -xcr2, -ycr2);\r\n    while (deltaAngle > PIx2) {\r\n        deltaAngle -= PIx2;\r\n    }\r\n    while (deltaAngle < 0.0) {\r\n        deltaAngle += PIx2;\r\n    }\r\n    if (fS == false || fS == 0) {\r\n        deltaAngle -= PIx2;\r\n    }\r\n    endAngle = startAngle + deltaAngle;\r\n    while (endAngle > PIx2) {\r\n        endAngle -= PIx2;\r\n    }\r\n    while (endAngle < 0.0) {\r\n        endAngle += PIx2;\r\n    }\r\n    const outputObj = {\r\n        cx: cx,\r\n        cy: cy,\r\n        startAngle: startAngle,\r\n        deltaAngle: deltaAngle,\r\n        endAngle: endAngle,\r\n        clockwise: (fS == true || fS == 1)\r\n    };\r\n    return outputObj;\r\n}\r\n\n\n//# sourceURL=webpack://graph-art-creator/./src/svgLib.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.user.ts");
/******/ 	
/******/ })()
;